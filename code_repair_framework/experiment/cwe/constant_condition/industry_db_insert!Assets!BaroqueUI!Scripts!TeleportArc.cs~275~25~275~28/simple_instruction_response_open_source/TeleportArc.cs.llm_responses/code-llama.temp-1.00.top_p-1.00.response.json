{
    "code_repairing_0": "Here is the fixed code for the `SetColor` method:\n```\npublic void SetColor(Color color)\n{\n    for (int i = 0; i < segmentCount; ++i)\n    {\n#if (UNITY_5_4)\n        lineRenderers[i].SetColors(color, color);\n#else\n        lineRenderers[i].startColor = color;\n        lineRenderers[i].endColor = color;\n#endif\n    }\n}\n```\nThe code was modified to use the `lineRenderers` array, and the `Color` parameter was passed to the `SetColors` method for both start and end colors.",
    "code_repairing_1": "FIXED CODE:\n\n\n\n\n\n\n\n\n\n\nusing UnityEngine;\n\nnamespace BaroqueUI\n{\n    \n    class TeleportArc : MonoBehaviour\n    {\n        public int segmentCount = 60;\n        public float thickness = 0.01f;\n\n        [Tooltip(\"The amount of time in seconds to predict the motion of the projectile.\")]\n        public float arcDuration = 3.0f;\n\n        [Tooltip(\"The amount of time in seconds between each segment of the projectile.\")]\n        public float segmentBreak = 0.025f;\n\n        [Tooltip(\"The speed at which the line segments of the arc move.\")]\n        public float arcSpeed = 0.2f;\n\n        public Material material = null;\n\n        [HideInInspector]\n        public int traceLayerMask = 0;\n\n        \n        private LineRenderer[] lineRenderers;\n        private Timed.Time arcTimeOffset = Timed.Time.Zero;\n        private float prevThickness = 0.0f;\n        private int prevSegmentCount = 0;\n        private bool showArc = true;\n        private Vector3 startPos;\n        private Vector3 projectileVelocity;\n        private bool useGravity = true;\n        private Transform arcObjectsTransfrom;\n        private bool arcInvalid = false;\n\n\n        \n        void Start()\n        {\n            arcTimeOffset = Timed.time;\n        }\n\n\n        \n        void Update()\n        {\n            if (thickness != prevThickness || segmentCount != prevSegmentCount)\n            {\n                CreateLineRendererObjects();\n                prevThickness = thickness;\n                prevSegmentCount = segmentCount;\n            }\n        }\n\n\n        \n        private void CreateLineRendererObjects()\n        {\n            \n            if (arcObjectsTransfrom != null)\n            {\n                Destroy((GameObject)arcObjectsTransfrom.gameObject);\n            }\n\n            GameObject arcObjectsParent = new GameObject(\"ArcObjects\");\n            arcObjectsTransfrom = arcObjectsParent.transform;\n            arcObjectsTransfrom.SetParent(this.transform);\n\n            \n            lineRenderers = new LineRenderer[segmentCount];\n            for (int i = 0; i < segmentCount; ++i)\n            {\n                GameObject newObject = new GameObject(\"LineRenderer_\" + i);\n                newObject.transform.SetParent(arcObjectsTransfrom);\n\n                lineRenderers[i] = newObject.AddComponent<LineRenderer>();\n\n                lineRenderers[i].receiveShadows = false;\n                lineRenderers[i].reflectionProbeUsage = UnityEngine.Rendering.ReflectionProbeUsage.Off;\n                lineRenderers[i].lightProbeUsage = UnityEngine.Rendering.LightProbeUsage.Off;\n                lineRenderers[i].shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;\n                lineRenderers[i].material = material;\n#if (UNITY_5_4)\n\t\t\t\tlineRenderers[i].SetWidth( thickness, thickness );\n#else\n                lineRenderers[i].startWidth = thickness;\n                lineRenderers[i].endWidth = thickness;\n#endif\n                lineRenderers[i].enabled = false;\n            }\n        }\n\n\n        \n        public void SetArcData(Vector3 position, Vector3 velocity, bool gravity, bool pointerAtBadAngle)\n        {\n            startPos = position;\n            projectileVelocity = velocity;\n            useGravity = gravity;\n\n            if (arcInvalid && !pointerAtBadAngle)\n            {\n                arcTimeOffset = Timed.time;\n            }\n            arcInvalid = pointerAtBadAngle;\n        }\n\n\n        \n        public void Show()\n        {\n            showArc = true;\n            if (lineRenderers == null)\n            {\n                CreateLineRendererObjects();\n            }\n        }\n\n\n        \n        public void Hide()\n        {\n            \n            if (showArc)\n            {\n                HideLineSegments(0, segmentCount);\n            }\n            showArc = false;\n        }\n\n\n        \n        \n        \n        public bool DrawArc(out RaycastHit hitInfo)\n        {\n            float timeStep = arcDuration / segmentCount;\n\n            float currentTimeOffset = (Timed.time - arcTimeOffset) * arcSpeed;\n\n            \n            if (currentTimeOffset > (timeStep + segmentBreak))\n            {\n                arcTimeOffset = Timed.time;\n                currentTimeOffset = 0.0f;\n            }\n\n            float segmentStartTime = currentTimeOffset;\n\n            float arcHitTime = FindProjectileCollision(out hitInfo);\n\n            if (arcInvalid)\n            {\n                \n                lineRenderers[0].enabled = true;\n                lineRenderers[0].SetPosition(0, GetArcPositionAtTime(0.0f));\n                lineRenderers[0].SetPosition(1, GetArcPositionAtTime(arcHitTime < timeStep ? arcHitTime : timeStep));\n\n                HideLineSegments(1, segmentCount);\n            }\n            else\n            {\n                \n                int loopStartSegment = 0;\n                if (segmentStartTime > segmentBreak)\n                {\n                    float firstSegmentEndTime = currentTimeOffset - segmentBreak;\n                    if (arcHitTime < firstSegmentEndTime)\n                    {\n                        firstSegmentEndTime = arcHitTime;\n                    }\n                    DrawArcSegment(0, 0.0f, firstSegmentEndTime);\n\n                    loopStartSegment = 1;\n                }\n\n                bool stopArc = false;\n                int currentSegment = 0;\n                if (segmentStartTime < arcHitTime)\n                {\n                    for (currentSegment = loopStartSegment; currentSegment < segmentCount; ++currentSegment)\n                    {\n                        \n                        float segmentEndTime = segmentStartTime + timeStep;\n                        if (segmentEndTime >= arcDuration)\n                        {\n                            segmentEndTime = arcDuration;\n                            stopArc = true;\n                        }\n\n                        if (segmentEndTime >= arcHitTime)\n                        {\n                            segmentEndTime = arcHitTime;\n                            stopArc = true;\n                        }\n\n                        DrawArcSegment(currentSegment, segmentStartTime, segmentEndTime);\n\n                        segmentStartTime += timeStep + segmentBreak;\n\n                        \n                        if (stopArc || segmentStartTime >= arcDuration || segmentStartTime >= arcHitTime)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    currentSegment--;\n                }\n\n                \n                HideLineSegments(currentSegment + 1, segmentCount);\n            }\n\n            return arcHitTime != float.MaxValue;\n        }\n\n\n        \n        private void DrawArcSegment(int index, float startTime, float endTime)\n        {\n            lineRenderers[index].enabled = true;\n            lineRenderers[index].SetPosition(0, GetArcPositionAtTime(startTime));\n            lineRenderers[index].SetPosition(1, GetArcPositionAtTime(endTime));\n        }\n\n\n        \n        public void SetColor(Color color)\n        {\n            for (int i = 0; i < segmentCount; ++i)\n            {\n#if (UNITY_5_4)\n\t\t\t\tlineRenderers[i].SetColors( color, color );\n#else\n                lineRenderers[i].startColor = color;\n                lineRenderers[i].endColor = color;\n#endif\n            }\n        }\n\n\n        \n        private float FindProjectileCollision(out RaycastHit hitInfo)\n        {\n            float timeStep = arcDuration / segmentCount;\n            float segmentStartTime = 0.0f;\n\n            hitInfo = new RaycastHit();\n\n            Vector3 segmentStartPos = GetArcPositionAtTime(segmentStartTime);\n            for (int i = 0; i < segmentCount; ++i)\n            {\n                float segmentEndTime = segmentStartTime + timeStep;\n                Vector3 segmentEndPos = GetArcPositionAtTime(segmentEndTime);\n\n                if (Physics.Linecast(segmentStartPos, segmentEndPos, out hitInfo, traceLayerMask))\n                {\n#if",
    "code_repairing_2": "FIXED CODE:\n\nusing UnityEngine;\n\nnamespace BaroqueUI\n{\n    class TeleportArc : MonoBehaviour\n    {\n        public int segmentCount = 60;\n        public float thickness = 0.01f;\n\n        [Tooltip(\"The amount of time in seconds to predict the motion of the projectile.\")]\n        public float arcDuration = 3.0f;\n\n        [Tooltip(\"The amount of time in seconds between each segment of the projectile.\")]\n        public float segmentBreak = 0.025f;\n\n        [Tooltip(\"The speed at which the line segments of the arc move.\")]\n        public float arcSpeed = 0.2f;\n\n        public Material material = null;\n\n        [HideInInspector]\n        public int traceLayerMask = 0;\n\n        private LineRenderer[] lineRenderers;\n        private Timed.Time arcTimeOffset = Timed.Time.Zero;\n        private float prevThickness = 0.0f;\n        private int prevSegmentCount = 0;\n        private bool showArc = true;\n        private Vector3 startPos;\n        private Vector3 projectileVelocity;\n        private bool useGravity = true;\n        private Transform arcObjectsTransfrom;\n        private bool arcInvalid = false;\n\n        void Start()\n        {\n            arcTimeOffset = Timed.Time.Zero;\n        }\n\n        void Update()\n        {\n            if (thickness != prevThickness || segmentCount != prevSegmentCount)\n            {\n                CreateLineRendererObjects();\n                prevThickness = thickness;\n                prevSegmentCount = segmentCount;\n            }\n        }\n\n        private void CreateLineRendererObjects()\n        {\n            if (arcObjectsTransfrom != null)\n            {\n                Destroy((GameObject)arcObjectsTransfrom.gameObject);\n            }\n\n            GameObject arcObjectsParent = new GameObject(\"ArcObjects\");\n            arcObjectsTransfrom = arcObjectsParent.transform;\n            arcObjectsTransfrom.SetParent(this.transform);\n\n            lineRenderers = new LineRenderer[segmentCount];\n\n            for (int i = 0; i < segmentCount; ++i)\n            {\n                GameObject newObject = new GameObject(\"LineRenderer_\" + i);\n                newObject.transform.SetParent(arcObjectsTransfrom);\n                lineRenderers[i] = newObject.AddComponent<LineRenderer>();\n\n                lineRenderers[i].receiveShadows = false;\n                lineRenderers[i].reflectionProbeUsage = UnityEngine.Rendering.ReflectionProbeUsage.Off;\n                lineRenderers[i].lightProbeUsage = UnityEngine.Rendering.LightProbeUsage.Off;\n                lineRenderers[i].shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;\n                lineRenderers[i].material = material;\n\n#if (UNITY_5_4)\n                lineRenderers[i].SetWidth(thickness, thickness);\n#else\n                lineRenderers[i].startWidth = thickness;\n                lineRenderers[i].endWidth = thickness;\n#endif\n                lineRenderers[i].enabled = false;\n            }\n        }\n\n        public void SetArcData(Vector3 position, Vector3 velocity, bool gravity, bool pointerAtBadAngle)\n        {\n            startPos = position;\n            projectileVelocity = velocity;\n            useGravity = gravity;\n\n            if (arcInvalid && !pointerAtBadAngle)\n            {\n                arcTimeOffset = Timed.time;\n            }\n            arcInvalid = pointerAtBadAngle;\n        }\n\n        public void Show()\n        {\n            showArc = true;\n            if (lineRenderers == null)\n            {\n                CreateLineRendererObjects();\n            }\n        }\n\n        public void Hide()\n        {\n            if (showArc)\n            {\n                HideLineSegments(0, segmentCount);\n            }\n            showArc = false;\n        }\n\n        public bool DrawArc(out RaycastHit hitInfo)\n        {\n            float timeStep = arcDuration / segmentCount;\n            float currentTimeOffset = (Timed.time - arcTimeOffset) * arcSpeed;\n\n            if (currentTimeOffset > (timeStep + segmentBreak))\n            {\n                arcTimeOffset = Timed.time;\n                currentTimeOffset = 0.0f;\n            }\n\n            float segmentStartTime = currentTimeOffset;\n\n            float arcHitTime = FindProjectileCollision(out hitInfo);\n\n            if (arcInvalid)\n            {\n                lineRenderers[0].enabled = true;\n                lineRenderers[0].SetPosition(0, GetArcPositionAtTime(0.0f));\n                lineRenderers[0].SetPosition(1, GetArcPositionAtTime(arcHitTime < timeStep ? arcHitTime : timeStep));\n\n                HideLineSegments(1, segmentCount);\n            }\n            else\n            {\n                int loopStartSegment = 0;\n                if (segmentStartTime > segmentBreak)\n                {\n                    float firstSegmentEndTime = currentTimeOffset - segmentBreak;\n                    if (arcHitTime < firstSegmentEndTime)\n                    {\n                        firstSegmentEndTime = arcHitTime;\n                    }\n                    DrawArcSegment(0, 0.0f, firstSegmentEndTime);\n\n                    loopStartSegment = 1;\n                }\n\n                bool stopArc = false;\n                int currentSegment = 0;\n                if (segmentStartTime < arcHitTime)\n                {\n                    for (currentSegment = loopStartSegment; currentSegment < segmentCount; ++currentSegment)\n                    {\n                        float segmentEndTime = segmentStartTime + timeStep;\n                        if (segmentEndTime >= arcDuration)\n                        {\n                            segmentEndTime = arcDuration;\n                            stopArc = true;\n                        }\n\n                        if (segmentEndTime >= arcHitTime)\n                        {\n                            segmentEndTime = arcHitTime;\n                            stopArc = true;\n                        }\n\n                        DrawArcSegment(currentSegment, segmentStartTime, segmentEndTime);\n\n                        segmentStartTime += timeStep + segmentBreak;\n\n                        if (stopArc || segmentStartTime >= arcDuration || segmentStartTime >= arcHitTime)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    currentSegment--;\n                }\n\n                HideLineSegments(currentSegment + 1, segmentCount);\n            }\n\n            return arcHitTime != float.MaxValue;\n        }\n\n        private void DrawArcSegment(int index, float startTime, float endTime)\n        {\n            lineRenderers[index].enabled = true;\n            lineRenderers[index].SetPosition(0, GetArcPositionAtTime(startTime));\n            lineRenderers[index].SetPosition(1, GetArcPositionAtTime(endTime));\n        }\n\n        public void SetColor(Color color)\n        {\n            for (int i = 0; i < segmentCount; ++i)\n            {\n#if (UNITY_5_4)\n                lineRenderers[i].SetColors(color, color);\n#else\n                lineRenderers[i].startColor = color;\n                lineRenderers[i].endColor = color;\n#endif\n            }\n        }\n\n        private float FindProjectileCollision(out RaycastHit hitInfo)\n        {\n            float timeStep = arcDuration / segmentCount;\n            float segmentStartTime = 0.0f;\n\n            hitInfo = new RaycastHit();\n\n            Vector3 segmentStartPos = GetArcPositionAtTime(segmentStartTime);\n            for (int i = 0; i < segmentCount; ++i)\n            {\n                float segmentEndTime = segmentStartTime + timeStep;\n                Vector3 segmentEndPos = GetArcPositionAtTime(segmentEndTime);\n\n                if (Physics.Linecast(segmentStartPos, segmentEndPos, out hitInfo, traceLayerMask))\n                {\n#if false\n                    if (hitInfo.collider.GetComponent<IgnoreTeleportTrace>() == null)\n#else",
    "code_repairing_3": "Here's the fixed code:\n```\nusing UnityEngine;\n\nnamespace BaroqueUI {\n    class TeleportArc : MonoBehaviour\n    {\n        public int segmentCount = 60;\n        public float thickness = 0.01f;\n\n        [Tooltip(\"The amount of time in seconds to predict the motion of the projectile.\")]\n        public float arcDuration = 3.0f;\n\n        [Tooltip(\"The amount of time in seconds between each segment of the projectile.\")]\n        public float segmentBreak = 0.025f;\n\n        [Tooltip(\"The speed at which the line segments of the arc move.\")]\n        public float arcSpeed = 0.2f;\n\n        public Material material = null;\n\n        [HideInInspector]\n        public int traceLayerMask = 0;\n\n        private LineRenderer[] lineRenderers;\n        private Timed.Time arcTimeOffset = Timed.Time.Zero;\n        private float prevThickness = 0.0f;\n        private int prevSegmentCount = 0;\n        private bool showArc = true;\n        private Vector3 startPos;\n        private Vector3 projectileVelocity;\n        private bool useGravity = true;\n        private Transform arcObjectsTransfrom;\n        private bool arcInvalid = false;\n\n\n        void Start()\n        {\n            arcTimeOffset = Timed.time;\n        }\n\n\n        void Update()\n        {\n            if (thickness != prevThickness || segmentCount != prevSegmentCount)\n            {\n                CreateLineRendererObjects();\n                prevThickness = thickness;\n                prevSegmentCount = segmentCount;\n            }\n        }\n\n\n        private void CreateLineRendererObjects()\n        {\n\n            if (arcObjectsTransfrom != null)\n            {\n                GameObject.Destroy((GameObject)arcObjectsTransfrom.gameObject);\n            }\n\n            GameObject arcObjectsParent = new GameObject(\"ArcObjects\");\n            arcObjectsTransfrom = arcObjectsParent.transform;\n            arcObjectsTransfrom.SetParent(this.transform);\n\n            lineRenderers = new LineRenderer[segmentCount];\n            for (int i = 0; i < segmentCount; ++i)\n            {\n                GameObject newObject = new GameObject(\"LineRenderer_\" + i);\n                newObject.transform.SetParent(arcObjectsTransfrom);\n\n                lineRenderers[i] = newObject.AddComponent<LineRenderer>();\n\n                lineRenderers[i].receiveShadows = false;\n                lineRenderers[i].reflectionProbeUsage = UnityEngine.Rendering.ReflectionProbeUsage.Off;\n                lineRenderers[i].lightProbeUsage = UnityEngine.Rendering.LightProbeUsage.Off;\n                lineRenderers[i].shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;\n                lineRenderers[i].material = material;\n#if (UNITY_5_4)\n\t\t\t\tlineRenderers[i].SetWidth( thickness, thickness );\n#else\n                lineRenderers[i].startWidth = thickness;\n                lineRenderers[i].endWidth = thickness;\n#endif\n                lineRenderers[i].enabled = false;\n            }\n        }\n\n        public void SetArcData(Vector3 position, Vector3 velocity, bool gravity, bool pointerAtBadAngle)\n        {\n            startPos = position;\n            projectileVelocity = velocity;\n            useGravity = gravity;\n\n            if (arcInvalid && !pointerAtBadAngle)\n            {\n                arcTimeOffset = Timed.time;\n            }\n            arcInvalid = pointerAtBadAngle;\n        }\n\n        public void Show()\n        {\n            showArc = true;\n            if (lineRenderers == null)\n            {\n                CreateLineRendererObjects();\n            }\n        }\n\n        public void Hide()\n        {\n            \n            if (showArc)\n            {\n                HideLineSegments(0, segmentCount);\n            }\n            showArc = false;\n        }\n\n        public void DrawArc(out RaycastHit hitInfo)\n        {\n            float timeStep = arcDuration / segmentCount;\n\n            float currentTimeOffset = (Timed.time - arcTimeOffset) * arcSpeed;\n\n            if (currentTimeOffset > (timeStep + segmentBreak))\n            {\n                arcTimeOffset = Timed.time;\n                currentTimeOffset = 0.0f;\n            }\n\n            float segmentStartTime = currentTimeOffset;\n\n            float arcHitTime = FindProjectileCollision(out hitInfo);\n\n            if (arcInvalid)\n            {\n                \n                lineRenderers[0].enabled = true;\n                lineRenderers[0].SetPosition(0, GetArcPositionAtTime(0.0f));\n                lineRenderers[0].SetPosition(1, GetArcPositionAtTime(arcHitTime < timeStep ? arcHitTime : timeStep));\n\n                HideLineSegments(1, segmentCount);\n            }\n            else\n            {\n                \n                int loopStartSegment = 0;\n                if (segmentStartTime > segmentBreak)\n                {\n                    float firstSegmentEndTime = currentTimeOffset - segmentBreak;\n                    if (arcHitTime < firstSegmentEndTime)\n                    {\n                        firstSegmentEndTime = arcHitTime;\n                    }\n                    DrawArcSegment(0, 0.0f, firstSegmentEndTime);\n\n                    loopStartSegment = 1;\n                }\n\n                bool stopArc = false;\n                int currentSegment = 0;\n                if (segmentStartTime < arcHitTime)\n                {\n                    for (currentSegment = loopStartSegment; currentSegment < segmentCount; ++currentSegment)\n                    {\n                        \n                        float segmentEndTime = segmentStartTime + timeStep;\n                        if (segmentEndTime >= arcDuration)\n                        {\n                            segmentEndTime = arcDuration;\n                            stopArc = true;\n                        }\n\n                        if (segmentEndTime >= arcHitTime)\n                        {\n                            segmentEndTime = arcHitTime;\n                            stopArc = true;\n                        }\n\n                        DrawArcSegment(currentSegment, segmentStartTime, segmentEndTime);\n\n                        segmentStartTime += timeStep + segmentBreak;\n\n                        \n                        if (stopArc || segmentStartTime >= arcDuration || segmentStartTime >= arcHitTime)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    currentSegment--;\n                }\n\n                \n                HideLineSegments(currentSegment + 1, segmentCount);\n            }\n\n            return arcHitTime != float.MaxValue;\n        }\n\n        private void DrawArcSegment(int index, float startTime, float endTime)\n        {\n            lineRenderers[index].enabled = true;\n            lineRenderers[index].SetPosition(0, GetArcPositionAtTime(startTime));\n            lineRenderers[index].SetPosition(1, GetArcPositionAtTime(endTime));\n        }\n\n        public void SetColor(Color color)\n        {\n            for (int i = 0; i < segmentCount; ++i)\n            {\n#if (UNITY_5_4)\n\t\t\t\tlineRenderers[i].SetColors( color, color );\n#else\n                lineRenderers[i].startColor = color;\n                lineRenderers[i].endColor = color;\n#endif\n            }\n        }\n\n        private float FindProjectileCollision(out RaycastHit hitInfo)\n        {\n            float timeStep = arcDuration / segmentCount;\n            float segmentStartTime = 0.0f;\n\n            hitInfo = new RaycastHit();\n\n            Vector3 segmentStartPos = GetArcPositionAtTime(segmentStartTime);\n            for (int i = 0; i < segmentCount; ++i)\n            {\n                float segmentEndTime = segmentStartTime + timeStep;\n                Vector3 segmentEndPos = GetArcPositionAtTime(segmentEndTime);\n\n                if (Physics.Linecast(segmentStartPos, segmentEndPos, out hitInfo, traceLayerMask))\n                {\n                    if (hitInfo.collider.GetComponent<IgnoreTeleportTrace>() == null)\n                    {\n                        return segmentEndTime;\n                    }\n                }\n\n                segmentStartPos",
    "code_repairing_4": "FIXED CODE:\n\nusing UnityEngine;\n\nnamespace BaroqueUI\n{\n\n    class TeleportArc : MonoBehaviour\n    {\n        public int segmentCount = 60;\n        public float thickness = 0.01f;\n\n        [Tooltip(\"The amount of time in seconds to predict the motion of the projectile.\")]\n        public float arcDuration = 3.0f;\n\n        [Tooltip(\"The amount of time in seconds between each segment of the projectile.\")]\n        public float segmentBreak = 0.025f;\n\n        [Tooltip(\"The speed at which the line segments of the arc move.\")]\n        public float arcSpeed = 0.2f;\n\n        public Material material = null;\n\n        [HideInInspector]\n        public int traceLayerMask = 0;\n\n        \n        private LineRenderer[] lineRenderers;\n        private Timed.Time arcTimeOffset = Timed.Time.Zero;\n        private float prevThickness = 0.0f;\n        private int prevSegmentCount = 0;\n        private bool showArc = true;\n        private Vector3 startPos;\n        private Vector3 projectileVelocity;\n        private bool useGravity = true;\n        private Transform arcObjectsTransfrom;\n        private bool arcInvalid = false;\n\n\n        \n        void Start()\n        {\n            arcTimeOffset = Timed.time;\n        }\n\n\n        \n        void Update()\n        {\n            if (thickness != prevThickness || segmentCount != prevSegmentCount)\n            {\n                CreateLineRendererObjects();\n                prevThickness = thickness;\n                prevSegmentCount = segmentCount;\n            }\n        }\n\n\n        \n        private void CreateLineRendererObjects()\n        {\n            \n            if (arcObjectsTransfrom != null)\n            {\n                Destroy((GameObject)arcObjectsTransfrom.gameObject);\n            }\n\n            GameObject arcObjectsParent = new GameObject(\"ArcObjects\");\n            arcObjectsTransfrom = arcObjectsParent.transform;\n            arcObjectsTransfrom.SetParent(this.transform);\n\n            \n            lineRenderers = new LineRenderer[segmentCount];\n            for (int i = 0; i < segmentCount; ++i)\n            {\n                GameObject newObject = new GameObject(\"LineRenderer_\" + i);\n                newObject.transform.SetParent(arcObjectsTransfrom);\n\n                LineRenderer lineRenderer = newObject.AddComponent<LineRenderer>();\n\n                lineRenderer.receiveShadows = false;\n                lineRenderer.reflectionProbeUsage = UnityEngine.Rendering.ReflectionProbeUsage.Off;\n                lineRenderer.lightProbeUsage = UnityEngine.Rendering.LightProbeUsage.Off;\n                lineRenderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;\n                lineRenderer.material = material;\n#if (UNITY_5_4)\n\t\t\t\tlineRenderer.SetWidth( thickness, thickness );\n#else\n                lineRenderer.startWidth = thickness;\n                lineRenderer.endWidth = thickness;\n#endif\n                lineRenderer.enabled = false;\n\n                lineRenderers[i] = lineRenderer;\n            }\n        }\n\n\n        \n        public void SetArcData(Vector3 position, Vector3 velocity, bool gravity, bool pointerAtBadAngle)\n        {\n            startPos = position;\n            projectileVelocity = velocity;\n            useGravity = gravity;\n\n            if (arcInvalid && !pointerAtBadAngle)\n            {\n                arcTimeOffset = Timed.time;\n            }\n            arcInvalid = pointerAtBadAngle;\n        }\n\n\n        \n        public void Show()\n        {\n            showArc = true;\n            if (lineRenderers == null)\n            {\n                CreateLineRendererObjects();\n            }\n        }\n\n\n        \n        public void Hide()\n        {\n            \n            if (showArc)\n            {\n                HideLineSegments(0, segmentCount);\n            }\n            showArc = false;\n        }\n\n\n        \n        \n        \n        public bool DrawArc(out RaycastHit hitInfo)\n        {\n            float timeStep = arcDuration / segmentCount;\n\n            float currentTimeOffset = (Timed.time - arcTimeOffset) * arcSpeed;\n\n            \n            if (currentTimeOffset > (timeStep + segmentBreak))\n            {\n                arcTimeOffset = Timed.time;\n                currentTimeOffset = 0.0f;\n            }\n\n            float segmentStartTime = currentTimeOffset;\n\n            float arcHitTime = FindProjectileCollision(out hitInfo);\n\n            if (arcInvalid)\n            {\n                \n                lineRenderers[0].enabled = true;\n                lineRenderers[0].SetPosition(0, GetArcPositionAtTime(0.0f));\n                lineRenderers[0].SetPosition(1, GetArcPositionAtTime(arcHitTime < timeStep ? arcHitTime : timeStep));\n\n                HideLineSegments(1, segmentCount);\n            }\n            else\n            {\n                \n                int loopStartSegment = 0;\n                if (segmentStartTime > segmentBreak)\n                {\n                    float firstSegmentEndTime = currentTimeOffset - segmentBreak;\n                    if (arcHitTime < firstSegmentEndTime)\n                    {\n                        firstSegmentEndTime = arcHitTime;\n                    }\n                    DrawArcSegment(0, 0.0f, firstSegmentEndTime);\n\n                    loopStartSegment = 1;\n                }\n\n                bool stopArc = false;\n                int currentSegment = 0;\n                if (segmentStartTime < arcHitTime)\n                {\n                    for (currentSegment = loopStartSegment; currentSegment < segmentCount; ++currentSegment)\n                    {\n                        \n                        float segmentEndTime = segmentStartTime + timeStep;\n                        if (segmentEndTime >= arcDuration)\n                        {\n                            segmentEndTime = arcDuration;\n                            stopArc = true;\n                        }\n\n                        if (segmentEndTime >= arcHitTime)\n                        {\n                            segmentEndTime = arcHitTime;\n                            stopArc = true;\n                        }\n\n                        DrawArcSegment(currentSegment, segmentStartTime, segmentEndTime);\n\n                        segmentStartTime += timeStep + segmentBreak;\n\n                        \n                        if (stopArc || segmentStartTime >= arcDuration || segmentStartTime >= arcHitTime)\n                        {\n                            break;\n                        }\n                    }\n                }\n                else\n                {\n                    currentSegment--;\n                }\n\n                \n                HideLineSegments(currentSegment + 1, segmentCount);\n            }\n\n            return arcHitTime != float.MaxValue;\n        }\n\n\n        \n        private void DrawArcSegment(int index, float startTime, float endTime)\n        {\n            lineRenderers[index].enabled = true;\n            lineRenderers[index].SetPosition(0, GetArcPositionAtTime(startTime));\n            lineRenderers[index].SetPosition(1, GetArcPositionAtTime(endTime));\n        }\n\n\n        \n        public void SetColor(Color color)\n        {\n            for (int i = 0; i < segmentCount; ++i)\n            {\n#if (UNITY_5_4)\n\t\t\t\tlineRenderers[i].SetColors( color, color );\n#else\n                lineRenderers[i].startColor = color;\n                lineRenderers[i].endColor = color;\n#endif\n            }\n        }\n\n\n        \n        private float FindProjectileCollision(out RaycastHit hitInfo)\n        {\n            float timeStep = arcDuration / segmentCount;\n            float segmentStartTime = 0.0f;\n\n            hitInfo = new RaycastHit();\n\n            Vector3 segmentStartPos = GetArcPositionAtTime(segmentStartTime);\n            for (int i = 0; i < segmentCount; ++i)\n            {\n                float segmentEndTime = segmentStartTime + timeStep;\n                Vector3 segmentEndPos = GetArcPositionAtTime(segmentEndTime);\n\n                if (Physics.Linecast(segmentStartPos, segmentEndPos, out hitInfo, traceLayerMask))\n                {\n#if false\n                    if (hitInfo.collider.GetComponent<IgnoreTeleportTrace>() == null)\n#"
}