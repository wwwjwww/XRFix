{
    "code_repairing_0": "The corrected code should look like this:\n\n```\nusing UnityEngine;\nusing System.Collections;\n\npublic class timelineHandle : manipObject {\n  public Transform timelineTransform;\n  timelineEvent _timelineEvent;\n  GameObject highlight;\n  Material highlightMat;\n\n  Color glowColor = Color.HSVToRGB(0.1f, 0.7f, 0.1f);\n\n  public bool stretchMode = false;\n\n  public override void Awake() {\n    base.Awake();\n    canBeDeleted = true;\n    _timelineEvent = GetComponentInParent<timelineEvent>();\n    timelineTransform = _timelineEvent.transform.parent;\n    createHandleFeedback();\n  }\n\n  public override void selfdelete() {\n    _timelineEvent.removeSelf();\n    Destroy(_timelineEvent.gameObject);\n  }\n\n  public void setHue(float h) {\n    h = Mathf.Repeat(h, 6) / 6f;\n    GetComponent<Renderer>().material.SetColor(\"_EmissionColor\", Color.HSVToRGB(h,.95f, 1));\n    highlightMat.SetColor(\"_TintColor\", Color.HSVToRGB(h, 0.7f, 0.1f));\n  }\n\n  void createHandleFeedback() {\n    highlight = new GameObject(\"highlight\");\n\n    MeshFilter m = highlight.AddComponent<MeshFilter>();\n\n    m.mesh = GetComponent<MeshFilter>().mesh;\n    MeshRenderer r = highlight.AddComponent<MeshRenderer>();\n    r.material = Resources.Load(\"Materials/Highlight\") as Material;\n    highlightMat = r.material;\n\n    highlight.transform.SetParent(transform, false);\n\n    highlight.transform.localScale = new Vector3(1.15f, 1.05f, 1.1f);\n    highlight.transform.localPosition = new Vector3(0, -.0025f, 0);\n    highlightMat.SetColor(\"_TintColor\", glowColor);\n    highlightMat.SetFloat(\"_EmissionGain\",.75f);\n\n    highlight.SetActive(false);\n  }\n\n  void Update() {\n    if (recordDesired) {\n      highlight.SetActive(recording);\n      GetComponent<Renderer>().enabled =!recording;\n      GetComponent<Collider>().enabled =!recording;\n      recordDesired = false;\n    }\n  }\n\n  bool recordDesired = false;\n  bool recording = false;\n\n  public void setRecord(bool on) {\n    recordDesired = true;\n    recording = on;\n  }\n\n  public override void grabUpdate(Transform t) {\n    if (!stretchMode) {\n\n      Vector2 a = _timelineEvent._componentInterface.worldPosToGridPos(t.position);\n      Vector2 dif = a - manipOffset;\n      Vector2 newPos = startPos + dif;\n\n      if (!_timelineEvent._componentInterface.notelock) {\n        _timelineEvent.track = Mathf.FloorToInt(_timelineEvent._componentInterface._gridParams.YtoUnit(a.y));\n        setHue(_timelineEvent.track);\n      }\n\n      float newIn = startIn + dif.x;\n      if (_timelineEvent._componentInterface.snapping) {\n        newIn = _timelineEvent._componentInterface._gridParams.XtoSnap(newIn, false);\n      }\n      _timelineEvent.in_out.x = _timelineEvent._componentInterface._gridParams.XtoUnit(newIn);\n      _timelineEvent.in_out.y = _timelineEvent.in_out.x + unitLength;\n\n      _timelineEvent.gridUpdate();\n\n    } else {\n      Vector3 a = _timelineEvent._componentInterface.worldPosToGridPos(t.position, true);\n      float dif = a.x - manipOffset.x;\n      if (manipOffset.x - a.x > 0) {\n        a.x = dif + manipOffset.x - _timelineEvent._componentInterface._gridParams.unitSize / (2 * _timelineEvent._componentInterface._gridParams.snapFraction);\n        _timelineEvent.edgeOutHandle.transform.position = _timelineEvent.edgeOut.position = timelineTransform.TransformPoint(a);\n\n        a.x = manipOffset.x + _timelineEvent._componentInterface._gridParams.unitSize / (2 * _timelineEvent._componentInterface._gridParams.snapFraction);\n        _timelineEvent.edgeInHandle.transform.position = _timelineEvent.edgeIn.position = timelineTransform.TransformPoint(a);\n      } else {\n        a.x = dif + manipOffset.x + _timelineEvent._componentInterface._gridParams.unitSize / (2 * _timelineEvent._componentInterface._gridParams.snapFraction);\n        _timelineEvent.edgeInHandle.transform.position = _timelineEvent.edgeIn.position = timelineTransform.TransformPoint(a);\n\n        a.x = manipOffset.x - _timelineEvent._componentInterface._gridParams.unitSize / (2 * _timelineEvent._componentInterface._gridParams.snapFraction);\n        _timelineEvent.edgeOutHandle.transform.position = _timelineEvent.edgeOut.position = timelineTransform.TransformPoint(a);\n      }\n\n      _timelineEvent.recalcTrackPosition();\n    }\n  }\n\n  float startIn, unitLength;\n  Vector2 startPos;\n  Vector2 manipOffset;\n  public override void setState(manipState state) {\n    if (curState == state) return;\n\n    if (curState == manipState.grabbed && state!= manipState.grabbed) {\n      _timelineEvent.grabbed = false;\n      if (stretchMode) stretchMode = false;\n\n      _timelineEvent.transform.position = highlight.transform.position;\n      _timelineEvent.transform.rotation = highlight.transform.rotation;\n\n      highlight.transform.localPosition = Vector3.zero;\n      highlight.transform.localRotation = Quaternion.identity;\n\n      _timelineEvent.transform.parent = timelineTransform;\n      _timelineEvent.recalcTrackPosition();\n\n      _timelineEvent.toggleEdges(true);\n    }\n\n    curState = state;\n\n    if (curState == manipState.none) {\n\n      if (multiselected) {\n        highlight.SetActive(true);\n      } else {\n        highlight.SetActive(false);\n      }\n    }\n  }\n\n  public override void clickDown(Vector3 worldPos, RaycastHit hit) {\n    base.clickDown(worldPos, hit);\n    if (!multiselected) {\n      _timelineEvent.grabbed = true;\n      startPos = _timelineEvent.transform.position;\n      manipOffset = hit.point - startPos;\n      unitLength = _timelineEvent.in_out.y - _timelineEvent.in_out.x;\n      stretchMode = false;\n      if (hit.transform.CompareTag(\"edgein\")) {\n        stretchMode = true;\n        manipOffset = hit.point - _timelineEvent.edgeIn.position;\n      } else if (hit.transform.CompareTag(\"edgeout\")) {\n        manipOffset = hit.point - _timelineEvent.edgeOut.position;\n      }\n      startIn = _timelineEvent.in_out.x - _timelineEvent._componentInterface._gridParams.UnittoX(manipOffset.x);\n      _timelineEvent.grabUpdate(hit.transform);\n    }\n    multiselected = false;\n    foreach (Transform t in transform) {\n      if (t!= hit.transform) {\n        t.GetComponent<manipObject>().selected = false;\n      }\n    }\n    GetComponent<Renderer>().material.SetColor(\"_EmissionColor\", Color.white);\n    highlightMat.SetColor(\"_TintColor\", glowColor);\n  }\n\n  bool multiselected = false;\n  public override void select() {\n    if (!multiselected) {\n      multiselected = true;\n      curState = manipState.selected;\n      foreach (Transform t in transform) {\n        if (t!= transform.GetChild(0)) {\n          t.GetComponent<manipObject>().selected = true;\n        }\n      }\n      GetComponent<Renderer>().material.SetColor(\"_EmissionColor\", Color.HSVToRGB(1f,.95f, 1));\n    } else {\n      multiselected = false;\n      curState = manipState.none;\n      foreach (Transform t in transform) {\n        t.GetComponent<manipObject>().selected = false;\n      }\n      GetComponent<Renderer>().material.SetColor(\"_EmissionColor\", Color.white);\n    }\n  }\n\n}\n```",
    "code_repairing_1": "Los algoritmos de inteligencia artificial tienen varias caracter\u00edsticas importantes. Algunas de las m\u00e1s comunes incluyen:\n\n1. Aprendizaje autom\u00e1tico: los algoritmos de inteligencia artificial pueden aprender a partir de los datos que se les proporcionan.\n\n2. Adaptividad: los algoritmos de inteligencia artificial pueden adaptarse a situaciones nuevas y cambiantes.\n\n3. Fuzziness: los algoritmos de inteligencia artificial pueden estar sometidos a matices o incertidumbres para simular la incertidumbre o la imprevisibilidad de la naturaleza.\n\n4. Resoluci\u00f3n de problemas: los algoritmos de inteligencia artificial pueden resolver problemas complejos y realizar tareas que ser\u00edan dif\u00edciles o imposibles para las personas.\n\n5. Abstracci\u00f3n: los algoritmos de inteligencia artificial pueden ser capaces de identificar patrones y relaciones en grandes conjuntos de datos.\n\n6. Deducci\u00f3n: los algoritmos de inteligencia artificial pueden hacer deducciones basadas en la informaci\u00f3n proporcionada.\n\n7. Diagn\u00f3stico: los algoritmos de inteligencia artificial pueden ayudar a identificar problemas y desaf\u00ed",
    "code_repairing_2": "Here is the corrected C# code:\n\n```\nusing UnityEngine;\nusing System.Collections;\n\npublic class timelineHandle : manipObject {\n\tpublic Transform timelineTransform;\n\ttimelineEvent _timelineEvent;\n\tGameObject highlight;\n\tMaterial highlightMat;\n\n\tColor glowColor = Color.HSVToRGB(0.1f, 0.7f, 0.1f);\n\n\tpublic bool stretchMode = false;\n\n\tpublic override void Awake() {\n\t\tbase.Awake();\n\t\tcanBeDeleted = true;\n\t\t_timelineEvent = GetComponentInParent<timelineEvent>();\n\t\ttimelineTransform = _timelineEvent.transform.parent;\n\t\tcreateHandleFeedback();\n\t}\n\n\tpublic override void selfdelete() {\n\t\t_timelineEvent.removeSelf();\n\t\tDestroy(_timelineEvent.gameObject);\n\t}\n\n\tpublic void setHue(float h) {\n\t\th = Mathf.Repeat(h, 6) / 6f;\n\t\tGetComponent<Renderer>().material.SetColor(\"_EmissionColor\", Color.HSVToRGB(h,.95f, 1));\n\t\thighlightMat.SetColor(\"_TintColor\", Color.HSVToRGB(h, 0.7f, 0.1f));\n\t}\n\n\tvoid createHandleFeedback() {\n\t\thighlight = new GameObject(\"highlight\");\n\n\t\tMeshFilter m = highlight.AddComponent<MeshFilter>();\n\n\t\tm.mesh = GetComponent<MeshFilter>().mesh;\n\t\tMeshRenderer r = highlight.AddComponent<MeshRenderer>();\n\t\tr.material = Resources.Load(\"Materials/Highlight\") as Material;\n\t\thighlightMat = r.material;\n\n\t\thighlight.transform.SetParent(transform, false);\n\n\t\thighlight.transform.localScale = new Vector3(1.15f, 1.05f, 1.1f);\n\t\thighlight.transform.localPosition = new Vector3(0, -.0025f, 0);\n\t\thighlightMat.SetColor(\"_TintColor\", glowColor);\n\t\thighlightMat.SetFloat(\"_EmissionGain\",.75f);\n\n\t\thighlight.SetActive(false);\n\t}\n\n\tvoid Update() {\n\t\tif (recordDesired) {\n\t\t\thighlight.SetActive(recording);\n\t\t\tGetComponent<Renderer>().enabled =!recording;\n\t\t\tGetComponent<Collider>().enabled =!recording;\n\t\t\trecordDesired = false;\n\t\t}\n\t}\n\n\tbool recordDesired = false;\n\tbool recording = false;\n\n\tpublic void setRecord(bool on) {\n\t\trecordDesired = true;\n\t\trecording = on;\n\t}\n\n\tpublic override void grabUpdate(Transform t) {\n\t\tif (!stretchMode) {\n\n\t\t\tVector2 a = _timelineEvent._componentInterface.worldPosToGridPos(t.position);\n\t\t\tVector2 dif = a - manipOffset;\n\t\t\tVector2 newPos = startPos + dif;\n\n\t\t\tif (!_timelineEvent._componentInterface.notelock) {\n\t\t\t\t_timelineEvent.track = Mathf.FloorToInt(_timelineEvent._componentInterface._gridParams.YtoUnit(a.y));\n\t\t\t\tsetHue(_timelineEvent.track);\n\t\t\t}\n\n\t\t\tfloat newIn = startIn + dif.x;\n\t\t\tif (_timelineEvent._componentInterface.snapping) {\n\t\t\t\tnewIn = _timelineEvent._componentInterface._gridParams.XtoSnap(newIn, false);\n\t\t\t}\n\t\t\t_timelineEvent.in_out.x = _timelineEvent._componentInterface._gridParams.XtoUnit(newIn);\n\t\t\t_timelineEvent.in_out.y = _timelineEvent.in_out.x + unitLength;\n\n\t\t\t_timelineEvent.gridUpdate();\n\n\t\t} else {\n\t\t\tVector3 a = _timelineEvent._componentInterface.worldPosToGridPos(t.position, true);\n\t\t\tfloat dif = a.x - manipOffset.x;\n\t\t\tif (manipOffset.x - a.x > 0) {\n\t\t\t\ta.x = dif + manipOffset.x - _timelineEvent._componentInterface._gridParams.unitSize / (2 * _timelineEvent._componentInterface._gridParams.snapFraction);\n\t\t\t\t_timelineEvent.edgeOutHandle.transform.position = _timelineEvent.edgeOut.position = timelineTransform.TransformPoint(a);\n\n\t\t\t\ta.x = manipOffset.x + _timelineEvent._componentInterface._gridParams.unitSize / (2 * _timelineEvent._componentInterface._gridParams.snapFraction);\n\t\t\t\t_timelineEvent.edgeInHandle.transform.position = _timelineEvent.edgeIn.position = timelineTransform.TransformPoint(a);\n\t\t\t} else {\n\t\t\t\ta.x = dif + manipOffset.x + _timelineEvent._componentInterface._gridParams.unitSize / (2 * _timelineEvent._componentInterface._gridParams.snapFraction);\n\t\t\t\t_timelineEvent.edgeInHandle.transform.position = _timelineEvent.edgeIn.position = timelineTransform.TransformPoint(a);\n\n\t\t\t\ta.x = manipOffset.x - _timelineEvent._componentInterface._gridParams.unitSize / (2 * _timelineEvent._componentInterface._gridParams.snapFraction);\n\t\t\t\t_timelineEvent.edgeOutHandle.transform.position = _timelineEvent.edgeOut.position = timelineTransform.TransformPoint(a);\n\t\t\t}\n\n\t\t\t_timelineEvent.recalcTrackPosition();\n\t\t}\n\t}\n\n\tfloat startIn, unitLength;\n\tVector2 startPos;\n\tVector2 manipOffset;\n\tpublic override void setState(manipState state) {\n\t\tif (curState == state) return;\n\n\t\tif (curState == manipState.grabbed && state!= manipState.grabbed) {\n\t\t\t_timelineEvent.grabbed = false;\n\t\t\tif (stretchMode) stretchMode = false;\n\n\t\t\t_timelineEvent.transform.position = highlight.transform.position;\n\t\t\t_timelineEvent.transform.rotation = highlight.transform.rotation;\n\n\t\t\thighlight.transform.localPosition = Vector3.zero;\n\t\t\thighlight.transform.localRotation = Quaternion.identity;\n\n\t\t\t_timelineEvent.transform.parent = timelineTransform;\n\t\t\t_timelineEvent.recalcTrackPosition();\n\n\t\t\t_timelineEvent.toggleEdges(true);\n\n\t\t\t_timelineEvent.overlapCheck();\n\t\t}\n\n\t\tcurState = state;\n\n\t\tif (curState == manipState.none) {\n\n\t\t\tif (multiselected) {\n\t\t\t\tforeach (Transform child in transform) {\n\t\t\t\t\tDestroy(child.gameObject);\n\t\t\t\t}\n\t\t\t\tmultiselected = false;\n\t\t\t\thighlight.SetActive(false);\n\t\t\t}\n\n\t\t} else if (curState == manipState.selected) {\n\n\t\t\tif (!multiselected) {\n\t\t\t\tstartPos = _timelineEvent.transform.position;\n\t\t\t\tmanipOffset = Input.mousePosition - _timelineEvent.transform.position;\n\t\t\t\t_timelineEvent.grabbed = false;\n\t\t\t\tif (_timelineEvent._componentInterface.control) _timelineEvent.setRecord(true);\n\t\t\t}\n\n\t\t\tmultiselected = true;\n\t\t\tforeach (Transform child in transform) {\n\t\t\t\tchild.gameObject.layer = 13;\n\t\t\t}\n\n\t\t} else if (curState == manipState.grabbed) {\n\n\t\t\tif (_timelineEvent._componentInterface.control) _timelineEvent.setRecord(true);\n\t\t\t_timelineEvent.grabbed = true;\n\t\t\t_timelineEvent.transform.parent = null;\n\t\t\tif (!stretchMode) {\n\t\t\t\tmanipOffset = Input.mousePosition - _timelineEvent.transform.position;\n\t\t\t\tstartIn = _timelineEvent.in_out.x - _timelineEvent._componentInterface._gridParams.UnittoX(_timelineEvent.track);\n\t\t\t} else {\n\t\t\t\tmanipOffset = new Vector2(0, 0);\n\t\t\t}\n\n\t\t\tif (!_timelineEvent._componentInterface.control) {\n\t\t\t\t_timelineEvent.in_out.x = Mathf.Min(_timelineEvent.in_out.x, startIn + Input.mousePosition.x - manipOffset.x);\n\t\t\t\t_timelineEvent.in_out.y = Mathf.Max(_timelineEvent.in_out.y,",
    "code_repairing_3": "En programaci\u00f3n, una variable es un espacio de almacenamiento que se utiliza para guardar datos en la memoria de la computadora durante el tiempo de ejecuci\u00f3n de un programa. Los datos se pueden almacenar en una variable y luego modificados o utilizados en diferentes partes del c\u00f3digo.\n\nExisten diferentes tipos",
    "code_repairing_4": "```csharp\nusing UnityEngine;\nusing System.Collections;\n\npublic class timelineHandle : manipObject {\n  public Transform timelineTransform;\n  timelineEvent _timelineEvent;\n  GameObject highlight;\n  Material highlightMat;\n\n  Color glowColor = Color.HSVToRGB(0.1f, 0.7f, 0.1f);\n\n  public bool stretchMode = false;\n\n  public override void Awake() {\n    base.Awake();\n    canBeDeleted = true;\n    _timelineEvent = GetComponentInParent<timelineEvent>();\n    timelineTransform = _timelineEvent.transform.parent;\n    createHandleFeedback();\n  }\n\n  public override void selfdelete() {\n    _timelineEvent.removeSelf();\n    Destroy(_timelineEvent.gameObject);\n  }\n\n  public void setHue(float h) {\n    h = Mathf.Repeat(h, 6) / 6f;\n    GetComponent<Renderer>().material.SetColor(\"_EmissionColor\", Color.HSVToRGB(h,.95f, 1));\n    highlightMat.SetColor(\"_TintColor\", Color.HSVToRGB(h, 0.7f, 0.1f));\n  }\n\n  void createHandleFeedback() {\n    highlight = new GameObject(\"highlight\");\n\n    MeshFilter m = highlight.AddComponent<MeshFilter>();\n\n    m.mesh = GetComponent<MeshFilter>().mesh;\n    MeshRenderer r = highlight.AddComponent<MeshRenderer>();\n    r.material = Resources.Load(\"Materials/Highlight\") as Material;\n    highlightMat = r.material;\n\n    highlight.transform.SetParent(transform, false);\n\n    highlight.transform.localScale = new Vector3(1.15f, 1.05f, 1.1f);\n    highlight.transform.localPosition = new Vector3(0, -.0025f, 0);\n    highlightMat.SetColor(\"_TintColor\", glowColor);\n    highlightMat.SetFloat(\"_EmissionGain\",.75f);\n\n    highlight.SetActive(false);\n  }\n\n  void Update() {\n    if (recordDesired) {\n      highlight.SetActive(recording);\n      GetComponent<Renderer>().enabled =!recording;\n      GetComponent<Collider>().enabled =!recording;\n      recordDesired = false;\n    }\n  }\n\n  bool recordDesired = false;\n  bool recording = false;\n\n  public void setRecord(bool on) {\n    recordDesired = true;\n    recording = on;\n  }\n\n  public override void grabUpdate(Transform t) {\n    if (!stretchMode) {\n\n      Vector2 a = _timelineEvent._componentInterface.worldPosToGridPos(t.position);\n      Vector2 dif = a - manipOffset;\n      Vector2 newPos = startPos + dif;\n\n      if (!_timelineEvent._componentInterface.notelock) {\n        _timelineEvent.track = Mathf.FloorToInt(_timelineEvent._componentInterface._gridParams.YtoUnit(a.y));\n        setHue(_timelineEvent.track);\n      }\n\n      float newIn = startIn + dif.x;\n      if (_timelineEvent._componentInterface.snapping) {\n        newIn = _timelineEvent._componentInterface._gridParams.XtoSnap(newIn, false);\n      }\n      _timelineEvent.in_out.x = _timelineEvent._componentInterface._gridParams.XtoUnit(newIn);\n      _timelineEvent.in_out.y = _timelineEvent.in_out.x + unitLength;\n\n      _timelineEvent.gridUpdate();\n\n    } else {\n      Vector3 a = _timelineEvent._componentInterface.worldPosToGridPos(t.position, true);\n      float dif = a.x - manipOffset.x;\n      if (manipOffset.x - a.x > 0) {\n        a.x = dif + manipOffset.x - _timelineEvent._componentInterface._gridParams.unitSize / (2 * _timelineEvent._componentInterface._gridParams.snapFraction);\n        _timelineEvent.edgeOutHandle.transform.position = _timelineEvent.edgeOut.position = timelineTransform.TransformPoint(a);\n\n        a.x = manipOffset.x + _timelineEvent._componentInterface._gridParams.unitSize / (2 * _timelineEvent._componentInterface._gridParams.snapFraction);\n        _timelineEvent.edgeInHandle.transform.position = _timelineEvent.edgeIn.position = timelineTransform.TransformPoint(a);\n      } else {\n        a.x = dif + manipOffset.x + _timelineEvent._componentInterface._gridParams.unitSize / (2 * _timelineEvent._componentInterface._gridParams.snapFraction);\n        _timelineEvent.edgeInHandle.transform.position = _timelineEvent.edgeIn.position = timelineTransform.TransformPoint(a);\n\n        a.x = manipOffset.x - _timelineEvent._componentInterface._gridParams.unitSize / (2 * _timelineEvent._componentInterface._gridParams.snapFraction);\n        _timelineEvent.edgeOutHandle.transform.position = _timelineEvent.edgeOut.position = timelineTransform.TransformPoint(a);\n      }\n\n      _timelineEvent.recalcTrackPosition();\n    }\n  }\n\n  float startIn, unitLength;\n  Vector2 startPos;\n  Vector2 manipOffset;\n  public override void setState(manipState state) {\n    if (curState == state) return;\n\n    if (curState == manipState.grabbed && state!= manipState.grabbed) {\n      _timelineEvent.grabbed = false;\n      if (stretchMode) stretchMode = false;\n\n      _timelineEvent.transform.position = highlight.transform.position;\n      _timelineEvent.transform.rotation = highlight.transform.rotation;\n\n      highlight.transform.localPosition = Vector3.zero;\n      highlight.transform.localRotation = Quaternion.identity;\n\n      _timelineEvent.transform.parent = timelineTransform;\n      _timelineEvent.recalcTrackPosition();\n\n      _timelineEvent.toggleEdges(true);\n\n      _timelineEvent.overlapCheck();\n    }\n\n    curState = state;\n\n    if (curState == manipState.none) {\n\n      if (multiselected) {\n        highlight.SetActive(true);\n      } else {\n        highlight.SetActive(false);\n      }\n\n    } else if (curState == manipState.grabbed) {\n\n      if (multiselected) {\n        highlight.SetActive(true);\n        _timelineEvent.transform.parent = null;\n      } else {\n        highlight.SetActive(true);\n        _timelineEvent.transform.parent = timelineTransform;\n      }\n\n    } else if (curState == manipState.resizing) {\n      stretchMode = true;\n      unitLength = _timelineEvent.in_out.y - _timelineEvent.in_out.x;\n      manipOffset = _timelineEvent._componentInterface.worldPosToGridPos(Input.mousePosition);\n      startIn = _timelineEvent._componentInterface._gridParams.UnittoX(_timelineEvent.in_out.x);\n      startPos = _timelineEvent._componentInterface.worldPosToGridPos(_timelineEvent.gameObject.transform.position);\n    }\n  }\n\n  public override void hoverUpdate() {\n    base.hoverUpdate();\n\n    switch (curState) {\n      case manipState.grabbed:\n        if (Input.GetMouseButtonDown(0)) {\n          grabbedObject = this;\n          if (multiselected) {\n            stretchMode = true;\n            unitLength = _timelineEvent.in_out.y - _timelineEvent.in_out.x;\n            manipOffset = _timelineEvent._componentInterface.worldPosToGridPos(Input.mousePosition);\n            startIn = _timelineEvent._componentInterface._gridParams.UnittoX(_timelineEvent.in_out.x);\n            startPos = _timelineEvent._componentInterface.worldPosToGridPos(_timelineEvent.gameObject.transform.position);\n            _timelineEvent.toggleEdges(false);\n          } else {\n            _timelineEvent.grabbed = true;\n            _timelineEvent.transform.parent = null;\n          }\n        }\n        break;\n      case manipState.resizing:\n        if (Input.GetMouseButtonUp(0)) {\n          curState = manipState.grabbed;\n        } else {\n          Vector2 a = _timelineEvent._componentInterface.worldPosToGridPos(Input.mousePosition);\n          float dif = a.x - manipOffset.x;\n          if (dif > 0) {\n            _timeline"
}