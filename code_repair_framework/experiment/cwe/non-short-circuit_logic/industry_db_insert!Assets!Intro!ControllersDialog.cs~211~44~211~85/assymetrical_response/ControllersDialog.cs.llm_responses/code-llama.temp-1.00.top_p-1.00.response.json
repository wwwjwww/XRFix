{
    "code_repairing_0": "Alright, I've taken a look at the code and I've fixed the errors that I found. Here's your fixed code:\n\n\ufeffusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.EventSystems;\nusing BaroqueUI;\nusing System;\n\nnamespace NanIndustryVR\n{\n    public interface IControllerDialog\n    {\n        float FindDistance(Camera cam, bool force = false);\n        void Enter(ControllersDialog.Track track);\n        void Leave(ControllersDialog.Track track);\n        void Hover(ControllersDialog.Track track, Controller controller, Camera cam);\n        void TriggerDown(ControllersDialog.Track track, Camera cam);\n        void TriggerUp(ControllersDialog.Track track, Camera cam);\n    }\n\n    public class ControllersDialog : MonoBehaviour\n    {\n        public Material lineMaterial, lineMissMaterial;\n        public float defaultDistance;\n\n        Mesh lineMesh;\n        new Camera camera;\n\n        private void Start()\n        {\n            lineMesh = new Mesh();\n            lineMesh.vertices = new Vector3[] { Vector3.zero, Vector3.forward };\n            lineMesh.SetIndices(new int[] { 0, 1 }, MeshTopology.Lines, 0);\n            lineMesh.RecalculateBounds();\n            lineMesh.UploadMeshData(true);\n\n            camera = GetComponent<Camera>();\n\n            var gt = Controller.GlobalTracker(this);\n            gt.onControllersUpdate += Gt_onControllersUpdate;\n        }\n\n\n        internal class TouchPadScroll\n        {\n            enum State { WaitTouch, WaitMoveFarEnough, Moving, FreeWheeling };\n            State state = State.WaitTouch;\n            Vector2 original_touch;\n            Vector2 speed_estimate;\n            float previous_time;\n\n            internal Vector2 Handle(Controller ctrl)\n            {\n                if (ctrl.haveRealTouchpad)\n                    return HandleRealTouchpad(ctrl);\n                if (ctrl.haveJoystick)\n                    return HandleJoystick(ctrl);\n                return Vector2.zero;\n            }\n\n            Vector2 HandleRealTouchpad(Controller ctrl)\n            {\n                const float SCROLL_SPEED = 2.5f;\n                bool touched = ctrl.touchpadTouched && !ctrl.touchpadPressed;\n\n                if (state == State.WaitTouch || (state == State.FreeWheeling && touched))\n                {\n                    if (touched)\n                    {\n                        original_touch = ctrl.touchpadPosition;\n                        state = State.WaitMoveFarEnough;\n                    }\n                    return Vector2.zero;\n                }\n                if (state == State.WaitMoveFarEnough)\n                {\n                    if (!touched)\n                    {\n                        state = State.WaitTouch;\n                        return Vector2.zero;\n                    }\n                    if ((ctrl.touchpadPosition - original_touch).sqrMagnitude < 0.01f)\n                        return Vector2.zero;   \n                    state = State.Moving;\n                    previous_time = float.NegativeInfinity;\n                    speed_estimate = Vector2.zero;\n                }\n\n                \n\n                \n                float delta_time = Time.time - previous_time;\n                previous_time = Time.time;\n                if (state == State.Moving)\n                {\n                    if (touched)\n                    {\n                        Vector2 delta = (ctrl.touchpadPosition - original_touch) * SCROLL_SPEED;\n                        original_touch = ctrl.touchpadPosition;\n                        Vector2 instant_speed = delta / delta_time;\n                        speed_estimate = Vector2.Lerp(\n                            instant_speed, speed_estimate, Mathf.Exp(delta_time * -13f));\n                        return delta;\n                    }\n                    if (speed_estimate.sqrMagnitude < 2f)\n                    {\n                        state = State.WaitTouch;\n                        return Vector2.zero;\n                    }\n                    state = State.FreeWheeling;\n\n                }\n                \n                speed_estimate *= Mathf.Exp(delta_time * -3f);\n                if (ctrl.touchpadPressed || speed_estimate.sqrMagnitude < 0.4f)\n                {\n                    state = State.WaitTouch;\n                    return Vector2.zero;\n                }\n                return speed_estimate * delta_time;\n            }\n\n            Vector2 HandleJoystick(Controller ctrl)\n            {\n                const float SCROLL_SPEED = 4.5f;\n\n                if (ctrl.touchpadPosition.sqrMagnitude > 0.01f)\n                    return ctrl.touchpadPosition * Time.deltaTime * SCROLL_SPEED;\n                else\n                    return Vector2.zero;    \n            }\n        }\n\n        public class Track\n        {\n            internal IControllerDialog hover;\n            internal PointerEventData pevent;\n            internal Vector3? grab_position;\n            internal bool grab_move;\n            internal GameObject current_pressed;\n            internal bool trigger_down;\n            internal TouchPadScroll touch_pad_scroll;\n            internal Track[] all_tracks;\n        }\n        Track[] tracks;\n\n        private void Gt_onControllersUpdate(Controller[] controllers)\n        {\n            foreach (var ctrl in controllers)\n            {\n                transform.SetPositionAndRotation(ctrl.position, ctrl.rotation);\n\n                var track = ctrl.GetAdditionalData(ref tracks);\n                track.all_tracks = tracks;\n                float closest_distance = float.PositiveInfinity;\n                IControllerDialog closest = null;\n\n                if (track.trigger_down)\n                {\n                    closest_distance = track.hover.FindDistance(camera, force: true);\n                    if (closest_distance > 100)\n                        closest_distance = 100;\n                    closest = track.hover;\n                }\n                else\n                {\n                    foreach (var vr_dialog in FindObjectsOfType<VRDialog>())\n                    {\n                        float distance = vr_dialog.FindDistance(camera);\n                        if (distance < closest_distance)\n                        {\n                            closest_distance = distance;\n                            closest = vr_dialog;\n                        }\n                    }\n\n                    float dist1 = LevelPlatform.FindDistanceTarget(camera, out var target);\n                    if (dist1 < closest_distance)\n                    {\n                        closest_distance = dist1;\n                        closest = target;\n                    }\n                }\n\n                if (track.hover != closest)\n                {\n                    if (track.trigger_down)\n                    {\n                        track.trigger_down = false;\n                        track.hover.TriggerUp(track, camera);\n                    }\n                    if (track.hover != null)\n                        track.hover.Leave(track);\n                    track.hover = closest;\n                    if (closest != null)\n                    {\n                        closest.Enter(track);\n                        ctrl.HapticPulse();\n                    }\n                }\n\n                Material mat;\n                if (closest == null)\n                {\n                    closest_distance = defaultDistance;\n                    mat = lineMissMaterial;\n                }\n                else\n                {\n                    \n\n                }\n            }\n        }\n    }\n}\n\nPlease let me know if there's anything else I can help with.",
    "code_repairing_1": "```csharp\ninternal class Track\n{\n    internal IControllerDialog hover;\n    internal PointerEventData pevent;\n    internal Vector3? grab_position;\n    internal bool grab_move;\n    internal GameObject current_pressed;\n    internal bool trigger_down;\n    internal TouchPadScroll touch_pad_scroll;\n    internal Track[] all_tracks;\n}\n\nprivate void Gt_onControllersUpdate(Controller[] controllers)\n{\n    foreach (var ctrl in controllers)\n    {\n        transform.SetPositionAndRotation(ctrl.position, ctrl.rotation);\n\n        var track = ctrl.GetAdditionalData(ref tracks);\n        track.all_tracks = tracks;\n        float closest_distance = float.PositiveInfinity;\n        IControllerDialog closest = null;\n\n        if (track.trigger_down)\n        {\n            closest_distance = track.hover.FindDistance(camera, force: true);\n            if (closest_distance > 100)\n                closest_distance = 100;\n            closest = track.hover;\n        }\n        else\n        {\n            foreach (var vr_dialog in FindObjectsOfType<VRDialog>())\n            {\n                float distance = vr_dialog.FindDistance(camera);\n                if (distance < closest_distance)\n                {\n                    closest_distance = distance;\n                    closest = vr_dialog;\n                }\n            }\n\n            float dist1 = LevelPlatform.FindDistanceTarget(camera, out var target);\n            if (dist1 < closest_distance)\n            {\n                closest_distance = dist1;\n                closest = target;\n            }\n        }\n\n        if (track.hover != closest)\n        {\n            if (track.trigger_down)\n            {\n                track.trigger_down = false;\n                track.hover.TriggerUp(track, camera);\n            }\n            if (track.hover != null)\n                track.hover.Leave(track);\n            track.hover = closest;\n            if (closest != null)\n            {\n                closest.Enter(track);\n                ctrl.HapticPulse();\n            }\n        }\n\n        Material mat;\n        if (closest == null)\n        {\n            closest_distance = defaultDistance;\n            mat = lineMissMaterial;\n        }\n        else\n        {\n            mat = lineMaterial;\n            closest_distance -= defaultDistance;\n            if (closest_distance < 0)\n                closest_distance = 0;\n        }\n\n        lineMesh.material = mat;\n        lineMesh.position = ctrl.position + ctrl.right * closest_distance;\n        lineMesh.LookAt(ctrl.position, ctrl.up);\n    }\n}\n```",
    "code_repairing_2": "The code appears to be a partial implementation of a VR user interface for a puzzle game. It defines a `ControllersDialog` class that represents a dialog that can be interacted with by a controller, and a `Track` class that tracks the state of the dialog and the controller that is interacting with it.\n\nHere are some suggestions for fixing the code:\n\n1. Add missing using statements for `BaroqueUI` and `NanIndustryVR`.\n2. Add a constructor to the `ControllersDialog` class that takes a `Camera` and a `Material` as parameters.\n3. Move the `TouchPadScroll` class to a separate file, and make it a static nested class of `ControllersDialog`.\n4. Add a constructor to the `Track` class that takes a `Camera` and a `Material` as parameters.\n5. Add a `Vector3` field to the `Track` class to represent the position of the controller when the trigger is pressed.\n6. Add a `HapticPulse` method to the `ControllersDialog` class to simulate a haptic feedback when a controller is interacted with.\n7. Add a `FindDistance` method to the `ControllersDialog` class that returns the distance between the dialog and the controller.\n8. Add a `LevelPlatform` class that represents a platform in the game, and add a `Vector3` field to the `Track` class to represent the position of the platform when the trigger is pressed.\n9. Add a `FindDistanceTarget` method to the `ControllersDialog` class that returns the distance between the platform and the controller.\n10. Add a `using` statement at the top of the file to import the `using System.Collections.Generic;` namespace.\n11. Add a `using` statement at the top of the file to import the `using UnityEngine.UI;` namespace.\n12. Add a `using` statement at the top of the file to import the `using UnityEngine.EventSystems;` namespace.\n\nThe fixed code would look like this:\n```\n\ufeffusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.EventSystems;\nusing BaroqueUI;\nusing NanIndustryVR;\n\nnamespace NanIndustryVR\n{\n    public interface IControllerDialog\n    {\n        float FindDistance(Camera cam, bool force = false);\n        void Enter(ControllersDialog.Track track);\n        void Leave(ControllersDialog.Track track);\n        void Hover(ControllersDialog.Track track, Controller controller, Camera cam);\n        void TriggerDown(ControllersDialog.Track track, Camera cam);\n        void TriggerUp(ControllersDialog.Track track, Camera cam);\n    }\n\n    public class ControllersDialog : MonoBehaviour\n    {\n        public Material lineMaterial, lineMissMaterial;\n        public float defaultDistance;\n\n        Mesh lineMesh;\n        new Camera camera;\n\n        public ControllersDialog(Camera cam, Material lineMaterial)\n        {\n            this.camera = cam;\n            this.lineMaterial = lineMaterial;\n        }\n\n        internal class TouchPadScroll\n        {\n            enum State { WaitTouch, WaitMoveFarEnough, Moving, FreeWheeling };\n            State state = State.WaitTouch;\n            Vector2 original_touch;\n            Vector2 speed_estimate;\n            float previous_time;\n\n            internal Vector2 Handle(Controller ctrl)\n            {\n                if (ctrl.haveRealTouchpad)\n                    return HandleRealTouchpad(ctrl);\n                if (ctrl.haveJoystick)\n                    return HandleJoystick(ctrl);\n                return Vector2.zero;\n            }\n\n            Vector2 HandleRealTouchpad(Controller ctrl)\n            {\n                const float SCROLL_SPEED = 2.5f;\n                bool touched = ctrl.touchpadTouched && !ctrl.touchpadPressed;\n\n                if (state == State.WaitTouch || (state == State.FreeWheeling && touched))\n                {\n                    if (touched)\n                    {\n                        original_touch = ctrl.touchpadPosition;\n                        state = State.WaitMoveFarEnough;\n                    }\n                    return Vector2.zero;\n                }\n                if (state == State.WaitMoveFarEnough)\n                {\n                    if (!touched)\n                    {\n                        state = State.WaitTouch;\n                        return Vector2.zero;\n                    }\n                    if ((ctrl.touchpadPosition - original_touch).sqrMagnitude < 0.01f)\n                        return Vector2.zero;   \n                    state = State.Moving;\n                    previous_time = float.NegativeInfinity;\n                    speed_estimate = Vector2.zero;\n                }\n                \n                \n\n                \n                float delta_time = Time.time - previous_time;\n                previous_time = Time.time;\n                if (state == State.Moving)\n                {\n                    if (touched)\n                    {\n                        Vector2 delta = (ctrl.touchpadPosition - original_touch) * SCROLL_SPEED;\n                        original_touch = ctrl.touchpadPosition;\n                        Vector2 instant_speed = delta / delta_time;\n                        speed_estimate = Vector2.Lerp(\n                            instant_speed, speed_estimate, Mathf.Exp(delta_time * -13f));\n                        return delta;\n                    }\n                    if (speed_estimate.sqrMagnitude < 2f)\n                    {\n                        state = State.WaitTouch;\n                        return Vector2.zero;\n                    }\n                    state = State.FreeWheeling;\n\n                }\n                \n                speed_estimate *= Mathf.Exp(delta_time * -3f);\n                if (ctrl.touchpadPressed || speed_estimate.sqrMagnitude < 0.4f)\n                {\n                    state = State.WaitTouch;\n                    return Vector2.zero;\n                }\n                return speed_estimate * delta_time;\n            }\n\n            Vector2 HandleJoystick(Controller ctrl)\n            {\n                const float SCROLL_SPEED = 4.5f;\n\n                if (ctrl.touchpadPosition.sqrMagnitude > 0.01f)\n                    return ctrl.touchpadPosition * Time.deltaTime * SCROLL_SPEED;\n                else\n                    return Vector2.zero;    \n            }\n        }\n\n        public class Track\n        {\n            internal IControllerDialog hover;\n            internal PointerEventData pevent;\n            internal Vector3? grab_position;\n            internal bool grab_move;\n            internal GameObject current_pressed;\n            internal bool trigger_down;\n            internal TouchPadScroll touch_pad_scroll;\n            internal Track[] all_tracks;\n\n            public Track(Camera cam, Material lineMaterial)\n            {\n                this.camera = cam;\n                this.lineMaterial = lineMaterial;\n            }\n        }\n        Track[] tracks;\n\n        private void Gt_onControllersUpdate(Controller[] controllers)\n        {\n            foreach (var ctrl in controllers)\n            {\n                transform.SetPositionAndRotation(ctrl.position, ctrl.rotation);\n\n                var track = ctrl.GetAdditionalData(ref tracks);\n                track.all_tracks = tracks;\n                float closest_distance = float.PositiveInfinity;\n                IControllerDialog closest = null;\n\n                if (track.trigger_down)\n                {\n                    closest_distance = track.hover.FindDistance(camera, force: true);\n                    if (closest_distance > 100)\n                        closest_distance = 100;\n                    closest = track.hover;\n                }\n                else\n                {\n                    foreach (var vr_dialog in FindObjectsOfType<VRDialog>())\n                    {\n                        float distance = vr_dialog.FindDistance(camera);\n                        if (distance < closest_distance)\n                        {\n                            closest_distance = distance;\n                            closest = vr_dialog;\n                        }\n                    }\n\n                    float dist1 = LevelPlatform.FindDistanceTarget(camera, out var target);\n                    if (dist1 < closest_distance)\n                    {\n                        closest_distance = dist1;\n                        closest = target;\n                    }\n                }\n\n                if (track.hover != closest)\n                {\n                    if (track.trigger_down)\n                    {\n                        track.trigger_down = false;\n                        track.hover.TriggerUp(track, camera);",
    "code_repairing_3": "Here's the fixed code:\n\n\ufeffusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.EventSystems;\nusing BaroqueUI;\nusing System;\n\nnamespace NanIndustryVR\n{\n    public interface IControllerDialog\n    {\n        float FindDistance(Camera cam, bool force = false);\n        void Enter(ControllersDialog.Track track);\n        void Leave(ControllersDialog.Track track);\n        void Hover(ControllersDialog.Track track, Controller controller, Camera cam);\n        void TriggerDown(ControllersDialog.Track track, Camera cam);\n        void TriggerUp(ControllersDialog.Track track, Camera cam);\n    }\n\n    public class ControllersDialog : MonoBehaviour\n    {\n        public Material lineMaterial, lineMissMaterial;\n        public float defaultDistance;\n\n        Mesh lineMesh;\n        new Camera camera;\n\n        private void Start()\n        {\n            lineMesh = new Mesh();\n            lineMesh.vertices = new Vector3[] { Vector3.zero, Vector3.forward };\n            lineMesh.SetIndices(new int[] { 0, 1 }, MeshTopology.Lines, 0);\n            lineMesh.RecalculateBounds();\n            lineMesh.UploadMeshData(true);\n\n            camera = GetComponent<Camera>();\n\n            tracks = new Track[8];\n            var gt = Controller.GlobalTracker(this);\n            gt.onControllersUpdate += Gt_onControllersUpdate;\n        }\n\n        internal class TouchPadScroll\n        {\n            enum State { WaitTouch, WaitMoveFarEnough, Moving, FreeWheeling };\n            State state = State.WaitTouch;\n            Vector2 original_touch;\n            Vector2 speed_estimate;\n            float previous_time;\n\n            internal Vector2 Handle(Controller ctrl)\n            {\n                if (ctrl.haveRealTouchpad)\n                    return HandleRealTouchpad(ctrl);\n                if (ctrl.haveJoystick)\n                    return HandleJoystick(ctrl);\n                return Vector2.zero;\n            }\n\n            Vector2 HandleRealTouchpad(Controller ctrl)\n            {\n                const float SCROLL_SPEED = 2.5f;\n                bool touched = ctrl.touchpadTouched && !ctrl.touchpadPressed;\n\n                if (state == State.WaitTouch || (state == State.FreeWheeling && touched))\n                {\n                    if (touched)\n                    {\n                        original_touch = ctrl.touchpadPosition;\n                        state = State.WaitMoveFarEnough;\n                    }\n                    return Vector2.zero;\n                }\n                if (state == State.WaitMoveFarEnough)\n                {\n                    if (!touched)\n                    {\n                        state = State.WaitTouch;\n                        return Vector2.zero;\n                    }\n                    if ((ctrl.touchpadPosition - original_touch).sqrMagnitude < 0.01f)\n                        return Vector2.zero;   \n                    state = State.Moving;\n                    previous_time = float.NegativeInfinity;\n                    speed_estimate = Vector2.zero;\n                }\n                \n                \n\n                \n                float delta_time = Time.time - previous_time;\n                previous_time = Time.time;\n                if (state == State.Moving)\n                {\n                    if (touched)\n                    {\n                        Vector2 delta = (ctrl.touchpadPosition - original_touch) * SCROLL_SPEED;\n                        original_touch = ctrl.touchpadPosition;\n                        Vector2 instant_speed = delta / delta_time;\n                        speed_estimate = Vector2.Lerp(\n                            instant_speed, speed_estimate, Mathf.Exp(delta_time * -13f));\n                        return delta;\n                    }\n                    if (speed_estimate.sqrMagnitude < 2f)\n                    {\n                        state = State.WaitTouch;\n                        return Vector2.zero;\n                    }\n                    state = State.FreeWheeling;\n\n                }\n                \n                speed_estimate *= Mathf.Exp(delta_time * -3f);\n                if (ctrl.touchpadPressed || speed_estimate.sqrMagnitude < 0.4f)\n                {\n                    state = State.WaitTouch;\n                    return Vector2.zero;\n                }\n                return speed_estimate * delta_time;\n            }\n\n            Vector2 HandleJoystick(Controller ctrl)\n            {\n                const float SCROLL_SPEED = 4.5f;\n\n                if (ctrl.touchpadPosition.sqrMagnitude > 0.01f)\n                    return ctrl.touchpadPosition * Time.deltaTime * SCROLL_SPEED;\n                else\n                    return Vector2.zero;    \n            }\n        }\n\n        public class Track\n        {\n            internal IControllerDialog hover;\n            internal PointerEventData pevent;\n            internal Vector3? grab_position;\n            internal bool grab_move;\n            internal GameObject current_pressed;\n            internal bool trigger_down;\n            internal TouchPadScroll touch_pad_scroll;\n            internal Track[] all_tracks;\n        }\n        Track[] tracks;\n\n        private void Gt_onControllersUpdate(Controller[] controllers)\n        {\n            foreach (var ctrl in controllers)\n            {\n                transform.SetPositionAndRotation(ctrl.position, ctrl.rotation);\n\n                var track = ctrl.GetAdditionalData(ref tracks);\n                track.all_tracks = tracks;\n                float closest_distance = float.PositiveInfinity;\n                IControllerDialog closest = null;\n\n                if (track.trigger_down)\n                {\n                    closest_distance = track.hover.FindDistance(camera, force: true);\n                    if (closest_distance > 100)\n                        closest_distance = 100;\n                    closest = track.hover;\n                }\n                else\n                {\n                    foreach (var vr_dialog in FindObjectsOfType<VRDialog>())\n                    {\n                        float distance = vr_dialog.FindDistance(camera);\n                        if (distance < closest_distance)\n                        {\n                            closest_distance = distance;\n                            closest = vr_dialog;\n                        }\n                    }\n\n                    float dist1 = LevelPlatform.FindDistanceTarget(camera, out var target);\n                    if (dist1 < closest_distance)\n                    {\n                        closest_distance = dist1;\n                        closest = target;\n                    }\n                }\n\n                if (track.hover != closest)\n                {\n                    if (track.trigger_down)\n                    {\n                        track.trigger_down = false;\n                        track.hover.TriggerUp(track, camera);\n                    }\n                    if (track.hover != null)\n                        track.hover.Leave(track);\n                    track.hover = closest;\n                    if (closest != null)\n                    {\n                        closest.Enter(track);\n                        ctrl.HapticPulse();\n                    }\n                }\n\n                Material mat;\n                if (closest == null)\n                {\n                    closest_distance = defaultDistance;\n                    mat = lineMissMaterial;\n                }\n                else\n                {\n                    Debug.Log(\"Distance: \" + closest_distance.ToString());\n\n                    // FIXED CODE: Replaced the usage of \"<\" with \">\" to fix the bug.\n                    if (closest_distance > defaultDistance)\n                    {\n                        mat = lineMaterial;\n                    }\n                    else\n                    {\n                        mat = lineMissMaterial;\n                    }\n                }\n\n                float distance = closest_distance * 0.4f;\n                if (distance > 1.0f)\n                    distance = 1.0f;\n                Vector3 start1 = camera.ViewportToWorldPoint(new Vector3(0, 0, distance));\n                Vector3 end1 = camera.ViewportToWorldPoint(new Vector3(1, 1, distance));\n                lineMesh.vertices = new Vector3[] { start1, end1 };\n                lineMesh.RecalculateBounds();\n                lineMesh.UploadMeshData(true);\n\n                lineMaterial.SetPass(0);",
    "code_repairing_4": "```\n\ufeffusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEngine.EventSystems;\nusing BaroqueUI;\nusing System;\n\nnamespace NanIndustryVR\n{\n    public class ControllersDialog : MonoBehaviour\n    {\n        public Material lineMaterial, lineMissMaterial;\n        public float defaultDistance;\n\n        Mesh lineMesh;\n        new Camera camera;\n\n        private void Start()\n        {\n            lineMesh = new Mesh();\n            lineMesh.vertices = new Vector3[] { Vector3.zero, Vector3.forward };\n            lineMesh.SetIndices(new int[] { 0, 1 }, MeshTopology.Lines, 0);\n            lineMesh.RecalculateBounds();\n            lineMesh.UploadMeshData(true);\n\n            camera = GetComponent<Camera>();\n\n            var gt = Controller.GlobalTracker(this);\n            gt.onControllersUpdate += Gt_onControllersUpdate;\n        }\n\n        internal class Track\n        {\n            internal IControllerDialog hover;\n            internal PointerEventData pevent;\n            internal Vector3? grab_position;\n            internal bool grab_move;\n            internal GameObject current_pressed;\n            internal bool trigger_down;\n            internal TouchPadScroll touch_pad_scroll;\n            internal Track[] all_tracks;\n        }\n        Track[] tracks;\n\n        private void Gt_onControllersUpdate(Controller[] controllers)\n        {\n            foreach (var ctrl in controllers)\n            {\n                transform.SetPositionAndRotation(ctrl.position, ctrl.rotation);\n\n                var track = ctrl.GetAdditionalData(ref tracks);\n                track.all_tracks = tracks;\n                float closest_distance = float.PositiveInfinity;\n                IControllerDialog closest = null;\n\n                if (track.trigger_down)\n                {\n                    closest_distance = track.hover.FindDistance(camera, force: true);\n                    if (closest_distance > 100)\n                        closest_distance = 100;\n                    closest = track.hover;\n                }\n                else\n                {\n                    foreach (var vr_dialog in FindObjectsOfType<VRDialog>())\n                    {\n                        float distance = vr_dialog.FindDistance(camera);\n                        if (distance < closest_distance)\n                        {\n                            closest_distance = distance;\n                            closest = vr_dialog;\n                        }\n                    }\n\n                    float dist1 = LevelPlatform.FindDistanceTarget(camera, out var target);\n                    if (dist1 < closest_distance)\n                    {\n                        closest_distance = dist1;\n                        closest = target;\n                    }\n                }\n\n                if (track.hover != closest)\n                {\n                    if (track.trigger_down)\n                    {\n                        track.trigger_down = false;\n                        track.hover.TriggerUp(track, camera);\n                    }\n                    if (track.hover != null)\n                        track.hover.Leave(track);\n                    track.hover = closest;\n                    if (closest != null)\n                    {\n                        closest.Enter(track);\n                        ctrl.HapticPulse();\n                    }\n                }\n\n                Material mat;\n                if (closest == null)\n                {\n                    closest_distance = defaultDistance;\n                    mat = lineMissMaterial;\n                }\n                else\n                {\n                    \n\n                ```"
}