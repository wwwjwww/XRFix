{
    "code_repairing_0": "if (!(scene.IsValid() && scene.isLoaded))\n                    {\n                        scenesLoadedAndActivated = false;\n                    }             \n\n                }\n                await Task.Yield();\n            }\n\n            SetSceneOpProgress(false, progressTarget, sceneType);\n\n\n            activationToken?.SetReadyToProceed(false);\n\n            InvokeLoadedActions(validNames, sceneType);\n\n\n\n\n            void InvokeWillLoadActions(IEnumerable<string> scenes, SceneType type)\n            {\n                switch (type)\n                {\n                    case SceneType.Content:\n                        OnWillLoadContent?.Invoke(scenes);\n                        break;\n                    case SceneType.Lighting:\n                        foreach (string sceneName in scenes)\n                        {\n                            OnWillLoadLighting?.Invoke(sceneName);\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n\n\n\n            void InvokeLoadedActions(IEnumerable<string> scenes, SceneType type)\n            {\n                switch (type)\n                {\n                    case SceneType.Content:\n                        OnContentLoaded?.Invoke(scenes);\n                        break;\n                    case SceneType.Lighting:\n                        foreach (string sceneName in scenes)\n                        {\n                            OnLightingLoaded?.Invoke(sceneName);\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            void SetSceneOpProgress(bool inProgress, float progress, SceneType type)\n            {\n                managerSceneOpInProgress = (type == SceneType.Manager) ? inProgress : managerSceneOpInProgress;\n                managerSceneOpProgress = (type == SceneType.Manager) ? progress : managerSceneOpProgress;\n                SceneOperationInProgress = (type != SceneType.Manager) ? inProgress : SceneOperationInProgress;\n                SceneOperationProgress = (type != SceneType.Manager) ? progress : SceneOperationProgress;\n            }\n\n\n            bool CanSceneOpProceed(SceneType type)\n            {\n                bool result = true;\n                switch (type)\n                {\n                    case SceneType.Content:\n                        result = !managerSceneOpInProgress && !SceneOperationInProgress;\n                        break;\n                    case SceneType.Lighting:\n                        result = !managerSceneOpInProgress && !SceneOperationInProgress;\n                        break;\n                    case SceneType.Manager:\n                        result = !SceneOperationInProgress;\n                        break;\n                    default:\n                        result = false;\n                        break;\n                }\n                return result;\n            }\n        }\n        \n\n        private async Task UnloadScenesInternal(\n            IEnumerable<string> scenesToUnload,\n            SceneType sceneType,\n            float progressOffset = 0,\n            float progressTarget = 1,\n            bool sceneOpInProgressWhenFinished = false)\n        {\n\n            foreach(string sceneToUnload in scenesToUnload)\n            {\n                Scene scene = SceneManager.GetSceneByName(sceneToUnload);\n                if(!scene.isLoaded)\n                {\n                    Debug.LogError(\"Can't unload scene \" + sceneToUnload + \", it's not loaded.\");\n                }\n            }\n\n            List<string> validNames = new List<string>();\n            List<int> validIndexes = new List<int>();\n            foreach (string sceneName in scenesToUnload)\n            {\n                Scene scene;\n                int sceneIndex;\n                if (!RuntimeSceneUtils.FindScene(sceneName, out scene, out sceneIndex))\n                {\n                    Debug.LogError(\"Can't unload invalid scene \" + sceneName);\n                }\n                else\n                {\n                    validIndexes.Add(sceneIndex);\n                    validNames.Add(sceneName);\n                }\n            }\n\n            int totalSceneOps = validIndexes.Count;\n            if (totalSceneOps < 1)\n            {\n                Debug.LogWarning(\"No valid scenes found to unload.\");\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n\n            InvokeWillUnloadActions(validNames, sceneType);\n\n\n            List<AsyncOperation> unloadSceneOps = new List<AsyncOperation>();\n            foreach (int sceneIndex in validIndexes)\n            {\n                Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                if (!scene.isLoaded)\n                    continue;\n\n                AsyncOperation sceneOp = SceneManager.UnloadSceneAsync(scene);\n\n                unloadSceneOps.Add(sceneOp);\n            }\n\n            bool completedAllSceneOps = false;\n\n            while (!completedAllSceneOps)\n            {\n                if (!Application.isPlaying)\n                {   // Break out of this loop if we've stopped playmode\n                    return;\n                }\n\n                completedAllSceneOps = true;\n\n                float sceneOpProgress = 0;\n                for (int i = 0; i < unloadSceneOps.Count; i++)\n                {\n                    if (unloadSceneOps[i].isDone)\n                    {   // Sometimes if a scene is small enough, progress will get reset to  before you even have a chance to check it\n                        sceneOpProgress += 1;\n                    }\n                    else\n                    {\n                        sceneOpProgress += unloadSceneOps[i].progress;\n                        completedAllSceneOps = false;\n                    }\n                }\n\n                sceneOpProgress = Mathf.Clamp01(SceneOperationProgress / totalSceneOps);\n                \n                SetSceneOpProgress(true, Mathf.Lerp(progressOffset, progressTarget, sceneOpProgress), sceneType);\n\n                await Task.Yield();\n            }\n\n            SetSceneOpProgress(false, progressTarget, sceneType);\n\n            InvokeUnloadedActions(validNames, sceneType);\n\n\n\n            void InvokeWillUnloadActions(IEnumerable<string> scenes, SceneType type)\n            {\n                switch (type)\n                {\n                    case SceneType.Content:\n                        OnWillUnloadContent?.Invoke(scenes);\n                        break;\n                    case SceneType.Lighting:\n                        foreach (string sceneName in scenes)\n                        {\n                            OnWillUnloadLighting?.Invoke(sceneName);\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            void InvokeUnloadedActions(IEnumerable<string> scenes, SceneType type)\n            {\n                switch (type)\n                {\n                    case SceneType.Content:\n                        OnContentUnloaded?.Invoke(scenes);\n                        break;\n                    case SceneType.Lighting:\n                        foreach (string sceneName in scenes)\n                        {\n                            OnLightingUnloaded?.Invoke(sceneName);\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            void SetSceneOpProgress(bool inProgress, float progress, SceneType type)\n            {\n                managerSceneOpInProgress = (type == SceneType.Manager) ? inProgress : managerSceneOpInProgress;\n                managerSceneOpProgress = (type == SceneType.Manager) ? progress : managerSceneOpProgress;\n                SceneOperationInProgress = (type != SceneType.Manager) ? inProgress : SceneOperationInProgress;\n                SceneOperationProgress = (type != SceneType.Manager) ? progress : SceneOperationProgress;\n            }\n        }\n\n        private bool GetLoadedContentScenes(out IEnumerable<string> loadedContentScenes)\n        => loadedContentScenes = ContentSceneNames.Where(IsContentLoaded);\n\n        #endregion\n    }\n}",
    "code_repairing_1": "It seems like you're sharing a large piece of code without asking a specific question. The code you shared seems to be a part of a C# class file related to a scene management system in a mixed reality project, possibly using the Microsoft Mixed Reality Toolkit. The code here includes loading and unloading scenes, managing lighting scenes, and a few other features.\n\nHowever, if you have a specific question about this code or any aspect of programming, I'd be happy to help! For instance, you might be interested in learning more about the LINQ library, async programming in C#, or the usage of UnityEngine.SceneManager, among other things.",
    "code_repairing_2": "Your code seems to be incomplete. To continue your discussion, I need to know what your code is supposed to do and what you're asking. Are you looking for help with debugging, understanding some code, or implementing a new feature?",
    "code_repairing_3": "It seems like you have pasted a large block of code and left it unfinished. You didn't ask a question and I'm not sure what you want to know about this code, but here is a general overview of this class:\n\nThe `MixedRealitySceneSystem` class from Microsoft.MixedReality.Toolkit is used to manage the loading and unloading of content scenes and lighting scenes in a mixed reality application. It provides methods to load/unload specific scenes, and set lighting scenes. You can also get information about the progress of the scene operations.\n\nIt also provides events to notify about the loading and unloading of scenes. It also tracks the previous and next content. \n\nThe code seems to be incomplete as there are several methods that are not implemented and variables that are not initialized. It might be a good practice to complete these parts before using this class in a real project.",
    "code_repairing_4": "It seems like you have cut off the end of some code you're trying to format or explain. If your intent is to debug or ask a question about the code you cut off, please provide more context or clarify your question."
}