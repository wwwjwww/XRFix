{
    "code_repairing_0": "private bool CanSceneOpProceed(SceneType sceneType)\n    {\n        if (WaitingToProceed)\n        {   \n            return false;\n        }\n\n        if (sceneType != SceneType.Content && contentTracker.PrevContentExists && contentTracker.NextContentExists)\n        {   \n            return false;\n        }\n\n        if (sceneType == SceneType.Content && SceneOperationInProgress)\n        {   \n            return false;\n        }\n\n        if (sceneType == SceneType.Lighting && LightingOperationInProgress)\n        {   \n            return false;\n        }\n\n        return true;\n    }\n\n    private void SetSceneOpProgress(bool sceneOpInProgress, float progress, SceneType sceneType)\n    {   \n        if (sceneType == SceneType.Content)\n    SceneOperationInProgress = sceneOpInProgress;\nSceneOperationProgress = progress;\n        else if (sceneType == SceneType.Lighting)\n    LightingOperationInProgress = sceneOpInProgress;\nLightingOperationProgress = progress;\n    }\n\n    private void InvokeWillLoadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n    {\n        switch (sceneType)\n{\n            case SceneType.Content:\n                if (OnWillLoadContent != null)\n                {   \n                    OnWillLoadContent(sceneNames);\n                }\n                break;\n            case SceneType.Lighting:\n                if (OnWillLoadLighting != null)\n                {   \n                    OnWillLoadLighting(sceneNames.FirstOrDefault());\n                }\n                break;\n        }\n    }\n\n    private void InvokeDidLoadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n    {\n        switch (sceneType)\n{\n            case SceneType.Content:\n                if (OnContentLoaded != null)\n                {   \n                    OnContentLoaded(sceneNames);\n                }\n                break;\n            case SceneType.Lighting:\n                if (OnLightingLoaded != null)\n                {   \n                    OnLightingLoaded(sceneNames.FirstOrDefault());\n                }\n                break;\n        }\n    }\n\n    private void InvokeWillUnloadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n    {\n        switch (sceneType)\n{\n            case SceneType.Content:\n                if (OnWillUnloadContent != null)\n                {   \n                    OnWillUnloadContent(sceneNames);\n                }\n                break;\n            case SceneType.Lighting:\n                if (OnWillUnloadLighting != null)\n                {   \n                    OnWillUnloadLighting(sceneNames.FirstOrDefault());\n                }\n                break;\n        }\n    }\n\n    private void InvokeDidUnloadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n    {\n        switch (sceneType)\n{\n            case SceneType.Content:\n                if (OnContentUnloaded != null)\n                {   \n                    OnContentUnloaded(sceneNames);\n                }\n                break;\n            case SceneType.Lighting:\n                if (OnLightingUnloaded != null)\n                {   \n                    OnLightingUnloaded(sceneNames.FirstOrDefault());\n                }\n                break;\n        }\n    }\n}",
    "code_repairing_1": "private async Task LoadScenesInternal(\n            IEnumerable<string> scenesToLoad,\n            SceneType sceneType,\n            SceneActivationToken activationToken = null,\n            float progressOffset = 0,\n            float progressTarget = 1,\n            bool sceneOpInProgressWhenFinished = false)\n        {\n            \n            activationToken?.SetReadyToProceed(false);\n\n            SetSceneOpProgress(true, progressOffset, sceneType);\n\n            \n            List<string> validNames = new List<string>();\n            List<int> validIndexes = new List<int>();\n\n            foreach (string sceneName in scenesToLoad)\n            {\n                \n                Scene scene;\n                int sceneIndex;\n                if (!RuntimeSceneUtils.FindScene(sceneName, out scene, out sceneIndex))\n                {\n                    Debug.LogError(\"Can't load invalid scene \" + sceneName);\n                }\n                else\n                {\n                    validIndexes.Add(sceneIndex);\n                    validNames.Add(sceneName);\n                }\n            }\n\n            int totalSceneOps = validIndexes.Count;\n            if (totalSceneOps < 1)\n            {\n                Debug.LogWarning(\"No valid scenes found to load.\");\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n            \n            InvokeWillLoadActions(validNames, sceneType);\n\n            \n            if (validIndexes.Count > 0)\n            {\n                List<AsyncOperation> loadSceneOps = new List<AsyncOperation>();\n                foreach (int sceneIndex in validIndexes)\n                {\n                    Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                    if (scene.isLoaded)\n                        continue;\n\n                    AsyncOperation sceneOp = SceneManager.LoadSceneAsync(sceneIndex, LoadSceneMode.Additive);\n                    \n                    sceneOp.allowSceneActivation = (activationToken != null) ? activationToken.AllowSceneActivation : true;\n                    loadSceneOps.Add(sceneOp);\n                }\n\n                \n                bool completedAllSceneOps = false;\n\n                while (!completedAllSceneOps)\n                {\n                    if (!Application.isPlaying)\n                    {\n                        return;\n                    }\n\n                    completedAllSceneOps = true;\n                    bool readyToProceed = false;\n                    bool allowSceneActivation = (activationToken != null) ? activationToken.AllowSceneActivation : true;\n\n                    \n                    float sceneOpProgress = 0;\n                    for (int i = 0; i < loadSceneOps.Count; i++)\n                    {\n                        \n                        \n                        loadSceneOps[i].allowSceneActivation = allowSceneActivation;\n\n                        if (loadSceneOps[i].isDone)\n                        {\n                            \n                            \n                            sceneOpProgress += 1;\n                        }\n                        else\n                        {\n                            readyToProceed |= loadSceneOps[i].progress >= SceneActivationLoadProgress;\n                            sceneOpProgress += loadSceneOps[i].progress;\n                            completedAllSceneOps = false;\n                        }\n                    }\n\n                    \n                    activationToken?.SetReadyToProceed(readyToProceed);\n\n                    sceneOpProgress = Mathf.Clamp01(SceneOperationProgress / totalSceneOps);\n                    \n                    SetSceneOpProgress(true, Mathf.Lerp(progressOffset, progressTarget, sceneOpProgress), sceneType);\n\n                    await Task.Yield();\n                }\n            }\n\n            \n            bool scenesLoadedAndActivated = false;\n            while (!scenesLoadedAndActivated)\n            {\n                if (!Application.isPlaying)\n                {\n                    return;\n                }\n\n                scenesLoadedAndActivated = true;\n                foreach (int sceneIndex in validIndexes)\n                {\n                    Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                    // BUG: Potentially dangerous use of non-short-circuit logic\n                    // MESSAGE: The & and | operators do not use short-circuit evaluation and can be dangerous when applied to boolean operands. In particular, their use can result in errors if the left-hand operand checks for cases in which it is not safe to evaluate the right-hand one.\n                    //                     scenesLoadedAndActivated &= (scene.IsValid() & scene.isLoaded);\n\n                    // FIXED CODE:\n\n                    scenesLoadedAndActivated |= scene.IsValid() && scene.isLoaded;\n                }\n            }\n\n            if (activationToken != null)\n            {   \n                activationToken.SetReadyToProceed(true);\n            }\n\n            await Task.Yield();\n            \n            if (sceneOpInProgressWhenFinished)\n            {   \n                SetSceneOpProgress(false, 0, sceneType);\n            }\n            \n            InvokeDidLoadActions(validNames, sceneType);\n        }",
    "code_repairing_2": "FIXED CODE:\n\n\ufeff\n\nusing Microsoft.MixedReality.Toolkit.Utilities;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.SceneManagement;\n\nnamespace Microsoft.MixedReality.Toolkit.SceneSystem\n{\n\n\n\n\n\n    [HelpURL(\"https:\n    public partial class MixedRealitySceneSystem : BaseCoreSystem, IMixedRealitySceneSystem\n    {\n\n\n        const float SceneActivationLoadProgress = 0.9f;\n\n\n\n\n        private enum SceneType\n        {\n            Manager = 0,\n            Content = 1,\n            Lighting = 2,\n        }\n\n\n        public MixedRealitySceneSystem(\n            IMixedRealityServiceRegistrar registrar,\n            MixedRealitySceneSystemProfile profile) : base(registrar, profile)\n        {\n            this.profile = profile;\n        }\n\n\n        private MixedRealitySceneSystemProfile profile;\n\n\n        private bool managerSceneOpInProgress;\n        private float managerSceneOpProgress;\n\n\n        private SceneContentTracker contentTracker;\n\n\n        private SceneLightingExecutor lightingExecutor;\n\n\n        public override string Name { get; protected set; } = \"Mixed Reality Scene System\";\n\n\n#region Actions\n\n\n\n        public Action<IEnumerable<string>> OnWillLoadContent { get; set; }\n\n\n\n\n        public Action<IEnumerable<string>> OnContentLoaded { get; set; }\n\n\n\n\n        public Action<IEnumerable<string>> OnWillUnloadContent { get; set; }\n\n\n\n\n        public Action<IEnumerable<string>> OnContentUnloaded { get; set; }\n\n\n\n\n        public Action<string> OnWillLoadLighting { get; set; }\n\n\n\n\n        public Action<string> OnLightingLoaded { get; set; }\n\n\n\n\n        public Action<string> OnWillUnloadLighting { get; set; }\n\n\n\n\n        public Action<string> OnLightingUnloaded { get; set; }\n\n\n\n\n        public Action<string> OnWillLoadScene { get; set; }\n\n\n\n\n        public Action<string> OnSceneLoaded { get; set; }\n\n\n\n\n        public Action<string> OnWillUnloadScene { get; set; }\n\n\n\n\n        public Action<string> OnSceneUnloaded { get; set; }\n\n\n#endregion\n\n\n#region Properties\n\n\n\n        public bool SceneOperationInProgress { get; private set; } = false;\n\n\n\n        public float SceneOperationProgress { get; private set; } = 0;\n\n\n\n\n        public bool LightingOperationInProgress { get; private set; } = false;\n\n\n\n\n        public float LightingOperationProgress { get; private set; } = 0;\n\n\n\n\n        public string ActiveLightingScene { get; private set; } = string.Empty;\n\n\n\n\n        public bool WaitingToProceed { get; private set; } = false;\n\n\n\n\n        public bool PrevContentExists => contentTracker.PrevContentExists;\n\n\n\n\n        public bool NextContentExists => contentTracker.NextContentExists;\n\n\n\n\n        public string[] ContentSceneNames => contentTracker.ContentSceneNames;\n\n\n\n\n        public uint SourceId { get; } = 0;\n\n\n\n\n        public string SourceName { get; } = \"Mixed Reality Scene System\";\n\n\n#endregion\n\n\n#region Service Methods\n\n\n\n        public override void Initialize()\n        {\n\n\n            contentTracker = new SceneContentTracker(profile);\n            lightingExecutor = new SceneLightingExecutor();\n\n\n#if UNITY_EDITOR\n            EditorOnInitialize();\n#endif\n\n\n\n            if (!Application.isPlaying)\n            {\n                return;\n            }\n\n\n\n\n            if (profile.UseManagerScene)\n            {\n                SetManagerScene(profile.ManagerScene.Name);\n            }\n\n\n\n\n            if (profile.UseLightingScene)\n            {\n                SetLightingScene(profile.DefaultLightingScene.Name, LightingSceneTransitionType.None);\n            }\n        }\n\n\n\n\n        public override void Enable()\n        {\n\n\n\n#if UNITY_EDITOR\n            EditorOnDisable();\n#endif\n        }\n\n\n\n\n        public override void Disable()\n        {\n\n\n\n#if UNITY_EDITOR\n            EditorOnDisable();\n#endif\n        }\n\n\n\n\n        public override void Destroy()\n        {\n\n\n\n#if UNITY_EDITOR\n            EditorOnDestroy();\n#endif\n        }\n\n\n\n\n        public override void Update()\n        {\n\n\n\n\n\n\n\n            if (profile.UseLightingScene)\n            {\n                lightingExecutor.UpdateTransition(Time.unscaledDeltaTime);\n            }\n\n        }\n\n\n#endregion\n\n\n#region Scene Operations\n\n\n\n\n\n\n\n        public async Task LoadNextContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            string nextContent;\n            if (contentTracker.GetNextContent(wrap, out nextContent))\n            {\n                await LoadContent(new string[] { nextContent }, mode, activationToken);\n            }\n            else\n            {\n                Debug.LogWarning(\"Attempted to load next content when no next content exists. Taking no action.\");\n            }\n        }\n\n\n\n\n\n\n\n        public async Task LoadPrevContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            string prevContent;\n            if (contentTracker.GetPrevContent(wrap, out prevContent))\n            {\n                await LoadContent(new string[] { prevContent }, mode, activationToken);\n            }\n            else\n            {\n                Debug.LogWarning(\"Attempted to load prev content when no next content exists. Taking no action.\");\n            }\n        }\n\n\n\n\n\n\n\n        public async Task LoadContent(string sceneToLoad, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            await LoadContent(new string[] { sceneToLoad }, mode, activationToken);\n        }\n\n\n\n\n\n\n\n        public async Task UnloadContent(string sceneToUnload)\n        {\n            await UnloadContent(new string[] { sceneToUnload });\n        }\n\n\n\n\n\n\n\n        public async Task LoadContent(IEnumerable<string> scenesToLoad, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            if (!CanSceneOpProceed(SceneType.Content))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            IEnumerable<string> loadedContentScenes;\n            if (mode == LoadSceneMode.Single && GetLoadedContentScenes(out loadedContentScenes))\n            {\n                await UnloadScenesInternal(loadedContentScenes, SceneType.Content, 0, 0.5f, true);\n                await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken, 0.5f, 1f, false);\n            }\n            else\n            {\n                await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken);\n            }\n        }\n\n\n\n\n\n\n        public async Task UnloadContent(IEnumerable<string> scenesToUnload)\n        {\n            if (!CanSceneOpProceed(SceneType.Content))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            await UnloadScenesInternal(scenesToUnload, SceneType.Content);\n        }\n\n\n\n\n\n\n\n        public bool IsContentLoaded(string sceneName)\n        {\n            Scene scene = SceneManager.GetSceneByName(sceneName);\n            return scene.IsValid() && scene.isLoaded;\n        }\n\n\n\n\n\n\n        public async void SetLightingScene(string newLightingSceneName, LightingSceneTransitionType transitionType = LightingScene",
    "code_repairing_3": "```\n\ufeff\n\nusing Microsoft.MixedReality.Toolkit.Utilities;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.SceneManagement;\n\nnamespace Microsoft.MixedReality.Toolkit.SceneSystem\n{\n    \n    \n    \n    \n    \n    [HelpURL(\"https:\n    public partial class MixedRealitySceneSystem : BaseCoreSystem, IMixedRealitySceneSystem\n    {\n        \n        \n        \n        \n        const float SceneActivationLoadProgress = 0.9f;\n\n        \n        \n        \n        private enum SceneType\n        {\n            Manager = 0,\n            Content = 1,\n            Lighting = 2,\n        }\n\n        public MixedRealitySceneSystem(\n            IMixedRealityServiceRegistrar registrar,\n            MixedRealitySceneSystemProfile profile) : base(registrar, profile)\n        {\n            this.profile = profile;\n        }\n\n        private MixedRealitySceneSystemProfile profile;\n\n        \n        private bool managerSceneOpInProgress;\n        private float managerSceneOpProgress;\n\n        \n        private SceneContentTracker contentTracker;\n        \n        private SceneLightingExecutor lightingExecutor;\n\n        \n        public override string Name { get; protected set; } = \"Mixed Reality Scene System\";\n\n        #region Actions\n\n        \n        public Action<IEnumerable<string>> OnWillLoadContent { get; set; }\n\n        \n        public Action<IEnumerable<string>> OnContentLoaded { get; set; }\n\n        \n        public Action<IEnumerable<string>> OnWillUnloadContent { get; set; }\n\n        \n        public Action<IEnumerable<string>> OnContentUnloaded { get; set; }\n\n        \n        public Action<string> OnWillLoadLighting { get; set; }\n\n        \n        public Action<string> OnLightingLoaded { get; set; }\n\n        \n        public Action<string> OnWillUnloadLighting { get; set; }\n\n        \n        public Action<string> OnLightingUnloaded { get; set; }\n\n        \n        public Action<string> OnWillLoadScene { get; set; }\n\n        \n        public Action<string> OnSceneLoaded { get; set; }\n\n        \n        public Action<string> OnWillUnloadScene { get; set; }\n\n        \n        public Action<string> OnSceneUnloaded { get; set; }\n\n        #endregion\n\n        #region Properties\n\n        \n        public bool SceneOperationInProgress { get; private set; } = false;\n\n        \n        public float SceneOperationProgress { get; private set; } = 0;\n\n        \n        public bool LightingOperationInProgress { get; private set; } = false;\n\n        \n        public float LightingOperationProgress { get; private set; } = 0;\n\n        \n        public string ActiveLightingScene { get; private set; } = string.Empty;\n\n        \n        public int NextContentIndex => contentTracker.NextContentIndex;\n\n        \n        public int PrevContentIndex => contentTracker.PrevContentIndex;\n\n        \n        public string[] ContentSceneNames => contentTracker.ContentSceneNames;\n\n        \n        public uint SourceId { get; } = 0;\n\n        \n        public string SourceName { get; } = \"Mixed Reality Scene System\";\n\n        #endregion\n\n        #region Service Methods\n\n        \n        public override void Initialize()\n        {\n            \n            contentTracker = new SceneContentTracker(profile);\n            lightingExecutor = new SceneLightingExecutor();\n\n#if UNITY_EDITOR\n            EditorOnInitialize();\n#endif\n\n            if (!Application.isPlaying)\n            {\n                return;\n            }\n\n            if (profile.UseManagerScene)\n            {\n                SetManagerScene(profile.ManagerScene.Name);\n            }\n\n            if (profile.UseLightingScene)\n            {   \n                SetLightingScene(profile.DefaultLightingScene.Name, LightingSceneTransitionType.None);\n            }\n        }\n\n        \n        public override void Enable()\n        {\n#if UNITY_EDITOR\n            EditorOnDisable();\n#endif\n        }\n\n        \n        public override void Disable()\n        {\n#if UNITY_EDITOR\n            EditorOnDisable();\n#endif\n        }\n\n        \n        public override void Destroy()\n        {\n#if UNITY_EDITOR\n            EditorOnDestroy();\n#endif\n        }\n\n        \n        public override void Update()\n        {\n            \n            if (profile.UseLightingScene)\n            {\n                lightingExecutor.UpdateTransition(Time.unscaledDeltaTime);\n            }\n        }\n\n        #endregion\n\n        #region Scene Operations\n\n        \n        public async Task LoadNextContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            string nextContent;\n            if (contentTracker.GetNextContent(wrap, out nextContent))\n            {\n                await LoadContent(new string[] { nextContent }, mode, activationToken);\n            }\n            else\n            {\n                Debug.LogWarning(\"Attempted to load next content when no next content exists. Taking no action.\");\n            }\n        }\n\n        \n        public async Task LoadPrevContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            string prevContent;\n            if (contentTracker.GetPrevContent(wrap, out prevContent))\n            {\n                await LoadContent(new string[] { prevContent }, mode, activationToken);\n            }\n            else\n            {\n                Debug.LogWarning(\"Attempted to load prev content when no next content exists. Taking no action.\");\n            }\n        }\n\n        \n        public async Task LoadContent(string sceneToLoad, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            await LoadContent(new string[] { sceneToLoad }, mode, activationToken);\n        }\n\n        \n        public async Task UnloadContent(string sceneToUnload)\n        {\n            await UnloadContent(new string[] { sceneToUnload });\n        }\n\n        \n        public async Task LoadContentByTag(string tag, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            await LoadContent(profile.GetContentSceneNamesByTag(tag), mode, activationToken);\n        }\n\n        \n        public async Task UnloadContentByTag(string tag)\n        {\n            await UnloadScenesInternal(profile.GetContentSceneNamesByTag(tag), SceneType.Content);\n        }\n\n        \n        public async Task LoadContent(IEnumerable<string> scenesToLoad, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            if (!CanSceneOpProceed(SceneType.Content))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            IEnumerable<string> loadedContentScenes;\n            if (mode == LoadSceneMode.Single && GetLoadedContentScenes(out loadedContentScenes))\n            {\n                await UnloadScenesInternal(loadedContentScenes, SceneType.Content, 0, 0.5f, true);\n                await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken, 0.5f, 1f, false);\n            }\n            else\n            {\n                await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken);\n            }\n\n            await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken);\n        }\n\n        \n        public async Task UnloadContent(IEnumerable<string> scenesToUnload)\n        {\n            if (!CanSceneOpProceed(SceneType.Content))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            await UnloadScenesInternal(scenesToUnload, SceneType.Content);\n        }\n\n        \n        public bool IsContentLoaded(string sceneName)\n        {\n            Scene scene = SceneManager.GetSceneByName(sceneName);",
    "code_repairing_4": "private async Task LoadScenesInternal(\n            IEnumerable<string> scenesToLoad,\n            SceneType sceneType,\n            SceneActivationToken activationToken = null,\n            float progressOffset = 0,\n            float progressTarget = 1,\n            bool sceneOpInProgressWhenFinished = false)\n        {\n            \n            activationToken?.SetReadyToProceed(false);\n\n            SetSceneOpProgress(true, progressOffset, sceneType);\n\n            \n            List<string> validNames = new List<string>();\n            List<int> validIndexes = new List<int>();\n\n            foreach (string sceneName in scenesToLoad)\n            {\n                \n                Scene scene;\n                int sceneIndex;\n                if (!RuntimeSceneUtils.FindScene(sceneName, out scene, out sceneIndex))\n                {\n                    Debug.LogError(\"Can't load invalid scene \" + sceneName);\n                }\n                else\n                {\n                    validIndexes.Add(sceneIndex);\n                    validNames.Add(sceneName);\n                }\n            }\n\n            int totalSceneOps = validIndexes.Count;\n            if (totalSceneOps < 1)\n            {\n                Debug.LogWarning(\"No valid scenes found to load.\");\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n            \n            InvokeWillLoadActions(validNames, sceneType);\n\n            \n            if (validIndexes.Count > 0)\n            {\n                List<AsyncOperation> loadSceneOps = new List<AsyncOperation>();\n                foreach (int sceneIndex in validIndexes)\n                {\n                    Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                    if (scene.isLoaded)\n                        continue;\n\n                    AsyncOperation sceneOp = SceneManager.LoadSceneAsync(sceneIndex, LoadSceneMode.Additive);\n                    \n                    sceneOp.allowSceneActivation = (activationToken != null) ? activationToken.AllowSceneActivation : true;\n                    loadSceneOps.Add(sceneOp);\n                }\n\n                \n                bool completedAllSceneOps = false;\n\n                while (!completedAllSceneOps)\n                {\n                    if (!Application.isPlaying)\n                    {   \n                        return;\n                    }\n\n                    completedAllSceneOps = true;\n                    bool readyToProceed = false;\n                    bool allowSceneActivation = (activationToken != null) ? activationToken.AllowSceneActivation : true;\n\n                    \n                    float sceneOpProgress = 0;\n                    for (int i = 0; i < loadSceneOps.Count; i++)\n                    {\n                        \n                        \n                        loadSceneOps[i].allowSceneActivation = allowSceneActivation;\n\n                        if (loadSceneOps[i].isDone)\n                        {   \n                            \n                            \n                            sceneOpProgress += 1;\n                        }\n                        else\n                        {\n                            readyToProceed |= loadSceneOps[i].progress >= SceneActivationLoadProgress;\n                            sceneOpProgress += loadSceneOps[i].progress;\n                            completedAllSceneOps = false;\n                        }\n                    }\n\n                    \n                    activationToken?.SetReadyToProceed(readyToProceed);\n\n                    sceneOpProgress = Mathf.Clamp01(SceneOperationProgress / totalSceneOps);\n                    \n                    SetSceneOpProgress(true, Mathf.Lerp(progressOffset, progressTarget, sceneOpProgress), sceneType);\n\n                    await Task.Yield();\n                }\n            }\n\n            \n            bool scenesLoadedAndActivated = false;\n            while (!scenesLoadedAndActivated)\n            {\n                if (!Application.isPlaying)\n                {   \n                    return;\n                }\n\n                scenesLoadedAndActivated = true;\n                foreach (int sceneIndex in validIndexes)\n                {\n                    Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                    // BUG: Potentially dangerous use of non-short-circuit logic\n                    // MESSAGE: The & and | operators do not use short-circuit evaluation and can be dangerous when applied to boolean operands. In particular, their use can result in errors if the left-hand operand checks for cases in which it is not safe to evaluate the right-hand one.\n                    //                     scenesLoadedAndActivated &= (scene.IsValid() & scene.isLoaded);\n\n                    // FIXED CODE:\n\n                    if (scene.IsValid() && scene.isLoaded)\n                    {   \n                        scenesLoadedAndActivated = true;\n                        break;\n                    }\n                }\n            }\n        }"
}