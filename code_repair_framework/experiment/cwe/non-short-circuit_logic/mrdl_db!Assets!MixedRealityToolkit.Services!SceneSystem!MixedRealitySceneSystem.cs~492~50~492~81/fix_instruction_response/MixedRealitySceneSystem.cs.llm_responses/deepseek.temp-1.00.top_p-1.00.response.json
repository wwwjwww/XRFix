{
    "code_repairing_0": "It seems like your code chunk is cut off. However, in the context of MixedRealitySceneSystem class, you are looking for some methods related to loading and unloading content, and setting or changing of lighting scene. \n\nSo, if you have any specific method or property you're looking for, could you please provide more details? I can help you write or understand any part of the above code, or any code related to MixedRealitySceneSystem.",
    "code_repairing_1": "if (scene.IsValid() && !scene.isLoaded) //scene is valid, but not loaded.\n{\n    scenesLoadedAndActivated = false; //reset the flag.\n    break; //stop checking the rest of the scenes.\n}\n                }\n\nInvokeLoadedActions(validNames, sceneType);\n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n        }\n\n\n        private async Task UnloadScenesInternal(\n            IEnumerable<string> scenesToUnload,\n            SceneType sceneType,\n            float progressOffset = 0,\n            float progressTarget = 1,\n            bool sceneOpInProgressWhenFinished = false)\n        {\n            SetSceneOpProgress(true, progressOffset, sceneType);\n\n            List<string> sceneNames = new List<string>(scenesToUnload);\n\n            InvokeWillUnloadActions(sceneNames, sceneType);\n\n            List<AsyncOperation> unloadSceneOps = new List<AsyncOperation>();\n\n            bool allScenesValid = true;\n            foreach (string sceneName in scenesToUnload)\n            {\n                Scene scene;\n                int sceneIndex;\n                RuntimeSceneUtils.FindScene(sceneName, out scene, out sceneIndex);\n\n                if (scene.IsValid())\n                {   // Unload operations are not allowed for persistent scenes that are included in a Build\n                    if (!scene.isLoaded || scene.isPersistent)\n                    {\n                        Debug.LogWarning(\"Cannot unload scene \" + sceneName +\n                            \" because it is either not loaded or a persistent scene.\");\n                    }\n                    else if (SceneManager.sceneCount == 1)\n                    {   // All the loaded scenes are persistent, so we cannot unload any of them\n                        Debug.LogError(\"Not possible to unload scene \" + sceneName +\n                            \" because only the main scene \" + SceneManager.GetActiveScene().name + \" is left.\");\n                        allScenesValid = false;\n                    }\n                    else if (!unloadSceneOps.Contains(sceneIndex))\n                    {   // Add to list if not already added\n                        unloadSceneOps.Add(SceneManager.UnloadSceneAsync(scene));\n                    }\n                }\n                else\n                {\n                    Debug.LogError(\"Cannot unload scene \" + sceneName + \" because it does not exist.\");\n                    sceneNames.Remove(sceneName);\n                    allScenesValid = false;\n                }\n            }\n\n            if (allScenesValid)\n            {\n                bool scenesUnloaded = false;\n\n                List<int> unloadIndexes = new List<int>();\n                for (int i = 0; i < unloadSceneOps.Count; i++)\n                {\n                    unloadIndexes.Add(SceneManager.GetSceneByIndex(i));\n                }\n\n                float sceneOpProgress = 0;\n\n                while (!scenesUnloaded)\n                {\n                    if (!Application.isPlaying)\n                    {   // Break out of this loop if we've stopped playmode\n                        return;\n                    }\n\n                    scenesUnloaded = true;\n                    for (int i = 0; i < unloadSceneOps.Count; i++)\n                    {\n                        if (!unloadSceneOps[i].isDone)\n                        {\n                            scenesUnloaded = false;\n                            break;\n                        }\n\n                        sceneOpProgress += 1;\n                    }\n\n                    sceneOpProgress = Mathf.Clamp01(SceneOperationProgress / unloadSceneOps.Count);\n                    SetSceneOpProgress(true, Mathf.Lerp(progressOffset, progressTarget, sceneOpProgress), sceneType);\n                    await Task.Yield();\n                }\n\n                InvokeUnloadedActions(sceneNames, sceneType);\n            }\n\n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n        }\n\n\n        private void SetSceneOpProgress(bool inProgress, float progress, SceneType sceneType)\n        {\n            SceneOperationInProgress = inProgress;\n            SceneOperationProgress = progress;\n\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    if (profile.ContentLoadUnloadProgressReporter != null)\n                    {\n                        profile.ContentLoadUnloadProgressReporter.Report(progress);\n                    }\n                    break;\n                case SceneType.Lighting:\n                    if (profile.LightingLoadUnloadProgressReporter != null)\n                        profile.LightingLoadUnloadProgressReporter.Report(progress);\n                    break;\n            }\n        }\n\n        private bool CanSceneOpProceed(SceneType sceneType)\n        {\n            if (SceneOperationInProgress)\n            {\n                return false;\n            }\n\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    return !profile.ContentSceneOperationsBlocked;\n                case SceneType.Lighting:\n                    return !profile.LightingSceneOperationsBlocked;\n                default:\n                    return true;\n            }\n        }\n\n        private void InvokeWillLoadActions(IEnumerable<string> scenes, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnWillLoadContent?.Invoke(scenes);\n                    break;\n                case SceneType.Lighting:\n                    OnWillLoadLighting?.Invoke(scenes.FirstOrDefault());\n                    break;\n            }\n        }\n\n        private void InvokeLoadedActions(IEnumerable<string> scenes, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnContentLoaded?.Invoke(scenes);\n                    break;\n                case SceneType.Lighting:\n                    SetLightingScene(scenes.FirstOrDefault());\n                    OnLightingLoaded?.Invoke(scenes.FirstOrDefault());\n                    break;\n            }\n        }\n\n        private void InvokeWillUnloadActions(IEnumerable<string> scenes, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnWillUnloadContent?.Invoke(scenes);\n                    break;\n                case SceneType.Lighting:\n                    OnWillUnloadLighting?.Invoke(scenes.FirstOrDefault());\n                    break;\n            }\n        }\n\n        private void InvokeUnloadedActions(IEnumerable<string> scenes, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnContentUnloaded?.Invoke(scenes);\n                    break;\n                case SceneType.Lighting:\n                    OnLightingUnloaded?.Invoke(scenes.FirstOrDefault());\n                    break;\n            }\n        }\n\n        #endregion\n\n        #region Editor Only Methods\n\n\n\n        private void EditorOnInitialize()\n        {\n            //Nothing to do as of yet.\n        }\n\n\n        private void EditorOnDisable()\n        {\n            //Nothing to do as of yet.\n        }\n\n\n        private void EditorOnDestroy()\n        {\n            //Nothing to do as of yet.\n        }\n\n        #endregion\n   }\n}\n\n\n\n\n\n\n   \n\n\n\n\n\n\n   \n\n\n\n   \n    \n\n    #region Private Classes\n\n    private class SceneContentTracker\n    {\n\n        private MixedRealitySceneSystemProfile profile;\n\n        private int cursor;\n\n        public SceneContentTracker(MixedRealitySceneSystemProfile profile)\n        {\n            this.profile = profile;\n            SortSceneNames();\n        }\n\n        private void SortSceneNames()\n        {\n            profile.ContentSceneNames = profile.ContentSceneNames.OrderBy(name => name).ToArray();\n        }\n\n        public bool GetNextContent(bool wrap, out string nextContent)\n        {\n            if (profile.ContentSceneNames.Length < 1)\n            {\n                nextContent = string.Empty;\n                return false;\n            }\n\n            int nextIndex = cursor + 1;\n            if (nextIndex >= profile.ContentSceneNames.Length)\n            {\n                if (wrap)\n                {\n                    nextIndex = 0;\n                }\n                else\n                {\n                    nextContent = string.Empty;\n                    return false;\n                }\n            }\n\n            nextContent = profile.ContentSceneNames[nextIndex];\n            cursor = nextIndex;\n            return true;\n        }\n\n\n        public bool GetPrevContent(bool wrap, out string prevContent)\n        {\n            if (profile.ContentSceneNames.Length < 1)\n            {\n                prevContent = string();\n                return false;\n            }\n\n            int prevIndex = cursor - 1;\n            if (prevIndex < 0)\n            {\n                if (wrap)\n                {\n                    prevIndex = profile.ContentSceneNames.Length - 1;\n                }\n                else\n                {\n                    prevContent = string.Empty;\n                    return false;\n                }\n            }\n\n            prevContent = profile.ContentSceneNames[prevIndex];\n            cursor = prevIndex;\n            return true;\n        }\n\n        public bool PrevContentExists => cursor > 0;\n\n        public bool NextContentExists => cursor < profile.ContentSceneNames.Length - 1;\n\n        public string[] ContentSceneNames => profile.ContentSceneNames;\n    }\n\n    #endregion\n}",
    "code_repairing_2": "It seems you are getting your code cut off at the end. However, you seem to have made a small error in the `while` loop for checking if all scenes have been activated. It seems like there is a misunderstanding in the documentation you are reading. The correct way to check if all scenes have been activated is by comparing the total number of scenes with the number of scenes that have been activated.\n\nHere's a corrected version of the code snippet:\n\n```csharp\nbool scenesLoadedAndActivated = false;\nint scenesActivated = 0;\nwhile (!scenesLoadedAndActivated)\n{\n    if (!Application.isPlaying)\n    {   // Break out of this loop if we've stopped playmode\n        return;\n    }\n\n    scenesActivated = 0;\n    foreach (int sceneIndex in validIndexes)\n    {\n        Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n        if (scene.isLoaded)\n        {\n            scenesActivated++;\n        }\n    }\n    scenesLoadedAndActivated = scenesActivated == totalSceneOps;\n    await Task.Yield();\n}\n```\n\nPlease replace your code with the above snippet to fix the issue. This code will check the number of scenes that have been loaded and activated against the total number of scenes to be loaded. If they match, it will set `scenesLoadedAndActivated` to `true`.",
    "code_repairing_3": "scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded);\n\n\n                    scenesLoadedAndActivated &= activationToken?.AllowSceneActivation ?? true;\n\n                }\n                if (!scenesLoadedAndActivated)\n                {\n                    await Task.Yield();\n                }\n            }\n\n\n            foreach (string sceneName in validNames)\n            {\n                RuntimeSceneUtils.HandleSceneActivated(sceneName, () => !scenesLoadedAndActivated, () => { });\n            }\n\n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n\n            InvokeLoadedActions(validNames, sceneType);\n\n            activationToken?.SetReadyToProceed(true);\n        }\n\n\n        private async Task UnloadScenesInternal(\n            IEnumerable<string> scenesToUnload,\n            SceneType sceneType,\n            float progressOffset = 0,\n            float progressTarget = 1,\n            bool sceneOpInProgressWhenFinished = false)\n        {\n            int unloadedScenes = 0;\n            int totalScenes = 0;\n\n            List<string> validNames = new List<string>();\n            foreach (string sceneName in scenesToUnload)\n            {\n                if (RuntimeSceneUtils.IsSceneValid(sceneName))\n                {\n                    validNames.Add(sceneName);\n                    totalScenes++;\n                }\n            }\n\n            if (totalScenes < 1)\n            {\n                Debug.LogWarning(\"No valid scenes to unload.\");\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n            InvokeWillUnloadActions(validNames, sceneType);\n\n            List<AsyncOperation> unloadSceneOps = new List<AsyncOperation>();\n            foreach (string sceneName in validNames)\n            {\n                AsyncOperation sceneOp = SceneManager.UnloadSceneAsync(sceneName);\n                unloadSceneOps.Add(sceneOp);\n            }\n\n            bool completedAllSceneOps = false;\n\n            while (!completedAllSceneOps)\n            {\n                if (!Application.isPlaying)\n                {   // Break out of this loop if we've stopped playmode\n                    return;\n                }\n\n                completedAllSceneOps = true;\n\n                float sceneOpProgress = 0;\n                for (int i = 0; i < unloadSceneOps.Count; i++)\n                {\n                    if (unloadSceneOps[i].isDone)\n                    {\n                        unloadedScenes++;\n                    }\n                    else\n                    {\n                        sceneOpProgress += unloadSceneOps[i].progress;\n                        completedAllSceneOps = false;\n                    }\n                }\n\n                sceneOpProgress = Mathf.Clamp01(unloadedScenes / (float)totalScenes);\n                SetSceneOpProgress(true, Mathf.Lerp(progressOffset, progressTarget, sceneOpProgress), sceneType);\n\n                await Task.Yield();\n            }\n\n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n\n            InvokeUnloadedActions(validNames, sceneType);\n        }\n\n\n        private bool CanSceneOpProceed(SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    return !managerSceneOpInProgress;\n                case SceneType.Lighting:\n                    return !SceneOperationInProgress;\n                case SceneType.Manager:\n                    return !SceneOperationInProgress;\n                default:\n                    Debug.Assert(false, \"Unknown scene type\");\n                    return false;\n            }\n        }\n\n\n        private void SetSceneOpProgress(bool inProgress, float progress, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    managerSceneOpInProgress = inProgress;\n                    managerSceneOpProgress = progress;\n                    break;\n                case SceneType.Lighting:\n                    LightingOperationInProgress = inProgress;\n                    LightingOperationProgress = progress;\n                    break;\n                case SceneType.Manager:\n                    SceneOperationInProgress = inProgress;\n                    SceneOperationProgress = progress;",
    "code_repairing_4": "The provided code seems to be incomplete or not related to computer science, so I won't be able to provide a useful answer. If you have any questions related to programming, computer science, or AI, feel free to ask!"
}