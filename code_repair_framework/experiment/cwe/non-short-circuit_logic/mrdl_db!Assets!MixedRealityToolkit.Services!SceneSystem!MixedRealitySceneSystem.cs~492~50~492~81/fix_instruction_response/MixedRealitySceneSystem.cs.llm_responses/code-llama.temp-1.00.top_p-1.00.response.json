{
    "code_repairing_0": "```csharp\n if (!scene.IsValid())\n {\n      scenesLoadedAndActivated = false;\n      break;\n }\n\n scnSceneLoadedAndActivated &= scene.isLoaded;\n     }\n }\n\n // ...\n \n if (scnSceneLoadedAndActivated)\n {\n     SceneActivationToken activationToken = activationToken ?? new SceneActivationToken();\n     await SceneActivationManager.Instance.ActivateAsync(activationToken, validIndexes);\n     activationToken?.SetReadyToProceed(true);\n\n     foreach (int sceneIndex in validIndexes)\n     {\n         SceneManager.UnloadSceneAsync(sceneIndex);\n     }\n\n     SceneActivationManager.Instance.ClearSceneActivationFlags();\n     \n     SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n     OnContentLoaded?.Invoke(scenesToLoad);\n     \n     return;\n }\n ```\n This code fix the issue of the scenes not correctly being loaded and activated, by using the `&&` operator instead of the `&` operator to verify the `IsValid()` and `isLoaded` properties. The `&&` operator also causes a short circuit evaluation, so the right-hand operand is only evaluated when the left-hand operand is `true`, ensuring that an error is not thrown.\n \n Additionally, the `SetSceneOpProgress()` function is used to update the progress value of the current scene operation, and the `OnContentLoaded` action is invoked with the list of loaded scenes as a parameter.",
    "code_repairing_1": "scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded) ;\n                    if (!scene.IsValid() || !scene.isLoaded)\n                    {\n                        scenesLoadedAndActivated = false;\n                    }\n                }\n\n                await Task.Yield();\n            }\n\n            \n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n\n            \n            InvokeSceneLoadedActions(validNames, sceneType);\n\n            if (!Application.isPlaying)\n            {   \n                return;\n            }\n\n            \n            foreach (int sceneIndex in validIndexes)\n            {\n                Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                scene.SetEnabled(true);\n            }\n\n            if (sceneType == SceneType.Content)\n            {\n                contentTracker.LoadContent();\n            }\n        }\n\n        \n        \n        \n        private async Task UnloadScenesInternal(\n            IEnumerable<string> scenesToUnload,\n            SceneType sceneType,\n            float progressOffset = 0,\n            float progressTarget = 1,\n            bool sceneOpInProgressWhenFinished = false)\n        {\n            \n            List<string> unloadSceneNames = new List<string>();\n            List<int> unloadSceneIndexes = new List<int>();\n\n            foreach (string sceneName in scenesToUnload)\n            {\n                if (RuntimeSceneUtils.GetSceneIndex(sceneName, out int sceneIndex))\n                {   \n                    unloadSceneNames.Add(sceneName);\n                    unloadSceneIndexes.Add(sceneIndex);\n                }\n                else\n                {   \n                    Debug.LogError(\"Can't unload invalid scene \" + sceneName);\n                }\n            }\n\n            int totalSceneOps = unloadSceneIndexes.Count;\n            if (totalSceneOps < 1)\n            {   \n                Debug.LogWarning(\"No valid scenes found to unload.\");\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n            \n            InvokeWillUnloadActions(unloadSceneNames, sceneType);\n\n            if (unloadSceneIndexes.Count > 0)\n            {\n                bool unloadAllSucceeded = true;\n                for (int i = 0; i < unloadSceneIndexes.Count; i++)\n                {   \n                    if (!RuntimeSceneUtils.UnloadScene(unloadSceneIndexes[i]))\n                    {\n                        unloadAllSucceeded = false;\n                    }\n                }\n\n                if (!unloadAllSucceeded)\n                {   \n                    Debug.LogError(\"Failed to unload at least one scene\");\n                    SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                    return;\n                }\n            }\n\n            \n            await Task.Yield();\n\n            \n            await UpdateSceneState(unloadSceneNames, unloadSceneIndexes, progressOffset, progressTarget, sceneOpInProgressWhenFinished, sceneType);\n        }\n        \n        \n        private async Task UnloadScenesInternal(int[] sceneIndexes, SceneType sceneType, float progressOffset = 0, float progressTarget = 1, bool sceneOpInProgressWhenFinished = false)\n        {\n            \n            List<string> unloadSceneNames = new List<string>();\n\n            foreach (int sceneIndex in sceneIndexes)\n            {\n                if (!RuntimeSceneUtils.GetSceneName(sceneIndex, out string sceneName))\n                {   \n                    Debug.LogError(\"Invalid scene index: \" + sceneIndex);\n\n                    // FIXED CODE:\n \n }\n                else\n                {   \n                    unloadSceneNames.Add(sceneName);\n                }\n            }\n\n            await UnloadScenesInternal(unloadSceneNames, sceneType, progressOffset, progressTarget, sceneOpInProgressWhenFinished);\n        }\n\n        \n        private bool CanSceneOpProceed(SceneType sceneType)\n        {\n            bool sceneOpInProgress = (sceneType == SceneType.Manager && managerSceneOpInProgress) || (sceneType == SceneType.Lighting && LightingOperationInProgress) || (sceneType == SceneType.Content && SceneOperationInProgress);\n            if (sceneOpInProgress)\n            {   \n                Debug.LogWarning(\"Can't perform scene op (\" + sceneType + \") while one is already in progress\");\n            }\n            return !sceneOpInProgress;\n        }\n\n        \n        private void SetSceneOpProgress(bool sceneOpInProgress, float sceneOpProgress, SceneType sceneType)\n        {\n            if (sceneType == SceneType.Manager)\n            {   \n                managerSceneOpInProgress = sceneOpInProgress;\n                managerSceneOpProgress = sceneOpProgress;\n            }\n            else if (sceneType == SceneType.Lighting)\n            {   \n                LightingOperationInProgress = sceneOpInProgress;\n                LightingOperationProgress = sceneOpProgress;\n            }\n            else if (sceneType == SceneType.Content)\n            {   \n                SceneOperationInProgress = sceneOpInProgress;\n                SceneOperationProgress = sceneOpProgress;\n            }\n        }\n\n        \n        private void InvokeWillLoadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            Action<IEnumerable<string>> action = null;\n            if (sceneType == SceneType.Content)\n            {   \n                action = OnWillLoadContent;\n            }\n            else if (sceneType == SceneType.Lighting)\n            {   \n                action = OnWillLoadLighting;\n            }\n\n            if (action == null)\n            {   \n                return;\n            }\n\n            action(sceneNames);\n        }\n\n        \n        private void InvokeSceneLoadedActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            Action<IEnumerable<string>> action = null;\n            if (sceneType == SceneType.Content)\n            {   \n                action = OnContentLoaded;\n            }\n            else if (sceneType == SceneType.Lighting)\n            {   \n                action = OnLightingLoaded;\n            }\n\n            if (action == null)\n            {   \n                return;\n            }\n\n            action(sceneNames);\n        }\n\n        \n        private void InvokeWillUnloadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            Action<IEnumerable<string>> action = null;\n            if (sceneType == SceneType.Content)\n            {   \n                action = OnWillUnloadContent;\n            }\n            else if (sceneType == SceneType.Lighting)\n            {   \n                action = OnWillUnloadLighting;\n            }\n\n            if (action == null)\n            {   \n                return;\n            }\n\n            action(sceneNames);\n        }\n\n        \n        private void InvokeSceneUnloadedActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            Action<IEnumerable<string>> action = null;\n            if (sceneType == SceneType.Content)\n            {   \n                action = OnContentUnloaded;\n            }\n            else if (sceneType == SceneType.Lighting)\n            {   \n                action = OnLightingUnloaded;\n            }\n\n            if (action == null)\n            {   \n                return;\n            }\n\n            action(sceneNames);\n        }\n\n        \n        private bool GetLoadedContentScenes(out IEnumerable<string> loadedContentSceneNames)\n        {\n            return contentTracker.GetLoadedContentSceneNames(out loadedContentSceneNames);\n        }\n\n        \n        private void EditorOnInitialize()\n        {\n            \n            if (Application.isPlaying)\n            {\n                return;\n            }\n\n            \n            SceneManager.sceneLoaded += HandleSceneLoad;\n\n            \n            SceneManager.sceneUnloaded += HandleSceneUnload;\n\n            \n            contentTracker.contentManager.OnContentLoad += HandleContentLoad;\n        }\n\n        \n        private void EditorOnDisable()\n        {\n            \n            if (Application.isPlaying)\n            {\n                return;\n            }\n\n            contentTracker.contentManager.OnContentLoad -= HandleContentLoad;\n\n            \n            SceneManager.sceneLoaded -= HandleSceneLoad;\n\n            \n            SceneManager.sceneUnloaded -= HandleSceneUnload;\n        }\n\n        \n        private void EditorOnDestroy()\n        {",
    "code_repairing_2": "private async Task LoadScenesInternal(\n            IEnumerable<string> scenesToLoad,\n            SceneType sceneType,\n            SceneActivationToken activationToken = null,\n            float progressOffset = 0,\n            float progressTarget = 1,\n            bool sceneOpInProgressWhenFinished = false)\n        {\n            \n            activationToken?.SetReadyToProceed(false);\n\n            SetSceneOpProgress(true, progressOffset, sceneType);\n\n            \n            List<string> validNames = new List<string>();\n            List<int> validIndexes = new List<int>();\n\n            foreach (string sceneName in scenesToLoad)\n            {\n                \n                Scene scene;\n                int sceneIndex;\n                if (!RuntimeSceneUtils.FindScene(sceneName, out scene, out sceneIndex))\n                {\n                    Debug.LogError(\"Can't load invalid scene \" + sceneName);\n                }\n                else\n                {\n                    validIndexes.Add(sceneIndex);\n                    validNames.Add(sceneName);\n                }\n            }\n\n            int totalSceneOps = validIndexes.Count;\n            if (totalSceneOps < 1)\n            {\n                Debug.LogWarning(\"No valid scenes found to load.\");\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n            \n            InvokeWillLoadActions(validNames, sceneType);\n\n            \n            if (validIndexes.Count > 0)\n            {\n                List<AsyncOperation> loadSceneOps = new List<AsyncOperation>();\n                foreach (int sceneIndex in validIndexes)\n                {\n                    Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                    if (scene.isLoaded)\n                        continue;\n\n                    AsyncOperation sceneOp = SceneManager.LoadSceneAsync(sceneIndex, LoadSceneMode.Additive);\n                    \n                    sceneOp.allowSceneActivation = (activationToken != null) ? activationToken.AllowSceneActivation : true;\n                    loadSceneOps.Add(sceneOp);\n                }\n\n                \n                bool completedAllSceneOps = false;\n\n                while (!completedAllSceneOps)\n                {\n                    if (!Application.isPlaying)\n                    {\n                        return;\n                    }\n\n                    completedAllSceneOps = true;\n                    bool readyToProceed = false;\n                    bool allowSceneActivation = (activationToken != null) ? activationToken.AllowSceneActivation : true;\n\n                    \n                    float sceneOpProgress = 0;\n                    for (int i = 0; i < loadSceneOps.Count; i++)\n                    {\n                        \n                        \n                        loadSceneOps[i].allowSceneActivation = allowSceneActivation;\n\n                        if (loadSceneOps[i].isDone)\n                        {\n                            sceneOpProgress += 1;\n                        }\n                        else\n                        {\n                            readyToProceed |= loadSceneOps[i].progress >= SceneActivationLoadProgress;\n                            sceneOpProgress += loadSceneOps[i].progress;\n                            completedAllSceneOps = false;\n                        }\n                    }\n\n                    \n                    activationToken?.SetReadyToProceed(readyToProceed);\n\n                    sceneOpProgress = Mathf.Clamp01(SceneOperationProgress / totalSceneOps);\n                    \n                    SetSceneOpProgress(true, Mathf.Lerp(progressOffset, progressTarget, sceneOpProgress), sceneType);\n\n                    await Task.Yield();\n                }\n            }\n\n            \n            bool scenesLoadedAndActivated = false;\n            while (!scenesLoadedAndActivated)\n            {\n                if (!Application.isPlaying)\n                {\n                    return;\n                }\n\n                scenesLoadedAndActivated = true;\n                foreach (int sceneIndex in validIndexes)\n                {\n                    Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                    // BUG: Potentially dangerous use of non-short-circuit logic\n                    // MESSAGE: The & and | operators do not use short-circuit evaluation and can be dangerous when applied to boolean operands. In particular, their use can result in errors if the left-hand operand checks for cases in which it is not safe to evaluate the right-hand one.\n                    //                     scenesLoadedAndActivated &= (scene.IsValid() & scene.isLoaded);\n\n                    //Replace the operator with the short circuit equivalent. \n                    // FIXED CODE:\n\n                 scenesLoadedAndActivated = scenesLoadedAndActivated & (scene.isLoaded & scene.isActive);\n\n                    if (!scenesLoadedAndActivated)\n                    {\n                        await Task.Yield();\n                    }\n                }\n            }\n        }",
    "code_repairing_3": "scenesLoadedAndActivated = (scene.IsValid() && scene.isLoaded) && scenesLoadedAndActivated;\n                    \n                }\n\n                if (!scenesLoadedAndActivated)\n                {\n                    await Task.Yield();\n                }\n            }\n\n            \n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n\n            \n            InvokeContentLoadedActions(validNames, sceneType);\n        }\n\n        \n        \n        private async Task UnloadScenesInternal(IEnumerable<string> scenesToUnload, SceneType sceneType, float progressOffset = 0, float progressTarget = 1, bool sceneOpInProgressWhenFinished = false)\n        {\n            \n            SetSceneOpProgress(true, progressOffset, sceneType);\n\n            \n            List<string> validNames = new List<string>();\n\n            IEnumerable<string> loadedScenes = SceneManager.GetScenes();\n            foreach (string sceneNameToUnload in scenesToUnload)\n            {\n                \n                if (loadedScenes.Any(ls => ls.name == sceneNameToUnload))\n                {   \n                    validNames.Add(sceneNameToUnload);\n                }\n            }\n\n            \n            if (validNames.Count < 1)\n            {   \n                SetSceneOpProgress(SceneOpInProgressWhenFinished, ProgressTarget, sceneType);\n                return;\n            }\n\n            \n            InvokeWillUnloadActions(validNames, sceneType);\n\n            \n            List<AsyncOperation> asyncOperations = new List<AsyncOperation>();\n\n            \n            foreach (string sceneName in validNames)\n            {\n                SceneInfo sceneInfo;\n                if (!profile.GetContentSceneInfoByName(sceneName, out sceneInfo))\n                {   \n                    Debug.LogError(\"Can't find scene info for scene \" + sceneName);\n                }\n                else\n                {\n                    Scene scene = SceneManager.GetSceneByName(sceneName);\n                    if (!scene.isLoaded)\n                    {   \n                        Debug.LogWarning(\"There is no scene \" + sceneName + \" to unload\");\n                        continue;\n                    }\n\n                    AsyncOperation sceneOp = SceneManager.UnloadSceneAsync(sceneName);\n                    asyncOperations.Add(sceneOp);\n                }\n            }\n\n            \n            float sceneOpProgress = 0;\n\n            while (asyncOperations.Count > 0)\n            {\n                if (!Application.isPlaying)\n                {   \n                    return;\n                }\n\n                bool allAsyncsCompleted = true;\n\n                \n                foreach (AsyncOperation asyncOp in asyncOperations)\n                {   \n                    if (!asyncOp.isDone)\n                    {   \n                        allAsyncsCompleted = false;\n                    }\n                }\n\n                if (allAsyncsCompleted)\n                {   \n                    sceneOpProgress += 1;\n                }\n                else\n                {   \n                    sceneOpProgress += (SceneOperationProgress / asyncOperations.Count);\n                }\n\n                \n                SetSceneOpProgress(true, Mathf.Lerp(progressOffset, progressTarget, sceneOpProgress), sceneType);\n\n                await Task.Yield();\n            }\n\n            \n            SetSceneOpProgress(SceneOpInProgressWhenFinished, progressTarget, sceneType);\n\n            \n            InvokeContentUnloadedActions(validNames, sceneType);\n        }\n\n        \n        private void SetSceneOpProgress(bool sceneOpInProgress, float sceneOpProgress, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    SceneOperationInProgress = sceneOpInProgress;\n                    SceneOperationProgress = sceneOpProgress;\n                    break;\n                case SceneType.Lighting:\n                    LightingOperationInProgress = sceneOpInProgress;\n                    LightingOperationProgress = sceneOpProgress;\n                    break;\n                default:\n                    Debug.LogError(\"Attempted to set scene op progress on unsupported scene type.\");\n                    break;\n            }\n        }\n\n        \n        private void InvokeContentLoadedActions(IEnumerable<string> loadedContentNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnContentLoaded?.Invoke(loadedContentNames);\n                    break;\n                case SceneType.Lighting:\n                    OnLightingLoaded?.Invoke(LoadedLightingSceneName);\n                    break;\n                default:\n                    Debug.LogError(\"Attempted to invoke loaded content actions on unsupported scene type.\");\n                    break;\n            }\n        }\n\n        \n        private void InvokeContentUnloadedActions(IEnumerable<string> unloadedContentNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnContentUnloaded?.Invoke(unloadedContentNames);\n                    break;\n                case SceneType.Lighting:\n                    OnLightingUnloaded?.Invoke(UnloadedLightingSceneName);\n                    break;\n                default:\n                    Debug.LogError(\"Attempted to invoke unloaded content actions on unsupported scene type.\");\n                    break;\n            }\n        }\n\n        \n        private void InvokeWillLoadActions(IEnumerable<string> loadedContentNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnWillLoadContent?.Invoke(loadedContentNames);\n                    break;\n                case SceneType.Lighting:\n                    OnWillLoadLighting?.Invoke(LoadedLightingSceneName);\n                    break;\n                default:\n                    Debug.LogError(\"Attempted to invoke will load actions on unsupported scene type.\");\n                    break;\n            }\n        }\n\n        \n        private void InvokeWillUnloadActions(IEnumerable<string> unloadedContentNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnWillUnloadContent?.Invoke(unloadedContentNames);\n                    break;\n                case SceneType.Lighting:\n                    OnWillUnloadLighting?.Invoke(UnloadedLightingSceneName);\n                    break;\n                default:\n                    Debug.LogError(\"Attempted to invoke will unload actions on unsupported scene type.\");\n                    break;\n            }\n        }\n\n        \n        private bool CanSceneOpProceed(SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    return !SceneOperationInProgress;\n                case SceneType.Lighting:\n                    return !LightingOperationInProgress;\n                default:\n                    Debug.LogError(\"Attempted to check scene op readiness on unsupported scene type.\");\n                    return false;\n            }\n        }\n\n        \n        private bool GetLoadedContentScenes(out IEnumerable<string> loadedContentScenes)\n        {\n            loadedContentScenes = SceneManager.GetScenes().Select(s => s.name);\n            return loadedContentScenes.Any();\n        }\n\n        \n        private T SafeReadMixedRealityProfile<T>(\n            string sceneName,\n            SceneType sceneType, \n            out string resultString,\n            Func<string, T> defaultResult) where T : Component\n        {\n            resultString = string.Empty;\n            if (string.IsNullOrEmpty(sceneName))\n            {   \n                return defaultResult(string.Empty);\n            }\n\n            Scene scene = SceneManager.GetSceneByName(sceneName);\n            if (!scene.IsValid())\n            {   \n                return defaultResult(string.Empty);\n            }\n\n            T result = scene.GetRootGameObjects().Select(go => go.GetComponent<T>()).FirstOrDefault();\n            if (result != null)\n            {   \n                return result;\n            }\n\n            GameObject[] contentGameObjects = scene.GetRootGameObjects();\n            if (contentGameObjects == null || contentGameObjects.Length < 1)\n            {   \n                Debug.LogWarning(\"No game objects found in scene \" + sceneName + \", taking no action.\");\n                return defaultResult(string.Empty);\n            }\n\n            UnityEngine.Object[] referencedObjects = contentGameObjects.SelectMany(g => g.GetComponentsInChildren<UnityEngine.Object>());\n            GameObject resultObject = referencedObjects.FirstOrDefault(o => o is T) as GameObject;\n            if (resultObject != null)",
    "code_repairing_4": "```\n\ufeffusing Microsoft.MixedReality.Toolkit.Utilities;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.SceneManagement;\n\nnamespace Microsoft.MixedReality.Toolkit.SceneSystem\n{\n    \n    \n    \n    \n    \n    [HelpURL(\"https:\n    public partial class MixedRealitySceneSystem : BaseCoreSystem, IMixedRealitySceneSystem\n    {\n        \n        \n        \n        \n        const float SceneActivationLoadProgress = 0.9f;\n\n        \n        \n        \n        private enum SceneType\n        {\n            Manager = 0,\n            Content = 1,\n            Lighting = 2,\n        }\n\n        public MixedRealitySceneSystem(\n            IMixedRealityServiceRegistrar registrar,\n            MixedRealitySceneSystemProfile profile) : base(registrar, profile)\n        {\n            this.profile = profile;\n        }\n\n        private MixedRealitySceneSystemProfile profile;\n\n        \n        private bool managerSceneOpInProgress;\n        private float managerSceneOpProgress;\n\n        \n        private SceneContentTracker contentTracker;\n        \n        private SceneLightingExecutor lightingExecutor;\n\n        \n        public override string Name { get; protected set; } = \"Mixed Reality Scene System\";\n\n        #region Actions\n\n        \n        public Action<IEnumerable<string>> OnWillLoadContent { get; set; }\n\n        \n        public Action<IEnumerable<string>> OnContentLoaded { get; set; }\n\n        \n        public Action<IEnumerable<string>> OnWillUnloadContent { get; set; }\n\n        \n        public Action<IEnumerable<string>> OnContentUnloaded { get; set; }\n\n        \n        public Action<string> OnWillLoadLighting { get; set; }\n\n        \n        public Action<string> OnLightingLoaded { get; set; }\n\n        \n        public Action<string> OnWillUnloadLighting { get; set; }\n\n        \n        public Action<string> OnLightingUnloaded { get; set; }\n\n        \n        public Action<string> OnWillLoadScene { get; set; }\n\n        \n        public Action<string> OnSceneLoaded { get; set; }\n\n        \n        public Action<string> OnWillUnloadScene { get; set; }\n\n        \n        public Action<string> OnSceneUnloaded { get; set; }\n\n        #endregion\n\n        #region Properties\n\n        \n        public bool SceneOperationInProgress { get; private set; } = false;\n\n        \n        public float SceneOperationProgress { get; private set; } = 0;\n\n        \n        public bool LightingOperationInProgress { get; private set; } = false;\n\n        \n        public float LightingOperationProgress { get; private set; } = 0;\n\n        \n        public string ActiveLightingScene { get; private set; } = string.Empty;\n\n        \n        public bool WaitingToProceed { get; private set; } = false;\n\n        \n        public bool PrevContentExists => contentTracker.PrevContentExists;\n\n        \n        public bool NextContentExists => contentTracker.NextContentExists;\n\n        \n        public string[] ContentSceneNames => contentTracker.ContentSceneNames;\n\n        \n        public uint SourceId { get; } = 0;\n\n        \n        public string SourceName { get; } = \"Mixed Reality Scene System\";\n\n        #endregion\n\n        #region Service Methods\n\n        \n        public override void Initialize()\n        {\n            \n            contentTracker = new SceneContentTracker(profile);\n            lightingExecutor = new SceneLightingExecutor();\n\n#if UNITY_EDITOR\n            EditorOnInitialize();\n#endif\n\n            if (!Application.isPlaying)\n            {\n                return;\n            }\n\n            if (profile.UseManagerScene)\n            {\n                SetManagerScene(profile.ManagerScene.Name);\n            }\n\n            if (profile.UseLightingScene)\n            {   \n                SetLightingScene(profile.DefaultLightingScene.Name, LightingSceneTransitionType.None);\n            }\n        }\n\n        \n        public override void Enable()\n        {\n#if UNITY_EDITOR\n            EditorOnDisable();\n#endif\n        }\n\n        \n        public override void Disable()\n        {\n#if UNITY_EDITOR\n            EditorOnDisable();\n#endif\n        }\n\n        \n        public override void Destroy()\n        {\n#if UNITY_EDITOR\n            EditorOnDestroy();\n#endif\n        }\n\n        \n        public override void Update()\n        {\n            \n            if (profile.UseLightingScene)\n            {\n                lightingExecutor.UpdateTransition(Time.unscaledDeltaTime);\n            }\n        }\n\n        #endregion\n\n        #region Scene Operations\n\n        \n        public async Task LoadNextContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            string nextContent;\n            if (contentTracker.GetNextContent(wrap, out nextContent))\n            {\n                await LoadContent(new string[] { nextContent }, mode, activationToken);\n            }\n            else\n            {\n                Debug.LogWarning(\"Attempted to load next content when no next content exists. Taking no action.\");\n            }\n        }\n\n        \n        public async Task LoadPrevContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            string prevContent;\n            if (contentTracker.GetPrevContent(wrap, out prevContent))\n            {\n                await LoadContent(new string[] { prevContent }, mode, activationToken);\n            }\n            else\n            {\n                Debug.LogWarning(\"Attempted to load prev content when no next content exists. Taking no action.\");\n            }\n        }\n\n        \n        public async Task LoadContent(string sceneToLoad, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            await LoadContent(new string[] { sceneToLoad }, mode, activationToken);\n        }\n\n        \n        public async Task UnloadContent(string sceneToUnload)\n        {\n            await UnloadContent(new string[] { sceneToUnload });\n        }\n\n        \n        public async Task LoadContentByTag(string tag, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            await LoadContent(profile.GetContentSceneNamesByTag(tag), mode, activationToken);\n        }\n\n        \n        public async Task UnloadContentByTag(string tag)\n        {\n            await UnloadScenesInternal(profile.GetContentSceneNamesByTag(tag), SceneType.Content);\n        }\n\n        \n        public async Task LoadContent(IEnumerable<string> scenesToLoad, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            if (!CanSceneOpProceed(SceneType.Content))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            IEnumerable<string> loadedContentScenes;\n            if (mode == LoadSceneMode.Single && GetLoadedContentScenes(out loadedContentScenes))\n            {\n                await UnloadScenesInternal(loadedContentScenes, SceneType.Content, 0, 0.5f, true);\n                await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken, 0.5f, 1f, false);\n            }\n            else\n            {\n                await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken);\n            }\n\n            await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken);\n        }\n\n        \n        public async Task UnloadContent(IEnumerable<string> scenesToUnload)\n        {\n            if (!CanSceneOpProceed(SceneType.Content))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            await UnloadScenesInternal(scenesToUnload, SceneType.Content);\n        }\n\n        \n        public bool IsContentLoaded(string sceneName)"
}