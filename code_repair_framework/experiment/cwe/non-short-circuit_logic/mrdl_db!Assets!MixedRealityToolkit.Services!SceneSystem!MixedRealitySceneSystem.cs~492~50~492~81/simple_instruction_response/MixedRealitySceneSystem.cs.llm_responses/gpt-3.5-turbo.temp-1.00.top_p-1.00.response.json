{
    "id": "chatcmpl-9yyyxKCJhwmRmY5dLkjtMbXnFRmKQ",
    "object": "chat.completion",
    "created": 1724321123,
    "model": "gpt-35-turbo",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "            scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded && scene.isLoaded);\n                }\n            }\n\n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n            InvokeContentLoadedActions(validNames, sceneType);\n        }\n\n        \n        private async Task UnloadScenesInternal(IEnumerable<string> scenesToUnload, SceneType sceneType, float progressOffset = 0, float progressTarget = 1, bool sceneOpInProgressWhenFinished = false)\n        {\n            SetSceneOpProgress(true, progressOffset, sceneType);\n\n            List<string> validNames = new List<string>();\n            List<int> validIndexes = new List<int>();\n\n            foreach (string sceneName in scenesToUnload)\n            {\n                Scene scene;\n                int sceneIndex;\n                if (!RuntimeSceneUtils.FindScene(sceneName, out scene, out sceneIndex))\n                {\n                    Debug.LogError(\"Can't unload invalid scene \" + sceneName);\n                }\n                else\n                {\n                    validIndexes.Add(sceneIndex);\n                    validNames.Add(sceneName);\n                }\n            }\n\n            if (validIndexes.Count < 1)\n            {\n                Debug.LogWarning(\"No valid scenes found to unload.\");\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n            InvokeWillUnloadActions(validNames, sceneType);\n\n            if (validIndexes.Count > 0)\n            {\n                List<AsyncOperation> unloadSceneOps = new List<AsyncOperation>();\n                foreach (int sceneIndex in validIndexes)\n                {\n                    Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                    if (!scene.isLoaded)\n                        continue;\n\n                    AsyncOperation sceneOp = SceneManager.UnloadSceneAsync(sceneIndex);\n                    unloadSceneOps.Add(sceneOp);\n                }\n\n                while (true)\n                {\n                    if (!Application.isPlaying)\n                    {\n                        return;\n                    }\n\n                    bool completedAllSceneOps = true;\n                    foreach (AsyncOperation sceneOp in unloadSceneOps)\n                    {\n                        completedAllSceneOps &= (sceneOp.isDone && sceneOp.progress >= SceneActivationLoadProgress);\n                    }\n\n                    if (completedAllSceneOps)\n                    {\n                        break;\n                    }\n\n                    float sceneOpProgress = unloadSceneOps.Sum(op => op.progress) / unloadSceneOps.Count;\n                    SetSceneOpProgress(true, Mathf.Lerp(progressOffset, progressTarget, sceneOpProgress), sceneType);\n\n                    await Task.Yield();\n                }\n            }\n\n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n            InvokeContentUnloadedActions(validNames, sceneType);\n        }\n\n        \n        private void InvokeWillLoadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnWillLoadContent?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnWillLoadLighting?.Invoke(sceneNames.First());\n                    break;\n                case SceneType.Manager:\n                    OnWillLoadScene?.Invoke(sceneNames.First());\n                    break;\n                default:\n                    Debug.LogError(\"Unsupported scene type\");\n                    break;\n            }\n        }\n\n        \n        private void InvokeContentLoadedActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnContentLoaded?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnLightingLoaded?.Invoke(sceneNames.First());\n                    break;\n                case SceneType.Manager:\n                    OnSceneLoaded?.Invoke(sceneNames.First());\n                    break;\n                default:\n                    Debug.LogError(\"Unsupported scene type\");\n                    break;\n            }\n        }\n\n        \n        private void InvokeWillUnloadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnWillUnloadContent?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnWillUnloadLighting?.Invoke(sceneNames.First());\n                    break;\n                case SceneType.Manager:\n                    OnWillUnloadScene?.Invoke(sceneNames.First());\n                    break;\n                default:\n                    Debug.LogError(\"Unsupported scene type\");\n                    break;\n            }\n        }\n\n        \n        private void InvokeContentUnloadedActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnContentUnloaded?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnLightingUnloaded?.Invoke(sceneNames.First());\n                    break;\n                case SceneType.Manager:\n                    OnSceneUnloaded?.Invoke(sceneNames.First());\n                    break;\n                default:\n                    Debug.LogError(\"Unsupported scene type\");\n                    break;\n            }\n        }\n\n        \n        private void SetSceneOpProgress(bool inProgress, float progress, SceneType sceneType)\n        {\n            if (inProgress)\n            {\n                switch (sceneType)\n                {\n                    case SceneType.Content:\n                        SceneOperationProgress = progress;\n                        break;\n                    case SceneType.Lighting:\n                        LightingOperationProgress = progress;\n                        break;\n                    case SceneType.Manager:\n                        managerSceneOpProgress = progress;\n                        break;\n                    default:\n                        Debug.LogError(\"Unsupported scene type\");\n                        break;\n                }\n            }\n            else\n            {\n                switch (sceneType)\n                {\n                    case SceneType.Content:\n                        SceneOperationProgress = 0;\n                        SceneOperationInProgress = false;\n                        break;\n                    case SceneType.Lighting:\n                        LightingOperationProgress = 0;\n                        LightingOperationInProgress = false;\n                        break;\n                    case SceneType.Manager:\n                        managerSceneOpProgress = 0;\n                        managerSceneOpInProgress = false;\n                        break;\n                    default:\n                        Debug.LogError(\"Unsupported scene type\");\n                        break;\n                }\n            }\n        }\n\n        \n        private bool CanSceneOpProceed(SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    return !SceneOperationInProgress;\n                case SceneType.Lighting:\n                    return !LightingOperationInProgress;\n                case SceneType.Manager:\n                    return !managerSceneOpInProgress;\n                default:\n                    Debug.LogError(\"Unsupported scene type\");\n                    return false;\n            }\n        }\n\n        #endregion\n    }\n}\n```"
            },
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "index": 1,
            "message": {
                "role": "assistant",
                "content": "                    scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded && scene.buildIndex == sceneIndex);\n                }\n\n                if (scenesLoadedAndActivated)\n                {\n                    SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                    InvokeContentReadyActions(validNames, sceneType);\n                }\n                else\n                {\n                    await Task.Yield();\n                }\n            }\n        }\n\n        \n        \n        \n        private async Task UnloadScenesInternal(IEnumerable<string> scenesToUnload, SceneType sceneType)\n        {\n            List<string> validNames = new List<string>();\n            List<int> validIndexes = new List<int>();\n            \n            foreach (string sceneName in scenesToUnload)\n            {\n                \n                Scene scene;\n                int sceneIndex;\n                if (!RuntimeSceneUtils.FindScene(sceneName, out scene, out sceneIndex))\n                {\n                    Debug.LogError(\"Can't unload invalid scene \" + sceneName);\n                }\n                else\n                {\n                    validIndexes.Add(sceneIndex);\n                    validNames.Add(sceneName);\n                }\n            }\n\n            if (validIndexes.Count < 1)\n            {\n                Debug.LogWarning(\"No valid scenes found to unload.\");\n                return;\n            }\n\n            InvokeWillUnloadActions(validNames, sceneType);\n\n            foreach (int sceneIndex in validIndexes)\n            {\n                AsyncOperation sceneOp = SceneManager.UnloadSceneAsync(sceneIndex);\n\n                while (!sceneOp.isDone)\n                {\n                    await Task.Yield();\n                }\n            }\n\n            InvokeUnloadedActions(validNames, sceneType);\n        }\n\n        \n        private void InvokeContentReadyActions(List<string> scenes, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnContentLoaded?.Invoke(scenes);\n                    break;\n                case SceneType.Lighting:\n                    OnLightingLoaded?.Invoke(scenes.First());\n                    break;\n                case SceneType.Manager:\n                default:\n                    break; \n            }\n        }\n\n        \n        private void SetSceneOpProgress(bool inProgress, float progress, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    SceneOperationInProgress = inProgress;\n                    SceneOperationProgress = progress;\n                    break;\n                case SceneType.Lighting:\n                    LightingOperationInProgress = inProgress;\n                    LightingOperationProgress = progress;\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        \n        private bool CanSceneOpProceed(SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    return !SceneOperationInProgress;\n                case SceneType.Lighting:\n                    return !LightingOperationInProgress;\n                default:\n                    return true;\n            }\n        }\n\n        \n        private bool GetLoadedContentScenes(out IEnumerable<string> loadedContentScenes)\n        {\n            loadedContentScenes = contentTracker.ContentSceneNames.Where(IsContentLoaded);\n            return loadedContentScenes.Any();\n        }\n\n        \n        private void InvokeWillLoadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnWillLoadContent?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnWillLoadLighting?.Invoke(sceneNames.First());\n                    break;\n                case SceneType.Manager:\n                default:\n                    break;\n            }\n        }\n\n        \n        private void InvokeWillUnloadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnWillUnloadContent?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnWillUnloadLighting?.Invoke(sceneNames.First());\n                    break;\n                case SceneType.Manager:\n                default:\n                    break;\n            }\n        }\n\n        \n        private void InvokeUnloadedActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnContentUnloaded?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnLightingUnloaded?.Invoke(sceneNames.First());\n                    break;\n                case SceneType.Manager:\n                default:\n                    break;\n            }\n        }\n    }\n}\n\"\"\""
            },
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "index": 2,
            "message": {
                "role": "assistant",
                "content": "sceneOperationProgress += 1;\nsceneOpProgress = Mathf.Clamp01(sceneOperationProgress / totalSceneOps);"
            },
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "index": 3,
            "message": {
                "role": "assistant",
                "content": "```csharp\n                    scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded && scene.isStageLoaderDone);\n```"
            },
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "index": 4,
            "message": {
                "role": "assistant",
                "content": "                    scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded && scene.isLoaded);\n\n                }\n\n                \n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n\n                \n                InvokeLoadedActions(validNames, sceneType);\n\n            }\n\n        }\n\n        \n        private async Task UnloadScenesInternal(IEnumerable<string> scenesToUnload, SceneType sceneType, float progressOffset = 0, float progressTarget = 1, bool sceneOpInProgressWhenFinished = false)\n        {\n            SetSceneOpProgress(true, progressOffset, sceneType);\n\n            \n            List<string> validNames = new List<string>();\n            List<int> validIndexes = new List<int>();\n\n            foreach (string sceneName in scenesToUnload)\n            {\n                \n                Scene scene;\n                int sceneIndex;\n                if (!RuntimeSceneUtils.FindScene(sceneName, out scene, out sceneIndex))\n                {\n                    Debug.LogError(\"Can't unload invalid scene \" + sceneName);\n                }\n                else\n                {\n                    validIndexes.Add(sceneIndex);\n                    validNames.Add(sceneName);\n                }\n            }\n\n            if (validIndexes.Count < 1)\n            {\n                Debug.LogWarning(\"No valid scenes found to unload.\");\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n            \n            InvokeWillUnloadActions(validNames, sceneType);\n\n            \n            if (validIndexes.Count > 0)\n            {\n                \n                List<AsyncOperation> unloadSceneOps = new List<AsyncOperation>();\n                foreach (int sceneIndex in validIndexes)\n                {\n                    Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                    AsyncOperation unloadedScene = SceneManager.UnloadSceneAsync(scene);\n                    unloadSceneOps.Add(unloadedScene);\n                }\n\n                \n                bool completedAllSceneOps = false;\n                while (!completedAllSceneOps)\n                {\n                    if (!Application.isPlaying)\n                    {   \n                        return;\n                    }\n\n                    completedAllSceneOps = true;\n                    foreach (AsyncOperation unloadSceneOp in unloadSceneOps)\n                    {\n                        completedAllSceneOps &= unloadSceneOp.isDone;\n                    }\n\n                    \n                    SetSceneOpProgress(true, progressTarget, sceneType);\n\n                    await Task.Yield();\n                }\n            }\n\n            \n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n\n            \n            InvokeUnloadedActions(validNames, sceneType);\n\n        }\n\n        \n        \n        \n        private void SetSceneOpProgress(bool inProgress, float progress, SceneType sceneType)\n        {\n            if (sceneType == SceneType.Content)\n            {\n                SceneOperationInProgress = inProgress;\n                SceneOperationProgress = progress;\n            }\n            else if (sceneType == SceneType.Lighting)\n            {   \n                LightingOperationInProgress = inProgress;\n                LightingOperationProgress = progress;\n            }\n        }\n\n        \n        \n        \n        private bool CanSceneOpProceed(SceneType sceneType)\n        {\n            if (sceneType == SceneType.Content)\n            {\n                return !SceneOperationInProgress && contentTracker.PrevContentExists && contentTracker.NextContentExists;\n            }\n            else if (sceneType == SceneType.Lighting)\n            {\n                return !LightingOperationInProgress;\n            }\n\n            return true;\n        }\n\n        \n        #endregion\n\n    }\n\n}\n\"\"\""
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 2781,
        "completion_tokens": 2809,
        "total_tokens": 5590
    },
    "system_fingerprint": "fp_e49e4201a9"
}