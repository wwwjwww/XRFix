{
    "code_repairing_0": "",
    "code_repairing_1": "```\n using Microsoft.MixedReality.Toolkit.Input;\nusing Microsoft.MixedReality.Toolkit.Utilities;\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\nusing UnityEngine;\nusing UnityEngine.Events;\nusing UnityEngine.Serialization;\nusing UnityPhysics = UnityEngine.Physics;\n\nnamespace Microsoft.MixedReality.Toolkit.UI\n{\n   \n    \n    \n   \n   \n    \n    [HelpURL(\"https:\n    public class BoundingBox : MonoBehaviour,\n        IMixedRealitySourceStateHandler,\n        IMixedRealityFocusChangedHandler,\n        IMixedRealityFocusHandler\n    {\n        #region Enums\n        \n        \n        \n        public enum FlattenModeType\n        {\n            DoNotFlatten = 0,\n            \n            \n            \n            FlattenX,\n            \n            \n            \n            FlattenY,\n            \n            \n            \n            FlattenZ,\n            \n            \n            \n            FlattenAuto,\n        }\n        \n        \n        \n        \n        public enum HandleType\n        {\n            None = 0,\n            Rotation,\n            Scale\n        }\n        \n        \n        \n        \n        private enum CardinalAxisType\n        {\n            X = 0,\n            Y,\n            Z\n        }\n        \n        \n        \n        public enum BoundsCalculationMethod\n        {\n            RendererOverCollider = 0,\n            \n            ColliderOverRenderer,\n            \n            ColliderOnly,\n            \n            RendererOnly,\n        }\n        \n        \n        \n        \n        public enum BoundingBoxActivationType\n        {\n            ActivateOnStart = 0,\n            ActivateByProximity,\n            ActivateByPointer,\n            ActivateByProximityAndPointer,\n            ActivateManually\n        }\n        \n        \n        \n        \n        private enum HandleProximityState\n        {\n            FullsizeNoProximity = 0,\n            MediumProximity,\n            CloseProximity\n        }\n        \n        \n        \n        public enum RotationHandlePrefabCollider\n        {\n            Sphere,\n            Box\n        }\n       \n       \n        private class Handle\n        {\n            public Transform HandleVisual;\n            public Renderer HandleVisualRenderer;\n            public HandleType Type = HandleType.None;\n            public HandleProximityState ProximityState = HandleProximityState.FullsizeNoProximity;\n        }\n\n        #endregion Enums\n\n        #region Serialized Fields and Properties\n        [SerializeField]\n        [Tooltip(\"The object that the bounding box rig will be modifying.\")]\n        private GameObject targetObject;\n        \n        \n        \n        public GameObject Target\n        {\n            get\n            {\n                if (targetObject == null)\n                {\n                    targetObject = gameObject;\n                }\n\n                return targetObject;\n            }\n        }\n\n        [Tooltip(\"For complex objects, automatic bounds calculation may not behave as expected. Use a box collider to manaully determine the bounds of Bounding Box.\")]\n        [SerializeField]\n        [FormerlySerializedAs(\"BoxColliderToUse\")]\n        private BoxCollider boundsOverride = null;\n\n       \n\n        \n        \n        public BoxCollider BoundsOverride\n        {\n            get { return boundsOverride; }\n            set\n            {\n                if (boundsOverride != value)\n                {\n                    boundsOverride = value;\n\n                    if (boundsOverride == null)\n                    {\n                        prevBoundsOverride = new Bounds();\n                    }\n                    CreateRig();\n                }\n            }\n        }\n        [SerializeField]\n        [Tooltip(\"Defines the volume type and the priority for the bounds calculation\")]\n        private BoundsCalculationMethod boundsCalculationMethod = BoundsCalculationMethod.RendererOverCollider;\n\n        \n        \n        \n        public BoundsCalculationMethod CalculationMethod\n        {\n            get { return boundsCalculationMethod; }\n            set\n            {\n                if (boundsCalculationMethod != value)\n                {\n                    boundsCalculationMethod = value;\n                    CreateRig();\n                }\n            }\n        }\n\n        [Header(\"Behavior\")]\n        [SerializeField]\n        [Tooltip(\"Type of activation method for showing/hiding bounding box handles and controls\")]\n        private BoundingBoxActivationType activation = BoundingBoxActivationType.ActivateOnStart;\n\n        \n        \n        \n        public BoundingBoxActivationType BoundingBoxActivation\n        {\n            get { return activation; }\n            set\n            {\n                if (activation != value)\n                {\n                    activation = value;\n                    ResetHandleVisibility();\n                }\n            }\n        }\n\n        [SerializeField]\n        [Obsolete(\"Use a TransformScaleHandler script rather than setting minimum on BoundingBox directly\", false)]\n        [Tooltip(\"Minimum scaling allowed relative to the initial size\")]\n        private float scaleMinimum = 0.2f;\n\n        [SerializeField]\n        [Obsolete(\"Use a TransformScaleHandler script rather than setting maximum on BoundingBox directly\", false)]\n        [Tooltip(\"Maximum scaling allowed relative to the initial size\")]\n        private float scaleMaximum = 2.0f;\n\n        \n        \n        \n\n        \n        \n        \n        \n        [Obsolete(\"Use a TransformScaleHandler.ScaleMinimum as it is the authoritative value for min scale\")]\n        public float ScaleMinimum\n        {\n            get\n            {\n                if (scaleHandler != null)\n                {\n                    return scaleHandler.ScaleMinimum;\n                }\n                return 0.0f;\n            }\n        }\n\n        \n        \n        \n\n        \n        \n        \n\n        \n        \n\n        \n        \n        \n        [Obsolete(\"Use a TransformScaleHandler.ScaleMaximum as it is the authoritative value for max scale\")]\n        public float ScaleMaximum\n        {\n            get\n            {\n                if (scaleHandler != null)\n                {\n                    return scaleHandler.ScaleMaximum;\n                }\n                return 0.0f;\n            }\n        }\n\n        [Header(\"Box Display\")]\n        [SerializeField]\n        [Tooltip(\"Flatten bounds in the specified axis or flatten the smallest one if 'auto' is selected\")]\n        private FlattenModeType flattenAxis = FlattenModeType.DoNotFlatten;\n\n        \n        \n        \n        public FlattenModeType FlattenAxis\n        {\n            get { return flattenAxis; }\n            set\n            {\n                if (flattenAxis != value)\n                {\n                    flattenAxis = value;\n                    CreateRig();\n                }\n            }\n        }\n\n        [SerializeField]\n        [Tooltip(\"When an axis is flattened what value to set that axis's scale to for display.\")]\n        private float flattenAxisDisplayScale = 0.0f;\n\n        \n        \n        \n        public float FlattenAxisDisplayScale\n        {\n            get { return flattenAxisDisplayScale; }\n            set\n            {\n                if (flattenAxisDisplayScale != value)\n                {\n                    flattenAxisDisplayScale = value;\n                    CreateRig();\n                }\n            }\n        }\n\n        [SerializeField]\n        [FormerlySerializedAs(\"wireframePadding\")]\n        [Tooltip(\"Extra padding added to the actual Target bounds\")]\n        private Vector3 boxPadding = Vector3.zero;\n\n        \n        \n        \n        public Vector3 BoxPadding\n        {\n            get { return boxPadding; }\n            set\n            {\n                if (Vector3.Distance(boxPadding, value) > float.Epsilon)\n                {\n                    boxPadding = value;\n                    CreateRig();\n                }\n            }\n        }\n\n        [SerializeField]\n        [Tooltip(\"Material used to display the bounding box. If set to null no bounding box will be displayed\")]\n        private Material boxMaterial = null;\n\n        \n        \n        \n        public Material BoxMaterial\n        {\n            get { return boxMaterial; }\n            set\n            {\n                if (boxMaterial != value)\n                {\n                    boxMaterial = value;\n                    CreateRig();\n                }\n            }\n        }\n\n        [SerializeField]\n        [Tooltip(\"Material used to display the bounding box when grabbed. If set to null no Change will occur when grabbed.\")]\n        private Material boxG",
    "code_repairing_2": "FIXED CODE:\n\ufeff\n\nusing Microsoft.MixedReality.Toolkit.Input;\nusing Microsoft.MixedReality.Toolkit.Utilities;\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\nusing UnityEngine;\nusing UnityEngine.Events;\nusing UnityEngine.Serialization;\nusing UnityPhysics = UnityEngine.Physics;\n\nnamespace Microsoft.MixedReality.Toolkit.UI\n{\n    \n    \n    \n    \n    \n    \n    [HelpURL(\"https:\n    public class BoundingBox : MonoBehaviour,\n        IMixedRealitySourceStateHandler,\n        IMixedRealityFocusChangedHandler,\n        IMixedRealityFocusHandler\n    {\n        #region Enums\n\n        \n        \n        \n        public enum FlattenModeType\n        {\n            DoNotFlatten = 0,\n            \n            \n            \n            FlattenX,\n            \n            \n            \n            FlattenY,\n            \n            \n            \n            FlattenZ,\n            \n            \n            \n            FlattenAuto,\n        }\n\n        \n        \n        \n        \n        public enum HandleType\n        {\n            None = 0,\n            Rotation,\n            Scale\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        public enum WireframeType\n        {\n            Cubic = 0,\n            Cylindrical\n        }\n\n        \n        \n        \n        private enum CardinalAxisType\n        {\n            X = 0,\n            Y,\n            Z\n        }\n\n        \n        \n        \n        \n        public enum BoundsCalculationMethod\n        {\n            \n            \n            \n            RendererOverCollider = 0,\n            \n            \n            \n            ColliderOverRenderer,\n            \n            \n            \n            ColliderOnly,\n            \n            \n            \n            RendererOnly,\n        }\n\n        \n        \n        \n        public enum BoundingBoxActivationType\n        {\n            ActivateOnStart = 0,\n            ActivateByProximity,\n            ActivateByPointer,\n            ActivateByProximityAndPointer,\n            ActivateManually\n        }\n\n        \n        \n        \n        private enum HandleProximityState\n        {\n            FullsizeNoProximity = 0,\n            MediumProximity,\n            CloseProximity\n        }\n\n        \n        \n        \n        public enum RotationHandlePrefabCollider\n        {\n            Sphere,\n            Box\n        }\n\n        \n        \n        \n        private class Handle\n        {\n            public Transform HandleVisual;\n            public Renderer HandleVisualRenderer;\n            public HandleType Type = HandleType.None;\n            public HandleProximityState ProximityState = HandleProximityState.FullsizeNoProximity;\n        }\n\n        #endregion Enums\n\n        #region Serialized Fields and Properties\n        [SerializeField]\n        [Tooltip(\"The object that the bounding box rig will be modifying.\")]\n        private GameObject targetObject;\n        \n        \n        \n        public GameObject Target\n        {\n            get\n            {\n                if (targetObject == null)\n                {\n                    targetObject = gameObject;\n                }\n\n                return targetObject;\n            }\n        }\n\n        [Tooltip(\"For complex objects, automatic bounds calculation may not behave as expected. Use an existing Box Collider (even on a child object) to manually determine bounds of Bounding Box.\")]\n        [SerializeField]\n        [FormerlySerializedAs(\"BoxColliderToUse\")]\n        private BoxCollider boundsOverride = null;\n\n        \n        \n        \n        public BoxCollider BoundsOverride\n        {\n            get { return boundsOverride; }\n            set\n            {\n                if (boundsOverride != value)\n                {\n                    boundsOverride = value;\n\n                    if (boundsOverride == null)\n                    {\n                        prevBoundsOverride = new Bounds();\n                    }\n                    CreateRig();\n                }\n            }\n        }\n\n        [SerializeField]\n        [Tooltip(\"Defines the volume type and the priority for the bounds calculation\")]\n        private BoundsCalculationMethod boundsCalculationMethod = BoundsCalculationMethod.RendererOverCollider;\n\n        \n        \n        \n        public BoundsCalculationMethod CalculationMethod\n        {\n            get { return boundsCalculationMethod; }\n            set\n            {\n                if (boundsCalculationMethod != value)\n                {\n                    boundsCalculationMethod = value;\n                    CreateRig();\n                }\n            }\n        }\n\n        [Header(\"Behavior\")]\n        [SerializeField]\n        [Tooltip(\"Type of activation method for showing/hiding bounding box handles and controls\")]\n        private BoundingBoxActivationType activation = BoundingBoxActivationType.ActivateOnStart;\n\n        \n        \n        \n        public BoundingBoxActivationType BoundingBoxActivation\n        {\n            get { return activation; }\n            set\n            {\n                if (activation != value)\n                {\n                    activation = value;\n                    ResetHandleVisibility();\n                }\n            }\n        }\n\n        [SerializeField]\n        [Obsolete(\"Use a TransformScaleHandler script rather than setting minimum on BoundingBox directly\", false)]\n        [Tooltip(\"Minimum scaling allowed relative to the initial size\")]\n        private float scaleMinimum = 0.2f;\n\n        [SerializeField]\n        [Obsolete(\"Use a TransformScaleHandler script rather than setting maximum on BoundingBox directly\")]\n        [Tooltip(\"Maximum scaling allowed relative to the initial size\")]\n        private float scaleMaximum = 2.0f;\n\n\n        \n        \n        \n        \n        \n        [Obsolete(\"Use a TransformScaleHandler.ScaleMinimum as it is the authoritative value for min scale\")]\n        public float ScaleMinimum\n        {\n            get\n            {\n                if (scaleHandler != null)\n                {\n                    return scaleHandler.ScaleMinimum;\n                }\n                return 0.0f;\n            }\n        }\n\n        \n        \n        \n        \n        \n        [Obsolete(\"Use a TransformScaleHandler.ScaleMinimum as it is the authoritative value for max scale\")]\n        public float ScaleMaximum\n        {\n            get\n            {\n                if (scaleHandler != null)\n                {\n                    return scaleHandler.ScaleMaximum;\n                }\n                return 0.0f;\n            }\n        }\n\n        [Header(\"Box Display\")]\n        [SerializeField]\n        [Tooltip(\"Flatten bounds in the specified axis or flatten the smallest one if 'auto' is selected\")]\n        private FlattenModeType flattenAxis = FlattenModeType.DoNotFlatten;\n\n        \n        \n        \n        public FlattenModeType FlattenAxis\n        {\n            get { return flattenAxis; }\n            set\n            {\n                if (flattenAxis != value)\n                {\n                    flattenAxis = value;\n                    CreateRig();\n                }\n            }\n        }\n\n        [SerializeField]\n        [Tooltip(\"When an axis is flattened what value to set that axis's scale to for display.\")]\n        private float flattenAxisDisplayScale = 0.0f;\n\n        \n        \n        \n        public float FlattenAxisDisplayScale\n        {\n            get { return flattenAxisDisplayScale; }\n            set\n            {\n                if (flattenAxisDisplayScale != value)\n                {\n                    flattenAxisDisplayScale = value;\n                    CreateRig();\n                }\n            }\n        }\n\n        [SerializeField]\n        [FormerlySerializedAs(\"wireframePadding\")]\n        [Tooltip(\"Extra padding added to the actual Target bounds\")]\n        private Vector3 boxPadding = Vector3.zero;\n\n        \n        \n        \n        public Vector3 BoxPadding\n        {\n            get { return boxPadding; }\n            set\n            {\n                if (Vector3.Distance(boxPadding, value) > float.Epsilon)\n                {\n                    boxPadding = value;\n                    CreateRig();\n                }\n            }\n        }\n\n        [SerializeField]\n        [Tooltip(\"Material used to display the bounding box. If set to null no bounding box will be displayed\")]\n        private Material boxMaterial = null;\n\n        \n        \n        \n        public Material BoxMaterial\n        {\n            get { return boxMaterial; }\n            set\n            {\n                if (boxMaterial != value)\n                {\n                    boxMaterial = value;",
    "code_repairing_3": "private readonly Dictionary<IMixedRealityInputSource, HandleProximityState> touchingSources = new Dictionary<IMixedRealityInputSource, HandleProximityState>();\n\n        private readonly Dictionary<IMixedRealityInputSource, Transform> sourceHandles = new Dictionary<IMixedRealityInputSource, Transform>();\n\n        private readonly Dictionary<IMixedRealityInputSource, Quaternion> sourceRots = new Dictionary<IMixedRealityInputSource, Quaternion>();\n        \n        \n        \n        private BoxCollider boundsOverride = null;\n\n        private ReadOnlyCollection<IMixedRealityInputSource> touchingSourcesReadOnly;\n        private ReadOnlyCollection<Transform> sourceHandlesReadOnly;\n\n        private Transform[] corners = new Transform[8];\n\n        private GameObject rotationHandlePrefab = null;\n\n        private Dictionary<IMixedRealityInputSource, GameObject> sourceRotationHandles;\n\n        private readonly Dictionary<IMixedRealityInputSource, HandleProximityState> touchingSources = new Dictionary<IMixedRealityInputSource, HandleProximityState>();\n\n        private readonly Dictionary<IMixedRealityInputSource, Transform> sourceHandles = new Dictionary<IMixedRealityInputSource, Transform>();\n\n        private readonly Dictionary<IMixedRealityInputSource, Quaternion> sourceRots = new Dictionary<IMixedRealityInputSource, Quaternion>();\n\n        private BoxCollider boundsOverride = null;\n\n        private ReadOnlyCollection<IMixedRealityInputSource> touchingSourcesReadOnly;\n        private ReadOnlyCollection<Transform> sourceHandlesReadOnly;\n\n        private Transform[] corners = new Transform[8];\n\n        private GameObject rotationHandlePrefab = null;\n\n        private Dictionary<IMixedRealityInputSource, GameObject> sourceRotationHandles;\n\n        private readonly Dictionary<IMixedRealityInputSource, HandleProximityState> touchingSources = new Dictionary<IMixedRealityInputSource, HandleProximityState>();\n\n        private readonly Dictionary<IMixedRealityInputSource, Transform> sourceHandles = new Dictionary<IMixedRealityInputSource, Transform>();\n\n        private readonly Dictionary<IMixedRealityInputSource, Quaternion> sourceRots = new Dictionary<IMixedRealityInputSource, Quaternion>();\n\n        // FIXED CODE:\n        #endregion Private Fields\n\n        #region IMixedRealitySourceStateHandler Implementation\n        void IMixedRealitySourceStateHandler.OnSourceDetected(SourceStateEventData eventData)\n        {\n            \n        }\n\n        \n        \n        \n        \n        \n        void IMixedRealitySourceStateHandler.OnSourceLost(SourceStateEventData eventData)\n        {\n            \n        }\n\n        \n        \n        \n        \n        \n        void IMixedRealitySourceStateHandler.OnSourceTracking(SourceStateEventData eventData)\n        {\n            \n        }\n\n        \n        \n        \n        \n        \n        void IMixedRealitySourceStateHandler.OnSourceNotTracking(SourceStateEventData eventData)\n        {\n            \n        }\n\n        \n        \n        \n        \n        \n        void IMixedRealitySourceStateHandler.OnSourcePoseChanged(SourcePoseEventData<TrackingState> eventData)\n        {\n            // if (IsActive())\n            // {\n            //     CheckForProximity(eventData.SourceId, eventData.InputSource);\n            // }\n        }\n        #endregion IMixedRealitySourceStateHandler Implementation\n\n        #region IMixedRealityFocusChangedHandler Implementation\n        void IMixedRealityFocusChangedHandler.OnBeforeFocusChanged(FocusEventData eventData)\n        {\n            \n        }\n\n        \n        \n        \n        \n        \n        void IMixedRealityFocusChangedHandler.OnFocusChanged(FocusEventData eventData)\n        {\n            \n        }\n\n        \n        \n        \n        \n        \n        void IMixedRealityFocusChangedHandler.OnBeforeFocusLost(FocusEventData eventData)\n        {\n            \n        }\n\n        \n        \n        \n        \n        \n        void IMixedRealityFocusChangedHandler.OnFocusLost(FocusEventData eventData)\n        {\n            \n        }\n        #endregion IMixedRealityFocusChangedHandler Implementation\n\n        #region IMixedRealitySourcePoseHandler Implementation\n        void IMixedRealitySourcePoseHandler.OnSourcePoseChanged(SourcePoseEventData eventData)\n        {\n            \n        }\n        #endregion IMixedRealitySourcePoseHandler Implementation\n\n        #region IMixedRealityPointerHandler Implementation\n        void IMixedRealityPointerHandler.OnPointerDown(MixedRealityPointerEventData eventData)\n        {\n            \n        }\n\n        \n        \n        \n        \n        \n        void IMixedRealityPointerHandler.OnPointerDragged(MixedRealityPointerEventData eventData)\n        {\n            \n        }\n\n        \n        \n        \n        \n        \n        void IMixedRealityPointerHandler.OnPointerUp(MixedRealityPointerEventData eventData)\n        {\n            \n        }\n        #endregion IMixedRealityPointerHandler Implementation\n\n        #region IMixedRealityHandler Implementation\n        void IMixedRealityHandler.OnBeforeSceneQuery(Transform sceneRoot)\n        {\n            \n        }\n\n        \n        \n        \n        \n        \n        void IMixedRealityHandler.OnAfterSceneQuery(Transform sceneRoot, ICollection<Transform> results)\n        {\n            \n        }\n        #endregion IMixedRealityHandler Implementation\n\n\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n        \n        #region StartUp and CleanUp\n\ufeff\n\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\n\ufeffprivate void OnEnable()\n{\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n}\n\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n/*\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n<?private void OnDisable()\n{\n{%\n\ufeff\n\ufeff\n\ufeff\n\ufeff\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\u00ab\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\u00ad\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\u200b\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff\n\ufeff",
    "code_repairing_4": "Fixed Code:\n\n\ufeffusing Microsoft.MixedReality.Toolkit.Input;\nusing Microsoft.MixedReality.Toolkit.Utilities;\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\nusing UnityEngine;\nusing UnityEngine.Events;\nusing UnityEngine.Serialization;\nusing UnityPhysics = UnityEngine.Physics;\n\nnamespace Microsoft.MixedReality.Toolkit.UI\n{\n    \n    \n    \n    \n    \n    \n    [HelpURL(\"https:\n    public class BoundingBox : MonoBehaviour,\n        IMixedRealitySourceStateHandler,\n        IMixedRealityFocusChangedHandler,\n        IMixedRealityFocusHandler\n    {\n        #region Enums\n\n        \n        \n        \n        public enum FlattenModeType\n        {\n            DoNotFlatten = 0,\n            \n            \n            \n            FlattenX,\n            \n            \n            \n            FlattenY,\n            \n            \n            \n            FlattenZ,\n            \n            \n            \n            FlattenAuto,\n        }\n\n        \n        \n        \n        \n        public enum HandleType\n        {\n            None = 0,\n            Rotation,\n            Scale\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        public enum WireframeType\n        {\n            Cubic = 0,\n            Cylindrical\n        }\n\n        \n        \n        \n        private enum CardinalAxisType\n        {\n            X = 0,\n            Y,\n            Z\n        }\n\n        \n        \n        \n        \n        public enum BoundsCalculationMethod\n        {\n            \n            \n            \n            RendererOverCollider = 0,\n            \n            \n            \n            ColliderOverRenderer,\n            \n            \n            \n            ColliderOnly,\n            \n            \n            \n            RendererOnly,\n        }\n\n        \n        \n        \n        public enum BoundingBoxActivationType\n        {\n            ActivateOnStart = 0,\n            ActivateByProximity,\n            ActivateByPointer,\n            ActivateByProximityAndPointer,\n            ActivateManually\n        }\n\n        \n        \n        \n        private enum HandleProximityState\n        {\n            FullsizeNoProximity = 0,\n            MediumProximity,\n            CloseProximity\n        }\n\n        \n        \n        \n        public enum RotationHandlePrefabCollider\n        {\n            Sphere,\n            Box\n        }\n\n        \n        \n        \n        private class Handle\n        {\n            public Transform HandleVisual;\n            public Renderer HandleVisualRenderer;\n            public HandleType Type = HandleType.None;\n            public HandleProximityState ProximityState = HandleProximityState.FullsizeNoProximity;\n        }\n\n        #endregion Enums\n\n        #region Serialized Fields and Properties\n        [SerializeField]\n        [Tooltip(\"The object that the bounding box rig will be modifying.\")]\n        private GameObject targetObject;\n        \n        \n        \n        public GameObject Target\n        {\n            get\n            {\n                if (targetObject == null)\n                {\n                    targetObject = gameObject;\n                }\n\n                return targetObject;\n            }\n        }\n\n        [Tooltip(\"For complex objects, automatic bounds calculation may not behave as expected. Use an existing Box Collider (even on a child object) to manually determine bounds of Bounding Box.\")]\n        [SerializeField]\n        [FormerlySerializedAs(\"BoxColliderToUse\")]\n        private BoxCollider boundsOverride = null;\n\n        \n        \n        \n        public BoxCollider BoundsOverride\n        {\n            get { return boundsOverride; }\n            set\n            {\n                if (boundsOverride != value)\n                {\n                    boundsOverride = value;\n\n                    if (boundsOverride == null)\n                    {\n                        prevBoundsOverride = new Bounds();\n                    }\n                    CreateRig();\n                }\n            }\n        }\n\n        [SerializeField]\n        [Tooltip(\"Defines the volume type and the priority for the bounds calculation\")]\n        private BoundsCalculationMethod boundsCalculationMethod = BoundsCalculationMethod.RendererOverCollider;\n\n        \n        \n        \n        public BoundsCalculationMethod CalculationMethod\n        {\n            get { return boundsCalculationMethod; }\n            set\n            {\n                if (boundsCalculationMethod != value)\n                {\n                    boundsCalculationMethod = value;\n                    CreateRig();\n                }\n            }\n        }\n\n        [Header(\"Behavior\")]\n        [SerializeField]\n        [Tooltip(\"Type of activation method for showing/hiding bounding box handles and controls\")]\n        private BoundingBoxActivationType activation = BoundingBoxActivationType.ActivateOnStart;\n\n        \n        \n        \n        public BoundingBoxActivationType BoundingBoxActivation\n        {\n            get { return activation; }\n            set\n            {\n                if (activation != value)\n                {\n                    activation = value;\n                    ResetHandleVisibility();\n                }\n            }\n        }\n\n        [SerializeField]\n        [Obsolete(\"Use a TransformScaleHandler script rather than setting minimum on BoundingBox directly\", false)]\n        [Tooltip(\"Minimum scaling allowed relative to the initial size\")]\n        private float scaleMinimum = 0.2f;\n\n        [SerializeField]\n        [Obsolete(\"Use a TransformScaleHandler script rather than setting maximum on BoundingBox directly\")]\n        [Tooltip(\"Maximum scaling allowed relative to the initial size\")]\n        private float scaleMaximum = 2.0f;\n\n\n        \n        \n        \n        \n        \n        [Obsolete(\"Use a TransformScaleHandler.ScaleMinimum as it is the authoritative value for min scale\")]\n        public float ScaleMinimum\n        {\n            get\n            {\n                if (scaleHandler != null)\n                {\n                    return scaleHandler.ScaleMinimum;\n                }\n                return 0.0f;\n            }\n        }\n\n        \n        \n        \n        \n        \n        [Obsolete(\"Use a TransformScaleHandler.ScaleMinimum as it is the authoritative value for max scale\")]\n        public float ScaleMaximum\n        {\n            get\n            {\n                if (scaleHandler != null)\n                {\n                    return scaleHandler.ScaleMaximum;\n                }\n                return 0.0f;\n            }\n        }\n\n        [Header(\"Box Display\")]\n        [SerializeField]\n        [Tooltip(\"Flatten bounds in the specified axis or flatten the smallest one if 'auto' is selected\")]\n        private FlattenModeType flattenAxis = FlattenModeType.DoNotFlatten;\n\n        \n        \n        \n        public FlattenModeType FlattenAxis\n        {\n            get { return flattenAxis; }\n            set\n            {\n                if (flattenAxis != value)\n                {\n                    flattenAxis = value;\n                    CreateRig();\n                }\n            }\n        }\n\n        [SerializeField]\n        [Tooltip(\"When an axis is flattened what value to set that axis's scale to for display.\")]\n        private float flattenAxisDisplayScale = 0.0f;\n\n        \n        \n        \n        public float FlattenAxisDisplayScale\n        {\n            get { return flattenAxisDisplayScale; }\n            set\n            {\n                if (flattenAxisDisplayScale != value)\n                {\n                    flattenAxisDisplayScale = value;\n                    CreateRig();\n                }\n            }\n        }\n\n        [SerializeField]\n        [FormerlySerializedAs(\"wireframePadding\")]\n        [Tooltip(\"Extra padding added to the actual Target bounds\")]\n        private Vector3 boxPadding = Vector3.zero;\n\n        \n        \n        \n        public Vector3 BoxPadding\n        {\n            get { return boxPadding; }\n            set\n            {\n                if (Vector3.Distance(boxPadding, value) > float.Epsilon)\n                {\n                    boxPadding = value;\n                    CreateRig();\n                }\n            }\n        }\n\n        [SerializeField]\n        [Tooltip(\"Material used to display the bounding box. If set to null no bounding box will be displayed\")]\n        private Material boxMaterial = null;\n\n        \n        \n        \n        public Material BoxMaterial\n        {\n            get { return boxMaterial; }\n            set\n            {\n                if (boxMaterial != value)\n                {\n                    boxMaterial = value;\n                    CreateRig"
}