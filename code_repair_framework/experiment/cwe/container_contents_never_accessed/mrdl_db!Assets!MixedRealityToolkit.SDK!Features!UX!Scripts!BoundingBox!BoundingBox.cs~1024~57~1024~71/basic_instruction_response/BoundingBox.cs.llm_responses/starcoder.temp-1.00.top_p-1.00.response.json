{
    "code_repairing_0": "```using System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\nusing Microsoft.MixedReality.Toolkit.Input;\nusing Microsoft.MixedReality.Toolkit.Utilities;\n\nnamespace Microsoft.MixedReality.Toolkit.Physics.UnityPhysics\n{\n    public class BoundingBox : MonoBehaviour\n    {\n        [SerializeField]\n        private BoxCollider boxCollider = null;\n\n        private event Action<Collider> OnCollisionEnter = delegate { };\n        private event Action<Collider> OnCollisionExit = delegate { };\n\n        private void OnEnable()\n        {\n            boxCollider.enabled = true;\n            OnCollisionEnter += HandleOnCollisionEnter;\n            OnCollisionExit += HandleOnCollisionExit;\n        }\n\n        private void OnDisable()\n        {\n            boxCollider.enabled = false;\n            OnCollisionEnter -= HandleOnCollisionEnter;\n            OnCollisionExit -= HandleOnCollisionExit;\n        }\n\n        private void HandleOnCollisionEnter(Collider other)\n        {\n            RaiseBoundaryEvent(other, CollisionEventType.Entered);\n        }\n\n        private void HandleOnCollisionExit(Collider other)\n        {\n            RaiseBoundaryEvent(other, CollisionEventType.Exited);\n        }\n\n        private void RaiseBoundaryEvent(Collider other, CollisionEventType eventType)\n        {\n            IMixedRealityInputSource inputSource = other.GetComponentInParent<IMixedRealityInputSource>();\n            if (inputSource!= null)\n            {\n                BoundaryEventData boundaryEventData = new BoundaryEventData(inputSource, eventType);\n                UnityEventBase unityEvent = eventType == CollisionEventType.Entered? OnCollisionEnter : OnCollisionExit;\n                unityEvent.Invoke(other);\n            }\n        }\n    }\n}\n```",
    "code_repairing_1": "using Microsoft.MixedReality.Toolkit.Input;\nusing Microsoft.MixedReality.Toolkit.Utilities;\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\nusing UnityEngine.Serialization;\n\npublic class BoundingBox : MonoBehaviour\n{\n    // Container to track sources that are currently touching the object\n    private readonly List<IMixedRealityInputSource> touchingSources = new List<IMixedRealityInputSource>();\n\n    #region MonoBehaviour Methods\n\n    private void OnEnable()\n    {\n        // Register for touch events\n        InputSystem?.InputSystemProfile?.InputActions?.TouchPositionAction?.started += OnTouchStarted;\n        InputSystem?.InputSystemProfile?.InputActions?.TouchPositionAction?.performed += OnTouchUpdated;\n        InputSystem?.InputSystemProfile?.InputActions?.TouchPositionAction?.canceled += OnTouchEnded;\n    }\n\n    private void OnDisable()\n    {\n        // Unregister for touch events\n        InputSystem?.InputSystemProfile?.InputActions?.TouchPositionAction?.started -= OnTouchStarted;\n        InputSystem?.InputSystemProfile?.InputActions?.TouchPositionAction?.performed -= OnTouchUpdated;\n        InputSystem?.InputSystemProfile?.InputActions?.TouchPositionAction?.canceled -= OnTouchEnded;\n    }\n\n    #endregion MonoBehaviour Methods\n\n    #region Event Handlers\n\n    private void OnTouchStarted(InputAction.CallbackContext context)\n    {\n        // Add touched source to list\n        if (context.performed)\n        {\n            var pointer = context.action.ReadValue<MixedRealityPose>();\n            var inputSource = pointer.Source as IMixedRealityInputSource;\n            if (!touchingSources",
    "code_repairing_2": "using System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.XR.ARFoundation;\nusing UnityEngine.XR.ARSubsystems;\n\nnamespace Microsoft.MixedReality.Toolkit.Input\n{\n    public class BoundingBox : MonoBehaviour\n    {\n        [SerializeField]\n        private BoxCollider boxCollider = null;\n\n        [SerializeField]\n        [Range(0.1f, 10f)]\n        private float radius = 1f;\n\n        private ARTrackedObjectManager trackedObjectManager;\n        private List<ARTrackable> trackedObjects = new List<ARTrackable>();\n        private List<XRHumanBody> detectedHumanBodies = new List<XRHumanBody>();\n\n        private void Awake()\n        {\n            trackedObjectManager = FindObjectOfType<ARTrackedObjectManager>();\n            if (trackedObjectManager == null)\n            {\n                throw new ArgumentNullException(\"trackedObjectManager\");\n            }\n        }\n\n        private void Update()\n        {\n            trackedObjectManager.GetTrackedObjects(trackedObjects);\n            detectedHumanBodies.Clear();\n            foreach (var trackedObject in trackedObjects)\n            {\n                if (trackedObject is ARHumanBody)\n                {\n                    detectedHumanBodies.Add(trackedObject as XRHumanBody);\n                }\n            }\n\n            UpdateBoxCollider();\n        }\n\n        private void UpdateBoxCollider()\n        {\n            if (detectedHumanBodies.Count == 0)\n            {\n                return;\n            }\n\n            // Reset collider\n            boxCollider.center = Vector3.zero;\n            boxCollider.size = Vector3.zero;\n\n            // Calculate center of all detected human bodies\n            Vector3 center = Vector3.zero;\n            foreach (var",
    "code_repairing_3": "```csharp\nusing Microsoft.MixedReality.Toolkit.Input;\nusing Microsoft.MixedReality.Toolkit.Utilities;\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\nusing UnityEngine;\nusing UnityEngine.Events;\nusing UnityEngine.Serialization;\nusing UnityPhysics = UnityEngine.Physics;\n\npublic class BoundingBox : MonoBehaviour\n{\n    #region MonoBehaviour Methods\n    #endregion MonoBehaviour Methods\n\n    private static readonly List<IMixedRealityInputSource> _touchingSources = new List<IMixedRealityInputSource>();\n\n    private void Update()\n    {\n        // 1. Filter sources based on touching interactions\n        foreach (var inputSource in CoreServices.InputSystem.DetectedInputSources)\n        {\n            if (inputSource.TryGetFeatureValue(CommonUsages.isTouchingHandHoldable, out bool isTouching)\n                && isTouching)\n            {\n                _touchingSources.Add(inputSource);\n            }\n        }\n\n        // 2. Query sources for position and orientation data\n        if (_touchingSources.Count > 0)\n        {\n            // Get position and orientation for all touching sources\n            Vector3 centerPosition = Vector3.zero;\n            Quaternion centerOrientation = Quaternion.identity;\n            foreach (var inputSource in _touchingSources)\n            {\n                if (inputSource.TryGetPosition(out Vector3 inputSourcePosition))\n                {\n                    if (inputSource.TryGetRotation(out Quaternion inputSourceOrientation))\n                    {\n                        centerPosition += inputSourcePosition;\n                        centerOrientation *= inputSourceOrientation;\n                    }\n                }\n            }\n\n            // Set bounding box position and rotation based",
    "code_repairing_4": "It was the last night on Earth. The sun was about to set and the sky was painted in shades of orange, pink, and purple. People were out in the streets, celebrating the end of the world and each other's company.\n\nI was walking through the city, taking in the sights and sounds of the final hours. I felt a sense of sadness and wonder, knowing that everything I had known was about to end.\n\nAs I made my way to the park, I saw a group of people gathered around a fire. They were dancing and singing, celebrating their final hours together. I joined them, feeling a sense of camaraderie and connection.\n\nThe sky turned from purple to black, signaling the end of the world. The sun disappeared below the horizon, plunging the world into darkness.\n\nBut instead of fear, I felt a sense of peace. This was it. The end"
}