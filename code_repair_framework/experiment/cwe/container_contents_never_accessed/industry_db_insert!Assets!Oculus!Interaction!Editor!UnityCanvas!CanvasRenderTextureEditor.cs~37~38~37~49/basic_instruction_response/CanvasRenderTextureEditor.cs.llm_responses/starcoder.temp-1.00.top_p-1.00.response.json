{
    "code_repairing_0": "using System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\n\nnamespace Oculus.Interaction.UnityCanvas.Editor\n{\n    [CustomEditor(typeof(CanvasRenderTexture))]\n    public class CanvasRenderTextureEditor : EditorBase\n    {\n        private static List<CanvasRenderer> _tmpRenderers = new List<CanvasRenderer>();\n        private static List<Graphic> _tmpGraphics = new List<Graphic>();\n\n        public override void OnInspectorGUI()\n        {\n            base.OnInspectorGUI();\n\n            EditorGUILayout.Space();\n\n            serializedObject.Update();\n\n            RenderTexturesGroupGUI();\n\n            serializedObject.ApplyModifiedProperties();\n        }\n\n        private void RenderTexturesGroupGUI()\n        {\n            EditorGUILayout.LabelField(\"Render Textures\", EditorStyles.boldLabel);\n\n            SerializedProperty renderTextureListProp =\n                serializedObject.GetIterator().Next(true).Next(true);\n\n            EditorGUILayout.PropertyField(renderTextureListProp, true);\n\n            EditorGUILayout.Space();\n\n            EditorGUILayout.LabelField(\"Texture Groups\", EditorStyles.boldLabel);\n\n            SerializedProperty textureGroupsProp =\n                serializedObject.GetIterator().Next(true).Next(true);\n\n            EditorGUILayout.PropertyField(textureGroupsProp, true);\n\n            EditorGUILayout.Space();\n\n            EditorGUILayout.LabelField(\"Graphic List\", EditorStyles.boldLabel);\n\n            RenderGraphicsList();\n        }\n\n        private void RenderGraphicsList()\n        {\n            SerializedProperty graphicListProp =\n                serializedObject.GetIterator().Next(true).Next(true).Next(true);\n\n            EditorGUILayout.PropertyField(graphicListProp, true);\n        }\n    }\n}\n\nYou can't call a non-static member from a static context. You can't modify static fields from a static context, either, or use a static field as the initial value of a local variable. That means you can't have a static List field like `_tmpGraphics` and add items to it from an instance method like RenderTexturesGroupGUI().\n\nYou probably need a non-static List field, so you can access it from both instance and static methods. Try this:\n\n```csharp\nprivate static List<Graphic> _tmpGraphics = new List<Graphic>();\n```\n\nand modify RenderTexturesGroupGUI to look like:\n\n```csharp\n        private void RenderTexturesGroupGUI()\n        {\n            EditorGUILayout.LabelField(\"Render Textures\", EditorStyles.boldLabel);\n\n            SerializedProperty renderTextureListProp =\n                serializedObject.GetIterator().Next(true).Next(true);\n\n            EditorGUILayout.PropertyField(renderTextureListProp, true);\n\n            EditorGUILayout.Space();\n\n            EditorGUILayout.LabelField(\"Texture Groups\", EditorStyles.boldLabel);\n\n            SerializedProperty textureGroupsProp =\n                serializedObject.GetIterator().Next(true).Next(true);\n\n            EditorGUILayout.PropertyField(textureGroupsProp, true);\n\n            EditorGUILayout.Space();\n\n            EditorGUILayout.LabelField(\"Graphic List\", EditorStyles.boldLabel);\n\n            RenderGraphicsList();\n        }\n\n        private void RenderGraphicsList()\n        {\n            _tmpGraphics.Clear();\n            SerializedProperty graphicListProp =\n                serializedObject.GetIterator().Next(true).Next(true).Next(true);\n            graphicListProp.GetObjectArrayElements(_tmpGraphics);\n\n            EditorGUILayout.BeginVertical();\n            foreach (var graphic in _tmpGraphics)\n            {\n                EditorGUILayout.ObjectField(graphic, typeof(Graphic), true);\n            }\n            EditorGUILayout.EndVertical();\n        }\n```",
    "code_repairing_1": "public static string ReverseString(int[] arr)\n    {\n        Array.Sort(arr);\n        Stack<int> stack = new Stack<int>();\n\n        for (int i = 0; i < arr.Length; i++)\n        {\n            if (stack.Count == 0 || stack.Peek()!= arr[",
    "code_repairing_2": "```csharp\nusing System.Linq;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEditor;\n\nusing props = Oculus.Interaction.UnityCanvas.CanvasRenderTexture.Properties;\n\nnamespace Oculus.Interaction.UnityCanvas.Editor\n{\n    [CustomEditor(typeof(CanvasRenderTexture))]\n    public class CanvasRenderTextureEditor : EditorBase\n    {\n        private static List<CanvasRenderer> _tmpRenderers = new List<CanvasRenderer>();\n        \n        private void OnEnable()\n        {\n            if (!EditorApplication.isPlaying &&!EditorApplication.isPlayingOrWillChangePlaymode)\n            {\n                RefreshReceivers();\n            }\n        }\n\n        private void OnDisable()\n        {\n            if (!EditorApplication.isPlaying &&!EditorApplication.isPlayingOrWillChangePlaymode)\n            {\n                DisposeReceivers();\n            }\n        }\n        \n        private void RefreshReceivers()\n        {\n            _tmpRenderers.Clear();\n            _tmpRenderers.AddRange(target.GetComponentsInChildren<CanvasRenderer>(true));\n        }\n\n        private void DisposeReceivers()\n        {\n            foreach (var r in _tmpRenderers)\n            {\n                UnityEngine.Object.DestroyImmediate(r);\n            }\n\n            _tmpRenderers.Clear();\n        }\n        \n        public override void OnInspectorGUI()\n        {\n            base.OnInspectorGUI();\n\n            if (!Application.isPlaying && GUILayout.Button(\"Apply Modifications\"))\n            {\n                RefreshReceivers();\n                serializedObject.Update();\n\n                ApplyTargeting();\n                ApplyClipping();\n                ApplySortingOrder();\n                ApplyAnchor();\n\n                serializedObject.ApplyModifiedProperties();\n                DisposeReceivers();\n            }\n        }\n        \n        private void ApplyTargeting()\n        {\n            var receivers = _tmpRenderers.Where(r => r.GetTargetScreenRectTransform()!= null).ToList();\n            if (receivers.Count > 0)\n            {\n                var renderTexture = target as CanvasRenderTexture;\n                foreach (var r in receivers)\n                {\n                    r.SetTargetScreenRectTransform(renderTexture.GetComponent<RectTransform>());\n                }\n            }\n        }\n        \n        private void ApplyClipping()\n        {\n            var receivers = _tmpRenderers.Where(r => r.GetClippingSoftness()!= 0).ToList();\n            if (receivers.Count > 0)\n            {\n                var renderTexture = target as CanvasRenderTexture;\n                var pixelsPerUnit = renderTexture.pixelsPerUnit;\n                var scaleFactor = renderTexture.renderMode == RenderMode.ScreenSpaceOverlay? pixelsPerUnit : 1;\n                foreach (var r in receivers)\n                {\n                    r.SetClippingSoftness(new Vector2(0.5f / scaleFactor, 0.5f / scaleFactor));\n                }\n            }\n        }\n        \n        private void ApplySortingOrder()\n        {\n            var receivers = _tmpRenderers.Where(r => r.sortingOrder!= 0).ToList();\n            if (receivers.Count > 0)\n            {\n                receivers.Sort((r1, r2) => r1.sortingOrder.CompareTo(r2.sortingOrder));\n                int index = 0;\n                foreach (var r in receivers)\n                {\n                    r.sortingOrder = index++;\n                }\n            }\n        }\n        \n        private void ApplyAnchor()\n        {\n            var receiv",
    "code_repairing_3": "Los 5 j",
    "code_repairing_4": "using Oculus.Interaction.Editor;\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing UnityEditor;\n\nusing props = Oculus.Interaction.UnityCanvas.CanvasRenderTexture.Properties;\n\nnamespace Oculus.Interaction.UnityCanvas.Editor\n{\n    [CustomEditor(typeof(CanvasRenderTexture))]\n    public class CanvasRenderTextureEditor : EditorBase\n    {\n        private static List<CanvasRenderer> _tmpRenderers = new List<CanvasRenderer>();\n        private static Dictionary<Canvas, List<Graphic>> _graphicCache =\n            new Dictionary<Canvas, List<Graphic>>();\n\n        // MESSAGE: A collection or map whose contents are never queried or accessed is useless.\n        // private static List<Graphic> _tmpGraphics = new List<Graphic>();\n\n        protected override void OnEnable()\n        {\n            base.OnEnable();\n            _graphicCache.Clear();\n        }\n\n        public override void OnInspectorGUI()\n        {\n            base.OnInspectorGUI();\n\n            CanvasRenderTexture crt = target as CanvasRenderTexture;\n            SerializedProperty textureProp = serializedObject.FindProperty(props.TEXTURE);\n            SerializedProperty renderModeProp = serializedObject.FindProperty(props.RENDER_MODE);\n            SerializedProperty canvasRenderersProp = serializedObject.FindProperty(props.CANVAS_RENDERERS);\n\n            EditorGUILayout.PropertyField(textureProp);\n            EditorGUILayout.PropertyField(renderModeProp);\n            EditorGUILayout.PropertyField(canvasRenderersProp);\n\n            serializedObject.ApplyModifiedProperties();\n\n            Repaint();\n        }\n\n        private void OnSceneGUI()\n        {\n            if (Event.current.type == EventType.Repaint)\n            {\n                OnPaint();\n            }\n        }\n\n        private void OnPaint()\n        {\n            CanvasRenderTexture crt = target as CanvasRenderTexture;\n            RenderTexture renderTexture = crt.Texture;\n            if (renderTexture == null)\n            {\n                return;\n            }\n\n            List<CanvasRenderer> renderers = new List<CanvasRenderer>();\n            foreach (UnityEngine.Object o in crt.CanvasRenderers)\n            {\n                CanvasRenderer cr = o as CanvasRenderer;\n                if (cr == null) continue;\n                renderers.Add(cr);\n            }\n\n            using (new GUIScope(new Rect(Vector2.zero, renderTexture.size), renderTexture))\n            {\n                GL.Clear(true, true, Color.clear);\n\n                foreach (CanvasRenderer cr in renderers)\n                {\n                    List<Graphic> graphics;\n                    if (!_graphicCache.TryGetValue(cr.canvas, out graphics))\n                    {\n                        graphics = new List<Graphic>();\n                        Graphic[] gs = cr.GetComponentsInChildren<Graphic>(true);\n                        graphics.AddRange(gs);\n                        _graphicCache.Add(cr.canvas, graphics);\n                    }\n\n                    for (int i = 0; i < graphics.Count; ++i)\n                    {\n                        Graphic g = graphics[i];\n                        if (g.raycastTarget)\n                        {\n                            _tmpRenderers.Clear();\n                            EventSystem.current.RaycastAll(new PointerEventData(EventSystem.current)\n                            {\n                                position = g.transform.position,\n                                pressPosition = g.transform.position,\n                                pointerEnter = g.transform\n                            }, _tmpRenderers);\n                            if (_tmpRenderers.Contains(cr"
}