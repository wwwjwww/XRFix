{
    "code_repairing_0": "Here is a possible solution:\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing UnityEditor;\nusing UnityEditor.Compilation;\nusing UnityEngine;\n\nnamespace Microsoft.MixedReality.Toolkit.MSBuild\n{\n    \n    \n    \n    public class UnityProjectInfo\n    {\n        \n        \n        \n        private static readonly HashSet<string> ExcludedPackageReferences = new HashSet<string>()\n        {\n            \"Windows.UI.Input.Spatial\"\n        };\n\n        \n        \n        \n        public string UnityProjectName { get; }\n\n        \n        \n        \n        internal IEnumerable<CompilationPlatformInfo> AvailablePlatforms { get; }\n\n        \n        \n        \n        public IReadOnlyDictionary<string, CSProjectInfo> CSProjects { get; }\n\n        \n        \n        \n        public IReadOnlyCollection<PluginAssemblyInfo> Plugins { get; }\n\n        public UnityProjectInfo(IEnumerable<CompilationPlatformInfo> availablePlatforms, string projectOutputPath)\n        {\n            AvailablePlatforms = availablePlatforms;\n\n            UnityProjectName = Application.productName;\n\n            if (string.IsNullOrWhiteSpace(UnityProjectName))\n            {\n                UnityProjectName = \"UnityProject\";\n            }\n\n            Plugins = new ReadOnlyCollection<PluginAssemblyInfo>(ScanForPluginDLLs());\n\n            foreach (PluginAssemblyInfo plugin in Plugins)\n            {\n                if (plugin.Type == PluginType.Native)\n                {\n                    Debug.Log($\"Native plugin {plugin.ReferencePath.AbsolutePath} not yet supported for MSBuild project.\");\n                }\n            }\n\n            CSProjects = new ReadOnlyDictionary<string, CSProjectInfo>(CreateUnityProjects(projectOutputPath));\n        }\n\n        private Dictionary<string, CSProjectInfo> CreateUnityProjects(string projectOutputPath)\n        {\n            Dictionary<string, AssemblyDefinitionInfo> asmDefInfoMap = new Dictionary<string, AssemblyDefinitionInfo>();\n            HashSet<string> builtInPackagesWithoutSource = new HashSet<string>();\n\n            DirectoryInfo builtInPackagesDirectory = new DirectoryInfo(Utilities.BuiltInPackagesPath);\n            foreach (DirectoryInfo packageDirectory in builtInPackagesDirectory.GetDirectories())\n            {\n                FileInfo[] asmDefFiles = packageDirectory.GetFiles(\"*.asmdef\", SearchOption.AllDirectories);\n\n                if (asmDefFiles.Length == 0)\n                {\n                    builtInPackagesWithoutSource.Add(packageDirectory.Name.ToLower());\n                    continue;\n                }\n\n                foreach (FileInfo fileInfo in asmDefFiles)\n                {\n                    AssemblyDefinitionInfo assemblyDefinitionInfo = AssemblyDefinitionInfo.Parse(fileInfo, this, null, true);\n                    asmDefInfoMap.Add(Path.GetFileNameWithoutExtension(fileInfo.Name), assemblyDefinitionInfo);\n                }\n            }\n\n            Dictionary<string, Assembly> unityAssemblies = CompilationPipeline.GetAssemblies().ToDictionary(t => t.name);\n            Dictionary<string, CSProjectInfo> projectsMap = new Dictionary<string, CSProjectInfo>();\n            Queue<string> projectsToProcess = new Queue<string>();\n\n            foreach (KeyValuePair<string, Assembly> pair in unityAssemblies)\n            {\n                if (!asmDefInfoMap.TryGetValue(pair.Key, out AssemblyDefinitionInfo assemblyDefinitionInfo))\n                {\n                    string asmDefPath = CompilationPipeline.GetAssemblyDefinitionFilePathFromAssemblyName(pair.Key);\n                    if (string.IsNullOrEmpty(asmDefPath))\n                    {\n                        if (!pair.Key.StartsWith(\"Assembly-CSharp\"))\n                        {\n                            throw new InvalidOperationException($\"Failed to retrieve AsmDef for script assembly: {pair.Key}\");\n                        }\n\n                        assemblyDefinitionInfo = AssemblyDefinitionInfo.GetDefaultAssemblyCSharpInfo(pair.Value);\n                        projectsToProcess.Enqueue(pair.Key);\n                    }\n                    else\n                    {\n                        assemblyDefinitionInfo = AssemblyDefinitionInfo.Parse(new FileInfo(Utilities.GetFullPathFromKnownRelative(asmDefPath)), this, pair.Value);\n\n                        if (asmDefPath.StartsWith(\"Assets/\"))\n                        {\n\n                            projectsToProcess.Enqueue(pair.Key);\n                        }\n                    }\n\n                    asmDefInfoMap.Add(pair.Key, assemblyDefinitionInfo);\n                }\n            }\n\n            while (projectsToProcess.Count > 0)\n            {\n                string projectKey = projectsToProcess.Dequeue();\n\n                if (!projectsMap.ContainsKey(projectKey))\n                {\n                    GetProjectInfo(projectsMap, asmDefInfoMap, builtInPackagesWithoutSource, projectKey, projectOutputPath);\n                }\n            }\n\n            return projectsMap;\n        }\n\n        private CSProjectInfo GetProjectInfo(Dictionary<string, CSProjectInfo> projectsMap, Dictionary<string, AssemblyDefinitionInfo> asmDefInfoMap, HashSet<string> builtInPackagesWithoutSource, string projectKey, string projectOutputPath)\n        {\n            if (projectsMap.TryGetValue(projectKey, out CSProjectInfo value))\n            {\n                return value;\n            }\n\n            if (!asmDefInfoMap.TryGetValue(projectKey, out AssemblyDefinitionInfo assemblyDefinitionInfo))\n            {\n                throw new InvalidOperationException($\"Can't find an asmdef for project: {projectKey}\");\n            }\n\n            CSProjectInfo toReturn = new CSProjectInfo(this, assemblyDefinitionInfo, projectOutputPath);\n            projectsMap.Add(projectKey, toReturn);\n\n            if (!assemblyDefinitionInfo.BuiltInPackage)\n            {\n                foreach (PluginAssemblyInfo plugin in Plugins.Where(t => t.Type!= PluginType.Native))\n                {\n                    if (plugin.AutoReferenced || assemblyDefinitionInfo.PrecompiledAssemblyReferences.Contains(plugin.Name))\n                    {\n                        toReturn.AddDependency(plugin);\n                    }\n                }\n            }\n\n            foreach (string reference in toReturn.AssemblyDefinitionInfo.References)\n            {\n                if (ExcludedPackageReferences.Contains(reference))\n                {\n                    Debug.LogWarning($\"Skipping processing {reference} for {toReturn.Name}, as it's marked as excluded.\");\n                    continue;\n                }\n                string packageCandidate = $\"com.{reference.ToLower()}\";\n                if (builtInPackagesWithoutSource.Any(t => packageCandidate.StartsWith(t)))\n                {\n                    Debug.LogWarning($\"Skipping processing {reference} for {toReturn.Name}, as it's a built-in package without source.\");\n                    continue;\n                }\n\n                toReturn.AddDependency(GetProjectInfo(projectsMap, asmDefInfoMap, builtInPackagesWithoutSource, reference, projectOutputPath));\n            }\n\n            return toReturn;\n        }\n\n        private List<PluginAssemblyInfo> ScanForPluginDLLs()\n        {\n            List<PluginAssemblyInfo> toReturn = new List<PluginAssemblyInfo>();\n\n            foreach (string assetAssemblyPath in Directory.GetFiles(Utilities.AssetPath, \"*.dll\", SearchOption.AllDirectories))\n            {\n                string assetRelativePath = Utilities.GetAssetsRelativePathFrom(assetAssemblyPath);\n                PluginImporter importer = (PluginImporter)AssetImporter.GetAtPath(assetRelativePath);\n                PluginAssemblyInfo toAdd = new PluginAssemblyInfo(this, Guid.Parse(AssetDatabase.AssetPathToGUID(assetRelativePath)), assetAssemblyPath, importer.isNativePlugin? PluginType.Native : PluginType.Managed);\n                toReturn.Add(toAdd);\n            }\n\n            foreach (string packageDllPath in Directory.GetFiles(Utilities.PackagesCopyPath, \"*.dll\", SearchOption.AllDirectories))\n            {\n                string metaPath = packageDllPath + \".meta\";\n\n                if (!File.Exists(metaPath))\n                {\n                    Debug.LogWarning($\"Skipping a packages DLL that didn't have an associated meta: '{packageDllPath}'\");\n                    continue;\n                }\n                Guid guid;\n                using (StreamReader reader = new StreamReader(metaPath))\n                {\n                    string guidLine = reader.ReadUntil(\"guid\");\n                    if (!Guid.TryParse(guidLine.Split(':')[1].Trim(), out guid))\n                    {\n                        Debug.LogWarning($\"Skipping a packages DLL that didn't have a valid guid in the.meta file: '{packageDllPath}'\");\n                        continue;\n                    }\n                }\n\n                bool isManaged = Utilities.IsManagedAssembly(packageDllPath);\n                PluginAssemblyInfo toAdd = new PluginAssemblyInfo(this, guid, packageDllPath, isManaged? PluginType.Managed : PluginType.Native);\n                toReturn.Add(toAdd);\n            }\n\n            return toReturn;\n        }\n\n        private string GetProjectEntry(CSProjectInfo projectInfo, string projectEntryTemplateBody)\n        {\n            StringBuilder toReturn = new StringBuilder();\n            toReturn.AppendLine(Utilities.ReplaceTokens(projectEntryTemplateBody, new Dictionary<string, string>() {\n                        { \"<PROJECT_NAME>\", projectInfo.Name },\n                        { \"<PROJECT_RELATIVE_PATH>\", Path.GetFileName(projectInfo.ReferencePath.AbsolutePath) },\n                        { \"<PROJECT_GUID>\", projectInfo.Guid.ToString().ToUpper() } }));\n            if (projectInfo.ProjectDependencies.Count > 0)\n            {\n                string projectDependencyStartSection = \"    ProjectSection(ProjectDependencies) = postProject\";\n                string projectDependencyGuid = \"        {<DependencyGuid>} = {<DependencyGuid>}\";\n                string projectDependencyStopSection = \"    EndProjectSection\";\n                toReturn.AppendLine(projectDependencyStartSection);\n\n                foreach (CSProjectDependency<CSProjectInfo> project in projectInfo.ProjectDependencies)\n                {\n                    toReturn.AppendLine(projectDependencyGuid.Replace(\"<DependencyGuid>\", project.Dependency.Guid.ToString().ToUpper()));\n                }\n\n                toReturn.AppendLine(projectDependencyStopSection);\n            }\n            toReturn.Append(\"EndProject\");\n            return toReturn.ToString();\n        }\n\n        private void ExportSolution(string solutionTemplateText, string projectFileTemplateText, string generatedProjectPath)\n        {\n            string solutionFilePath = Path.Combine(generatedProjectPath, $\"{UnityProjectName}.sln\");\n\n            if (File.Exists(solutionFilePath))\n            {\n                File.Delete(solutionFilePath);\n            }\n\n            if (Utilities.TryGetTextTemplate(solution",
    "code_repairing_1": "Here's the fixed version of the code.\n\n```csharp\n#if UNITY_EDITOR\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing UnityEditor;\nusing UnityEditor.Compilation;\nusing UnityEngine;\n\nnamespace Microsoft.MixedReality.Toolkit.MSBuild\n{\n    \n    \n    \n    public class UnityProjectInfo\n    {\n        \n        \n        \n        private static readonly HashSet<string> ExcludedPackageReferences = new HashSet<string>()\n        {\n            \"Windows.UI.Input.Spatial\"\n        };\n\n        \n        \n        \n        public string UnityProjectName { get; }\n\n        \n        \n        \n        internal IEnumerable<CompilationPlatformInfo> AvailablePlatforms { get; }\n\n        \n        \n        \n        public IReadOnlyDictionary<string, CSProjectInfo> CSProjects { get; }\n\n        \n        \n        \n        public IReadOnlyCollection<PluginAssemblyInfo> Plugins { get; }\n\n        public UnityProjectInfo(IEnumerable<CompilationPlatformInfo> availablePlatforms, string projectOutputPath)\n        {\n            AvailablePlatforms = availablePlatforms;\n\n            UnityProjectName = Application.productName;\n\n            if (string.IsNullOrWhiteSpace(UnityProjectName))\n            {\n                UnityProjectName = \"UnityProject\";\n            }\n\n            Plugins = new ReadOnlyCollection<PluginAssemblyInfo>(ScanForPluginDLLs());\n\n            foreach (PluginAssemblyInfo plugin in Plugins)\n            {\n                if (plugin.Type == PluginType.Native)\n                {\n                    Debug.Log($\"Native plugin {plugin.ReferencePath.AbsolutePath} not yet supported for MSBuild project.\");\n                }\n            }\n\n            CSProjects = new ReadOnlyDictionary<string, CSProjectInfo>(CreateUnityProjects(projectOutputPath));\n        }\n\n        private Dictionary<string, CSProjectInfo> CreateUnityProjects(string projectOutputPath)\n        {\n            \n            Dictionary<string, AssemblyDefinitionInfo> asmDefInfoMap = new Dictionary<string, AssemblyDefinitionInfo>();\n            HashSet<string> builtInPackagesWithoutSource = new HashSet<string>();\n\n            \n            DirectoryInfo builtInPackagesDirectory = new DirectoryInfo(Utilities.BuiltInPackagesPath);\n            foreach (DirectoryInfo packageDirectory in builtInPackagesDirectory.GetDirectories())\n            {\n                FileInfo[] asmDefFiles = packageDirectory.GetFiles(\"*.asmdef\", SearchOption.AllDirectories);\n\n                if (asmDefFiles.Length == 0)\n                {\n                    builtInPackagesWithoutSource.Add(packageDirectory.Name.ToLower());\n                    continue;\n                }\n\n                foreach (FileInfo fileInfo in asmDefFiles)\n                {\n                    AssemblyDefinitionInfo assemblyDefinitionInfo = AssemblyDefinitionInfo.Parse(fileInfo, this, null, true);\n                    asmDefInfoMap.Add(Path.GetFileNameWithoutExtension(fileInfo.Name), assemblyDefinitionInfo);\n                }\n            }\n\n            Dictionary<string, Assembly> unityAssemblies = CompilationPipeline.GetAssemblies().ToDictionary(t => t.name);\n            Dictionary<string, CSProjectInfo> projectsMap = new Dictionary<string, CSProjectInfo>();\n            Queue<string> projectsToProcess = new Queue<string>();\n            \n            foreach (KeyValuePair<string, Assembly> pair in unityAssemblies)\n            {\n                if (!asmDefInfoMap.TryGetValue(pair.Key, out AssemblyDefinitionInfo assemblyDefinitionInfo))\n                {\n                    string asmDefPath = CompilationPipeline.GetAssemblyDefinitionFilePathFromAssemblyName(pair.Key);\n                    if (string.IsNullOrEmpty(asmDefPath))\n                    {\n                        if (!pair.Key.StartsWith(\"Assembly-CSharp\"))\n                        {\n                            throw new InvalidOperationException($\"Failed to retrieve AsmDef for script assembly: {pair.Key}\");\n                        }\n\n                        assemblyDefinitionInfo = AssemblyDefinitionInfo.GetDefaultAssemblyCSharpInfo(pair.Value);\n                        projectsToProcess.Enqueue(pair.Key);\n                    }\n                    else\n                    {\n                        assemblyDefinitionInfo = AssemblyDefinitionInfo.Parse(new FileInfo(Utilities.GetFullPathFromKnownRelative(asmDefPath)), this, pair.Value);\n\n                        if (asmDefPath.StartsWith(\"Assets/\"))\n                        {\n                            \n                            projectsToProcess.Enqueue(pair.Key);\n                        }\n                    }\n\n                    asmDefInfoMap.Add(pair.Key, assemblyDefinitionInfo);\n                }\n            }\n\n            while (projectsToProcess.Count > 0)\n            {\n                string projectKey = projectsToProcess.Dequeue();\n\n                if (!projectsMap.ContainsKey(projectKey))\n                {\n                    GetProjectInfo(projectsMap, asmDefInfoMap, builtInPackagesWithoutSource, projectKey, projectOutputPath);\n                }\n            }\n\n            return projectsMap;\n        }\n\n        private CSProjectInfo GetProjectInfo(Dictionary<string, CSProjectInfo> projectsMap, Dictionary<string, AssemblyDefinitionInfo> asmDefInfoMap, HashSet<string> builtInPackagesWithoutSource, string projectKey, string projectOutputPath)\n        {\n            if (projectsMap.TryGetValue(projectKey, out CSProjectInfo value))\n            {\n                return value;\n            }\n\n            if (!asmDefInfoMap.TryGetValue(projectKey, out AssemblyDefinitionInfo assemblyDefinitionInfo))\n            {\n                throw new InvalidOperationException($\"Can't find an asmdef for project: {projectKey}\");\n            }\n\n            CSProjectInfo toReturn = new CSProjectInfo(this, assemblyDefinitionInfo, projectOutputPath);\n            projectsMap.Add(projectKey, toReturn);\n\n            if (!assemblyDefinitionInfo.BuiltInPackage)\n            {\n                foreach (PluginAssemblyInfo plugin in Plugins.Where(t => t.Type!= PluginType.Native))\n                {\n                    if (plugin.AutoReferenced || assemblyDefinitionInfo.PrecompiledAssemblyReferences.Contains(plugin.Name))\n                    {\n                        toReturn.AddDependency(plugin);\n                    }\n                }\n            }\n\n            foreach (string reference in toReturn.AssemblyDefinitionInfo.References)\n            {\n                if (ExcludedPackageReferences.Contains(reference))\n                {\n                    Debug.LogWarning($\"Skipping processing {reference} for {toReturn.Name}, as it's marked as excluded.\");\n                    continue;\n                }\n                string packageCandidate = $\"com.{reference.ToLower()}\";\n                if (builtInPackagesWithoutSource.Any(t => packageCandidate.StartsWith(t)))\n                {\n                    Debug.LogWarning($\"Skipping processing {reference} for {toReturn.Name}, as it's a built-in package without source.\");\n                    continue;\n                }\n\n                toReturn.AddDependency(GetProjectInfo(projectsMap, asmDefInfoMap, builtInPackagesWithoutSource, reference, projectOutputPath));\n            }\n\n            return toReturn;\n        }\n\n        private List<PluginAssemblyInfo> ScanForPluginDLLs()\n        {\n            List<PluginAssemblyInfo> toReturn = new List<PluginAssemblyInfo>();\n\n            foreach (string assetAssemblyPath in Directory.GetFiles(Utilities.AssetPath, \"*.dll\", SearchOption.AllDirectories))\n            {\n                string assetRelativePath = Utilities.GetAssetsRelativePathFrom(assetAssemblyPath);\n                PluginImporter importer = (PluginImporter)AssetImporter.GetAtPath(assetRelativePath);\n                PluginAssemblyInfo toAdd = new PluginAssemblyInfo(this, Guid.Parse(AssetDatabase.AssetPathToGUID(assetRelativePath)), assetAssemblyPath, importer.isNativePlugin? PluginType.Native : PluginType.Managed);\n                toReturn.Add(toAdd);\n            }\n\n            foreach (string packageDllPath in Directory.GetFiles(Utilities.PackagesCopyPath, \"*.dll\", SearchOption.AllDirectories))\n            {\n                string metaPath = packageDllPath + \".meta\";\n\n                if (!File.Exists(metaPath))\n                {\n                    Debug.LogWarning($\"Skipping a packages DLL that didn't have an associated meta: '{packageDllPath}'\");\n                    continue;\n                }\n                Guid guid;\n                using (StreamReader reader = new StreamReader(metaPath))\n                {\n                    string guidLine = reader.ReadUntil(\"guid\");\n                    if (!Guid.TryParse(guidLine.Split(':')[1].Trim(), out guid))\n                    {\n                        Debug.LogWarning($\"Skipping a packages DLL that didn't have a valid guid in the.meta file: '{packageDllPath}'\");\n                        continue;\n                    }\n                }\n\n                bool isManaged = Utilities.IsManagedAssembly(packageDllPath);\n                PluginAssemblyInfo toAdd = new PluginAssemblyInfo(this, guid, packageDllPath, isManaged? PluginType.Managed : PluginType.Native);\n                toReturn.Add(toAdd);\n            }\n\n            return toReturn;\n        }\n\n        private string GetProjectEntry(CSProjectInfo projectInfo, string projectEntryTemplateBody)\n        {\n            StringBuilder toReturn = new StringBuilder();\n            toReturn.AppendLine(Utilities.ReplaceTokens(projectEntryTemplateBody, new Dictionary<string, string>() {\n                        { \"PROJECT_NAME\", projectInfo.Name },\n                        { \"PROJECT_RELATIVE_PATH\", Path.GetFileName(projectInfo.ReferencePath.AbsolutePath) },\n                        { \"PROJECT_GUID\", projectInfo.Guid.ToString().ToUpper() } }));\n            if (projectInfo.ProjectDependencies.Count > 0)\n            {\n                string projectDependencyStartSection = \"    ProjectSection(ProjectDependencies) = postProject\";\n                string projectDependencyGuid = \"        {DependencyGuid} = {DependencyGuid}\";\n                string projectDependencyStopSection = \"    EndProjectSection\";\n                toReturn.AppendLine(projectDependencyStartSection);\n\n                foreach (CSProjectDependency<CSProjectInfo> project in projectInfo.ProjectDependencies)\n                {\n                    toReturn.AppendLine(projectDependencyGuid.Replace(\"DependencyGuid\", project.Dependency.Guid.ToString().ToUpper()));\n                }\n\n                toReturn.AppendLine(projectDependencyStopSection);\n            }\n            toReturn.Append(\"EndProject\");\n            return toReturn.ToString();\n        }\n\n        \n        \n        \n        \n        \n        \n        public void ExportSolution(string solutionTemplateText, string projectFileTemplateText, string generatedProjectPath)\n        {\n            string solutionFilePath = Path.Combine(generatedProjectPath, $\"{UnityProjectName}.sln\");\n\n            if (File.Exists(solutionFilePath))\n            {\n                File.Delete(solutionFilePath",
    "code_repairing_2": "Here is the fixed code:\n```csharp\n#if UNITY_EDITOR\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing UnityEditor;\nusing UnityEditor.Compilation;\nusing UnityEngine;\n\nnamespace Microsoft.MixedReality.Toolkit.MSBuild\n{\n    \n    \n    \n    public class UnityProjectInfo\n    {\n        \n        \n        \n        private static readonly HashSet<string> ExcludedPackageReferences = new HashSet<string>()\n        {\n            \"Windows.UI.Input.Spatial\"\n        };\n\n        \n        \n        \n        public string UnityProjectName { get; }\n\n        \n        \n        \n        internal IEnumerable<CompilationPlatformInfo> AvailablePlatforms { get; }\n\n        \n        \n        \n        public IReadOnlyDictionary<string, CSProjectInfo> CSProjects { get; }\n\n        \n        \n        \n        public IReadOnlyCollection<PluginAssemblyInfo> Plugins { get; }\n\n        public UnityProjectInfo(IEnumerable<CompilationPlatformInfo> availablePlatforms, string projectOutputPath)\n        {\n            AvailablePlatforms = availablePlatforms;\n\n            UnityProjectName = Application.productName;\n\n            if (string.IsNullOrWhiteSpace(UnityProjectName))\n            {\n                UnityProjectName = \"UnityProject\";\n            }\n\n            Plugins = new ReadOnlyCollection<PluginAssemblyInfo>(ScanForPluginDLLs());\n\n            foreach (PluginAssemblyInfo plugin in Plugins)\n            {\n                if (plugin.Type == PluginType.Native)\n                {\n                    Debug.Log($\"Native plugin {plugin.ReferencePath.AbsolutePath} not yet supported for MSBuild project.\");\n                }\n            }\n\n            CSProjects = new ReadOnlyDictionary<string, CSProjectInfo>(CreateUnityProjects(projectOutputPath));\n        }\n\n        private Dictionary<string, CSProjectInfo> CreateUnityProjects(string projectOutputPath)\n        {\n            \n            Dictionary<string, AssemblyDefinitionInfo> asmDefInfoMap = new Dictionary<string, AssemblyDefinitionInfo>();\n            HashSet<string> builtInPackagesWithoutSource = new HashSet<string>();\n\n            \n            DirectoryInfo builtInPackagesDirectory = new DirectoryInfo(Utilities.BuiltInPackagesPath);\n            foreach (DirectoryInfo packageDirectory in builtInPackagesDirectory.GetDirectories())\n            {\n                FileInfo[] asmDefFiles = packageDirectory.GetFiles(\"*.asmdef\", SearchOption.AllDirectories);\n\n                if (asmDefFiles.Length == 0)\n                {\n                    builtInPackagesWithoutSource.Add(packageDirectory.Name.ToLower());\n                    continue;\n                }\n\n                foreach (FileInfo fileInfo in asmDefFiles)\n                {\n                    AssemblyDefinitionInfo assemblyDefinitionInfo = AssemblyDefinitionInfo.Parse(fileInfo, this, null, true);\n                    asmDefInfoMap.Add(Path.GetFileNameWithoutExtension(fileInfo.Name), assemblyDefinitionInfo);\n                }\n            }\n\n            Dictionary<string, Assembly> unityAssemblies = CompilationPipeline.GetAssemblies().ToDictionary(t => t.name);\n            Dictionary<string, CSProjectInfo> projectsMap = new Dictionary<string, CSProjectInfo>();\n            Queue<string> projectsToProcess = new Queue<string>();\n            \n            foreach (KeyValuePair<string, Assembly> pair in unityAssemblies)\n            {\n                if (!asmDefInfoMap.TryGetValue(pair.Key, out AssemblyDefinitionInfo assemblyDefinitionInfo))\n                {\n                    string asmDefPath = CompilationPipeline.GetAssemblyDefinitionFilePathFromAssemblyName(pair.Key);\n                    if (string.IsNullOrEmpty(asmDefPath))\n                    {\n                        if (!pair.Key.StartsWith(\"Assembly-CSharp\"))\n                        {\n                            throw new InvalidOperationException($\"Failed to retrieve AsmDef for script assembly: {pair.Key}\");\n                        }\n\n                        assemblyDefinitionInfo = AssemblyDefinitionInfo.GetDefaultAssemblyCSharpInfo(pair.Value);\n                        projectsToProcess.Enqueue(pair.Key);\n                    }\n                    else\n                    {\n                        assemblyDefinitionInfo = AssemblyDefinitionInfo.Parse(new FileInfo(Utilities.GetFullPathFromKnownRelative(asmDefPath)), this, pair.Value);\n\n                        if (asmDefPath.StartsWith(\"Assets/\"))\n                        {\n                            \n                            projectsToProcess.Enqueue(pair.Key);\n                        }\n                    }\n\n                    asmDefInfoMap.Add(pair.Key, assemblyDefinitionInfo);\n                }\n            }\n\n            while (projectsToProcess.Count > 0)\n            {\n                string projectKey = projectsToProcess.Dequeue();\n\n                if (!projectsMap.ContainsKey(projectKey))\n                {\n                    GetProjectInfo(projectsMap, asmDefInfoMap, builtInPackagesWithoutSource, projectKey, projectOutputPath);\n                }\n            }\n\n            return projectsMap;\n        }\n\n        private CSProjectInfo GetProjectInfo(Dictionary<string, CSProjectInfo> projectsMap, Dictionary<string, AssemblyDefinitionInfo> asmDefInfoMap, HashSet<string> builtInPackagesWithoutSource, string projectKey, string projectOutputPath)\n        {\n            if (projectsMap.TryGetValue(projectKey, out CSProjectInfo value))\n            {\n                return value;\n            }\n\n            if (!asmDefInfoMap.TryGetValue(projectKey, out AssemblyDefinitionInfo assemblyDefinitionInfo))\n            {\n                throw new InvalidOperationException($\"Can't find an asmdef for project: {projectKey}\");\n            }\n\n            CSProjectInfo toReturn = new CSProjectInfo(this, assemblyDefinitionInfo, projectOutputPath);\n            projectsMap.Add(projectKey, toReturn);\n\n            if (!assemblyDefinitionInfo.BuiltInPackage)\n            {\n                foreach (PluginAssemblyInfo plugin in Plugins.Where(t => t.Type!= PluginType.Native))\n                {\n                    if (plugin.AutoReferenced || assemblyDefinitionInfo.PrecompiledAssemblyReferences.Contains(plugin.Name))\n                    {\n                        toReturn.AddDependency(plugin);\n                    }\n                }\n            }\n\n            foreach (string reference in toReturn.AssemblyDefinitionInfo.References)\n            {\n                if (ExcludedPackageReferences.Contains(reference))\n                {\n                    Debug.LogWarning($\"Skipping processing {reference} for {toReturn.Name}, as it's marked as excluded.\");\n                    continue;\n                }\n                string packageCandidate = $\"com.{reference.ToLower()}\";\n                if (builtInPackagesWithoutSource.Any(t => packageCandidate.StartsWith(t)))\n                {\n                    Debug.LogWarning($\"Skipping processing {reference} for {toReturn.Name}, as it's a built-in package without source.\");\n                    continue;\n                }\n\n                toReturn.AddDependency(GetProjectInfo(projectsMap, asmDefInfoMap, builtInPackagesWithoutSource, reference, projectOutputPath));\n            }\n\n            return toReturn;\n        }\n\n        private List<PluginAssemblyInfo> ScanForPluginDLLs()\n        {\n            List<PluginAssemblyInfo> toReturn = new List<PluginAssemblyInfo>();\n\n            foreach (string assetAssemblyPath in Directory.GetFiles(Utilities.AssetPath, \"*.dll\", SearchOption.AllDirectories))\n            {\n                string assetRelativePath = Utilities.GetAssetsRelativePathFrom(assetAssemblyPath);\n                PluginImporter importer = (PluginImporter)AssetImporter.GetAtPath(assetRelativePath);\n                PluginAssemblyInfo toAdd = new PluginAssemblyInfo(this, Guid.Parse(AssetDatabase.AssetPathToGUID(assetRelativePath)), assetAssemblyPath, importer.isNativePlugin? PluginType.Native : PluginType.Managed);\n                toReturn.Add(toAdd);\n            }\n\n            foreach (string packageDllPath in Directory.GetFiles(Utilities.PackagesCopyPath, \"*.dll\", SearchOption.AllDirectories))\n            {\n                string metaPath = packageDllPath + \".meta\";\n\n                if (!File.Exists(metaPath))\n                {\n                    Debug.LogWarning($\"Skipping a packages DLL that didn't have an associated meta: '{packageDllPath}'\");\n                    continue;\n                }\n                Guid guid;\n                using (StreamReader reader = new StreamReader(metaPath))\n                {\n                    string guidLine = reader.ReadUntil(\"guid\");\n                    if (!Guid.TryParse(guidLine.Split(':')[1].Trim(), out guid))\n                    {\n                        Debug.LogWarning($\"Skipping a packages DLL that didn't have a valid guid in the.meta file: '{packageDllPath}'\");\n                        continue;\n                    }\n                }\n\n                bool isManaged = Utilities.IsManagedAssembly(packageDllPath);\n                PluginAssemblyInfo toAdd = new PluginAssemblyInfo(this, guid, packageDllPath, isManaged? PluginType.Managed : PluginType.Native);\n                toReturn.Add(toAdd);\n            }\n\n            return toReturn;\n        }\n\n        private string GetProjectEntry(CSProjectInfo projectInfo, string projectEntryTemplateBody)\n        {\n            StringBuilder toReturn = new StringBuilder();\n            toReturn.AppendLine(Utilities.ReplaceTokens(projectEntryTemplateBody, new Dictionary<string, string>() {\n                        { \"<PROJECT_NAME>\", projectInfo.Name },\n                        { \"<PROJECT_RELATIVE_PATH>\", Path.GetFileName(projectInfo.ReferencePath.AbsolutePath) },\n                        { \"<PROJECT_GUID>\", projectInfo.Guid.ToString().ToUpper() } }));\n            if (projectInfo.ProjectDependencies.Count > 0)\n            {\n                string projectDependencyStartSection = \"    ProjectSection(ProjectDependencies) = postProject\";\n                string projectDependencyGuid = \"        {<DependencyGuid>} = {<DependencyGuid>}\";\n                string projectDependencyStopSection = \"    EndProjectSection\";\n                toReturn.AppendLine(projectDependencyStartSection);\n\n                foreach (CSProjectDependency<CSProjectInfo> project in projectInfo.ProjectDependencies)\n                {\n                    toReturn.AppendLine(projectDependencyGuid.Replace(\"<DependencyGuid>\", project.Dependency.Guid.ToString().ToUpper()));\n                }\n\n                toReturn.AppendLine(projectDependencyStopSection);\n            }\n            toReturn.Append(\"EndProject\");\n            return toReturn.ToString();\n        }\n\n        \n        \n        \n        \n        \n        \n        public void ExportSolution(string solutionTemplateText, string projectFileTemplateText, string generatedProjectPath)\n        {\n            string solutionFilePath = Path.Combine(generatedProjectPath, $\"{UnityProjectName}.sln\");\n\n            if (File.Exists(solutionFilePath))\n            {",
    "code_repairing_3": "Fixed Code:\n\n```cs\n#if UNITY_EDITOR\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing UnityEditor;\nusing UnityEditor.Compilation;\nusing UnityEngine;\n\nnamespace Microsoft.MixedReality.Toolkit.MSBuild\n{\n    \n    \n    \n    public class UnityProjectInfo\n    {\n        \n        \n        \n        private static readonly HashSet<string> ExcludedPackageReferences = new HashSet<string>()\n        {\n            \"Windows.UI.Input.Spatial\"\n        };\n\n        \n        \n        \n        public string UnityProjectName { get; }\n\n        \n        \n        \n        internal IEnumerable<CompilationPlatformInfo> AvailablePlatforms { get; }\n\n        \n        \n        \n        public IReadOnlyDictionary<string, CSProjectInfo> CSProjects { get; }\n\n        \n        \n        \n        public IReadOnlyCollection<PluginAssemblyInfo> Plugins { get; }\n\n        public UnityProjectInfo(IEnumerable<CompilationPlatformInfo> availablePlatforms, string projectOutputPath)\n        {\n            AvailablePlatforms = availablePlatforms;\n\n            UnityProjectName = Application.productName;\n\n            if (string.IsNullOrWhiteSpace(UnityProjectName))\n            {\n                UnityProjectName = \"UnityProject\";\n            }\n\n            Plugins = new ReadOnlyCollection<PluginAssemblyInfo>(ScanForPluginDLLs());\n\n            foreach (PluginAssemblyInfo plugin in Plugins)\n            {\n                if (plugin.Type == PluginType.Native)\n                {\n                    Debug.Log($\"Native plugin {plugin.ReferencePath.AbsolutePath} not yet supported for MSBuild project.\");\n                }\n            }\n\n            CSProjects = new ReadOnlyDictionary<string, CSProjectInfo>(CreateUnityProjects(projectOutputPath));\n        }\n\n        private Dictionary<string, CSProjectInfo> CreateUnityProjects(string projectOutputPath)\n        {\n            \n            Dictionary<string, AssemblyDefinitionInfo> asmDefInfoMap = new Dictionary<string, AssemblyDefinitionInfo>();\n            HashSet<string> builtInPackagesWithoutSource = new HashSet<string>();\n\n            \n            DirectoryInfo builtInPackagesDirectory = new DirectoryInfo(Utilities.BuiltInPackagesPath);\n            foreach (DirectoryInfo packageDirectory in builtInPackagesDirectory.GetDirectories())\n            {\n                FileInfo[] asmDefFiles = packageDirectory.GetFiles(\"*.asmdef\", SearchOption.AllDirectories);\n\n                if (asmDefFiles.Length == 0)\n                {\n                    builtInPackagesWithoutSource.Add(packageDirectory.Name.ToLower());\n                    continue;\n                }\n\n                foreach (FileInfo fileInfo in asmDefFiles)\n                {\n                    AssemblyDefinitionInfo assemblyDefinitionInfo = AssemblyDefinitionInfo.Parse(fileInfo, this, null, true);\n                    asmDefInfoMap.Add(Path.GetFileNameWithoutExtension(fileInfo.Name), assemblyDefinitionInfo);\n                }\n            }\n\n            Dictionary<string, Assembly> unityAssemblies = CompilationPipeline.GetAssemblies().ToDictionary(t => t.name);\n            Dictionary<string, CSProjectInfo> projectsMap = new Dictionary<string, CSProjectInfo>();\n            Queue<string> projectsToProcess = new Queue<string>();\n            \n            foreach (KeyValuePair<string, Assembly> pair in unityAssemblies)\n            {\n                if (!asmDefInfoMap.TryGetValue(pair.Key, out AssemblyDefinitionInfo assemblyDefinitionInfo))\n                {\n                    string asmDefPath = CompilationPipeline.GetAssemblyDefinitionFilePathFromAssemblyName(pair.Key);\n                    if (string.IsNullOrEmpty(asmDefPath))\n                    {\n                        if (!pair.Key.StartsWith(\"Assembly-CSharp\"))\n                        {\n                            throw new InvalidOperationException($\"Failed to retrieve AsmDef for script assembly: {pair.Key}\");\n                        }\n\n                        assemblyDefinitionInfo = AssemblyDefinitionInfo.GetDefaultAssemblyCSharpInfo(pair.Value);\n                        projectsToProcess.Enqueue(pair.Key);\n                    }\n                    else\n                    {\n                        assemblyDefinitionInfo = AssemblyDefinitionInfo.Parse(new FileInfo(Utilities.GetFullPathFromKnownRelative(asmDefPath)), this, pair.Value);\n\n                        if (asmDefPath.StartsWith(\"Assets/\"))\n                        {\n                            \n                            projectsToProcess.Enqueue(pair.Key);\n                        }\n                    }\n\n                    asmDefInfoMap.Add(pair.Key, assemblyDefinitionInfo);\n                }\n            }\n\n            while (projectsToProcess.Count > 0)\n            {\n                string projectKey = projectsToProcess.Dequeue();\n\n                if (!projectsMap.ContainsKey(projectKey))\n                {\n                    GetProjectInfo(projectsMap, asmDefInfoMap, builtInPackagesWithoutSource, projectKey, projectOutputPath);\n                }\n            }\n\n            return projectsMap;\n        }\n\n        private CSProjectInfo GetProjectInfo(Dictionary<string, CSProjectInfo> projectsMap, Dictionary<string, AssemblyDefinitionInfo> asmDefInfoMap, HashSet<string> builtInPackagesWithoutSource, string projectKey, string projectOutputPath)\n        {\n            if (projectsMap.TryGetValue(projectKey, out CSProjectInfo value))\n            {\n                return value;\n            }\n\n            if (!asmDefInfoMap.TryGetValue(projectKey, out AssemblyDefinitionInfo assemblyDefinitionInfo))\n            {\n                throw new InvalidOperationException($\"Can't find an asmdef for project: {projectKey}\");\n            }\n\n            CSProjectInfo toReturn = new CSProjectInfo(this, assemblyDefinitionInfo, projectOutputPath);\n            projectsMap.Add(projectKey, toReturn);\n\n            if (!assemblyDefinitionInfo.BuiltInPackage)\n            {\n                foreach (PluginAssemblyInfo plugin in Plugins.Where(t => t.Type!= PluginType.Native))\n                {\n                    if (plugin.AutoReferenced || assemblyDefinitionInfo.PrecompiledAssemblyReferences.Contains(plugin.Name))\n                    {\n                        toReturn.AddDependency(plugin);\n                    }\n                }\n            }\n\n            foreach (string reference in toReturn.AssemblyDefinitionInfo.References)\n            {\n                if (ExcludedPackageReferences.Contains(reference))\n                {\n                    Debug.LogWarning($\"Skipping processing {reference} for {toReturn.Name}, as it's marked as excluded.\");\n                    continue;\n                }\n                string packageCandidate = $\"com.{reference.ToLower()}\";\n                if (builtInPackagesWithoutSource.Any(t => packageCandidate.StartsWith(t)))\n                {\n                    Debug.LogWarning($\"Skipping processing {reference} for {toReturn.Name}, as it's a built-in package without source.\");\n                    continue;\n                }\n\n                toReturn.AddDependency(GetProjectInfo(projectsMap, asmDefInfoMap, builtInPackagesWithoutSource, reference, projectOutputPath));\n            }\n\n            return toReturn;\n        }\n\n        private List<PluginAssemblyInfo> ScanForPluginDLLs()\n        {\n            List<PluginAssemblyInfo> toReturn = new List<PluginAssemblyInfo>();\n\n            foreach (string assetAssemblyPath in Directory.GetFiles(Utilities.AssetPath, \"*.dll\", SearchOption.AllDirectories))\n            {\n                string assetRelativePath = Utilities.GetAssetsRelativePathFrom(assetAssemblyPath);\n                PluginImporter importer = (PluginImporter)AssetImporter.GetAtPath(assetRelativePath);\n                PluginAssemblyInfo toAdd = new PluginAssemblyInfo(this, Guid.Parse(AssetDatabase.AssetPathToGUID(assetRelativePath)), assetAssemblyPath, importer.isNativePlugin? PluginType.Native : PluginType.Managed);\n                toReturn.Add(toAdd);\n            }\n\n            foreach (string packageDllPath in Directory.GetFiles(Utilities.PackagesCopyPath, \"*.dll\", SearchOption.AllDirectories))\n            {\n                string metaPath = packageDllPath + \".meta\";\n\n                if (!File.Exists(metaPath))\n                {\n                    Debug.LogWarning($\"Skipping a packages DLL that didn't have an associated meta: '{packageDllPath}'\");\n                    continue;\n                }\n                Guid guid;\n                using (StreamReader reader = new StreamReader(metaPath))\n                {\n                    string guidLine = reader.ReadUntil(\"guid\");\n                    if (!Guid.TryParse(guidLine.Split(':')[1].Trim(), out guid))\n                    {\n                        Debug.LogWarning($\"Skipping a packages DLL that didn't have a valid guid in the.meta file: '{packageDllPath}'\");\n                        continue;\n                    }\n                }\n\n                bool isManaged = Utilities.IsManagedAssembly(packageDllPath);\n                PluginAssemblyInfo toAdd = new PluginAssemblyInfo(this, guid, packageDllPath, isManaged? PluginType.Managed : PluginType.Native);\n                toReturn.Add(toAdd);\n            }\n\n            return toReturn;\n        }\n\n        private string GetProjectEntry(CSProjectInfo projectInfo, string projectEntryTemplateBody)\n        {\n            StringBuilder toReturn = new StringBuilder();\n            toReturn.AppendLine(Utilities.ReplaceTokens(projectEntryTemplateBody, new Dictionary<string, string>() {\n                        { \"<PROJECT_NAME>\", projectInfo.Name },\n                        { \"<PROJECT_RELATIVE_PATH>\", Path.GetFileName(projectInfo.ReferencePath.AbsolutePath) },\n                        { \"<PROJECT_GUID>\", projectInfo.Guid.ToString().ToUpper() } }));\n            if (projectInfo.ProjectDependencies.Count > 0)\n            {\n                string projectDependencyStartSection = \"    ProjectSection(ProjectDependencies) = postProject\";\n                string projectDependencyGuid = \"        {<DependencyGuid>} = {<DependencyGuid>}\";\n                string projectDependencyStopSection = \"    EndProjectSection\";\n                toReturn.AppendLine(projectDependencyStartSection);\n\n                foreach (CSProjectDependency<CSProjectInfo> project in projectInfo.ProjectDependencies)\n                {\n                    toReturn.AppendLine(projectDependencyGuid.Replace(\"<DependencyGuid>\", project.Dependency.Guid.ToString().ToUpper()));\n                }\n\n                toReturn.AppendLine(projectDependencyStopSection);\n            }\n            toReturn.Append(\"EndProject\");\n            return toReturn.ToString();\n        }\n\n        \n        \n        \n        \n        \n        \n        public void ExportSolution(string solutionTemplateText, string projectFileTemplateText, string generatedProjectPath)\n        {\n            string solutionFilePath = Path.Combine(generatedProjectPath, $\"{UnityProjectName}.sln\");\n\n            if (File.Exists(solutionFilePath))\n            {\n                File.",
    "code_repairing_4": "Here's a potential solution:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Solution Version=\"12.00\" SolutionId=\"e7a70177-92e9-4539-89c4-99b980d54499\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n    <Project ProjectId=\"e7a70177-92e9-4539-89c4-99b980d54499\" SolutionId=\"e7a70177-92e9-4539-89c4-99b980d54499\" Name=\"UnityProjectName\" Language=\"C#\" TargetFrameworkVersion=\"4.7.2\">\n        <ProjectSection Name=\"ProjectDependencies\">\n            <ProjectReference>\n                <Project>{95a2789d-9623-49f6-963d-fc8cc0751fbd}</Project>\n                <Name>Microsoft.MixedReality.Toolkit.Core</Name>\n            </ProjectReference>\n            <ProjectReference>\n                <Project>{0149F8E4-F8B8-4B29-94C7-7B783639346E}</Project>\n                <Name>Microsoft.MixedReality.Toolkit.Input</Name>\n            </ProjectReference>\n        </ProjectSection>\n    </Project>\n    <Project ProjectId=\"95a2789d-9623-49f6-963d-fc8cc0751fbd\" SolutionId=\"e7a70177-92e9-4539-89c4-99b980d54499\" Name=\"Microsoft.MixedReality.Toolkit.Core\" Language=\"C#\" TargetFrameworkVersion=\"4.7.2\">\n        <ProjectSection Name=\"ProjectDependencies\">\n            <ProjectReference>\n                <Project>{6b988e55-7dd4-422c-89ec-179843346d17}</Project>\n                <Name>Microsoft.MixedReality.Toolkit.Services</Name>\n            </ProjectReference>\n        </ProjectSection>\n    </Project>\n    <Project ProjectId=\"6b988e55-7dd4-422c-89ec-179843346d17\" SolutionId=\"e7a70177-92e9-4539-89c4-99b980d54499\" Name=\"Microsoft.MixedReality.Toolkit.Services\" Language=\"C#\" TargetFrameworkVersion=\"4.7.2\">\n        <ProjectSection Name=\"ProjectDependencies\" />\n    </Project>\n    <Project ProjectId=\"0149F8E4-F8B8-4B29-94C7-7B783639346E\" SolutionId=\"e7a70177-92e9-4539-89c4-99b980d54499\" Name=\"Microsoft.MixedReality.Toolkit.Input\" Language=\"C#\" TargetFrameworkVersion=\"4.7.2\">\n        <ProjectSection Name=\"ProjectDependencies\">\n            <ProjectReference>\n                <Project>{359960d3-c81d-4965-8b16-f3b45dd14c97}</Project>\n                <Name>Microsoft.MixedReality.Toolkit.Utilities</Name>\n            </ProjectReference>\n        </ProjectSection>\n    </Project>\n    <Project ProjectId=\"359960d3-c81d-4965-8b16-f3b45dd14c97\" SolutionId=\"e7a70177-92e9-4539-89c4-99b980d54499\" Name=\"Microsoft.MixedReality.Toolkit.Utilities\" Language=\"C#\" TargetFrameworkVersion=\"4.7.2\">\n        <ProjectSection Name=\"ProjectDependencies\" />\n    </Project>\n{ProjectEntries}\n{ConfigurationPlatformEntries}\n{ConfigurationPlatformMappings}\n{ConfigurationPlatformEnabled}\n</Solution>\n```\n\nThe `{ProjectEntries}` section will be replaced with the generated project entries. The `{ConfigurationPlatformEntries}` section will be repeated for each available platform, with the appropriate `<Configuration>` and `<Platform>` tags filled in. The `{ConfigurationPlatformMappings}` section will map each configuration and platform combination to the appropriate project. The `{ConfigurationPlatformEnabled}` section will enable the appropriate projects for the active configuration and platform combination.\n\nThe following code should fix the compiler errors:\n\n```csharp\n#if UNITY_EDITOR\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing UnityEditor;\nusing UnityEditor.Compilation;\nusing UnityEngine;\n\nnamespace Microsoft.MixedReality.Toolkit.MSBuild\n{\n    \n    \n    \n    public class UnityProjectInfo\n    {\n        \n        \n        \n        private static readonly HashSet<string> ExcludedPackageReferences = new HashSet<string>()\n        {\n            \"Windows.UI.Input.Spatial\"\n        };\n\n        \n        \n        \n        public string UnityProjectName { get; }\n\n        \n        \n        \n        internal IEnumerable<CompilationPlatformInfo> AvailablePlatforms { get; }\n\n        \n        \n        \n        public IReadOnlyDictionary<string, CSProjectInfo> CSProjects { get; }\n\n        \n        \n        \n        public IReadOnlyCollection<PluginAssemblyInfo> Plugins { get; }\n\n        public UnityProjectInfo(IEnumerable<CompilationPlatformInfo> availablePlatforms, string projectOutputPath)\n        {\n            AvailablePlatforms = availablePlatforms;\n\n            UnityProjectName = Application.productName;\n\n            if (string.IsNullOrWhiteSpace(UnityProjectName))\n            {\n                UnityProjectName = \"UnityProject\";\n            }\n\n            Plugins = new ReadOnlyCollection<PluginAssemblyInfo>(ScanForPluginDLLs());\n\n            foreach (PluginAssemblyInfo plugin in Plugins)\n            {\n                if (plugin.Type == PluginType.Native)\n                {\n                    Debug.Log($\"Native plugin {plugin.ReferencePath.AbsolutePath} not yet supported for MSBuild project.\");\n                }\n            }\n\n            CSProjects = new ReadOnlyDictionary<string, CSProjectInfo>(CreateUnityProjects(projectOutputPath));\n        }\n\n        private Dictionary<string, CSProjectInfo> CreateUnityProjects(string projectOutputPath)\n        {\n            \n            Dictionary<string, AssemblyDefinitionInfo> asmDefInfoMap = new Dictionary<string, AssemblyDefinitionInfo>();\n            HashSet<string> builtInPackagesWithoutSource = new HashSet<string>();\n\n            \n            DirectoryInfo builtInPackagesDirectory = new DirectoryInfo(Utilities.BuiltInPackagesPath);\n            foreach (DirectoryInfo packageDirectory in builtInPackagesDirectory.GetDirectories())\n            {\n                FileInfo[] asmDefFiles = packageDirectory.GetFiles(\"*.asmdef\", SearchOption.AllDirectories);\n\n                if (asmDefFiles.Length == 0)\n                {\n                    builtInPackagesWithoutSource.Add(packageDirectory.Name.ToLower());\n                    continue;\n                }\n\n                foreach (FileInfo fileInfo in asmDefFiles)\n                {\n                    AssemblyDefinitionInfo assemblyDefinitionInfo = AssemblyDefinitionInfo.Parse(fileInfo, this, null, true);\n                    asmDefInfoMap.Add(Path.GetFileNameWithoutExtension(fileInfo.Name), assemblyDefinitionInfo);\n                }\n            }\n\n            Dictionary<string, Assembly> unityAssemblies = CompilationPipeline.GetAssemblies().ToDictionary(t => t.name);\n            Dictionary<string, CSProjectInfo> projectsMap = new Dictionary<string, CSProjectInfo>();\n            Queue<string> projectsToProcess = new Queue<string>();\n            \n            foreach (KeyValuePair<string, Assembly> pair in unityAssemblies)\n            {\n                if (!asmDefInfoMap.TryGetValue(pair.Key, out AssemblyDefinitionInfo assemblyDefinitionInfo))\n                {\n                    string asmDefPath = CompilationPipeline.GetAssemblyDefinitionFilePathFromAssemblyName(pair.Key);\n                    if (string.IsNullOrEmpty(asmDefPath))\n                    {\n                        if (!pair.Key.StartsWith(\"Assembly-CSharp\"))\n                        {\n                            throw new InvalidOperationException($\"Failed to retrieve AsmDef for script assembly: {pair.Key}\");\n                        }\n\n                        assemblyDefinitionInfo = AssemblyDefinitionInfo.GetDefaultAssemblyCSharpInfo(pair.Value);\n                        projectsToProcess.Enqueue(pair.Key);\n                    }\n                    else\n                    {\n                        assemblyDefinitionInfo = AssemblyDefinitionInfo.Parse(new FileInfo(Utilities.GetFullPathFromKnownRelative(asmDefPath)), this, pair.Value);\n\n                        if (asmDefPath.StartsWith(\"Assets/\"))\n                        {\n                            \n                            projectsToProcess.Enqueue(pair.Key);\n                        }\n                    }\n\n                    asmDefInfoMap.Add(pair.Key, assemblyDefinitionInfo);\n                }\n            }\n\n            while (projectsToProcess.Count > 0)\n            {\n                string projectKey = projectsToProcess.Dequeue();\n\n                if (!projectsMap.ContainsKey(projectKey))\n                {\n                    GetProjectInfo(projectsMap, asmDefInfoMap, builtInPackagesWithoutSource, projectKey, projectOutputPath);\n                }\n            }\n\n            return projectsMap;\n        }\n\n        private CSProjectInfo GetProjectInfo(Dictionary<string, CSProjectInfo> projectsMap, Dictionary<string, AssemblyDefinitionInfo> asmDefInfoMap, HashSet<string> builtInPackagesWith"
}