{
    "code_repairing_0": "Fixed Code:\n\ufeff\n\nusing Microsoft.MixedReality.Toolkit.Utilities;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.SceneManagement;\n\nnamespace Microsoft.MixedReality.Toolkit.SceneSystem\n{\n    \n    \n    \n    \n    \n    [HelpURL(\"https:\n    public partial class MixedRealitySceneSystem : BaseCoreSystem, IMixedRealitySceneSystem\n    {\n        \n        \n        \n        \n        private enum SceneType\n        {\n            Manager = 0,\n            Content = 1,\n            Lighting = 2,\n        }\n\n        public MixedRealitySceneSystem(\n            IMixedRealityServiceRegistrar registrar,\n            MixedRealitySceneSystemProfile profile) : base(registrar, profile)\n        {\n            this.profile = profile;\n        }\n\n        private MixedRealitySceneSystemProfile profile;\n\n        \n        private bool managerSceneOpInProgress;\n        private float managerSceneOpProgress;\n\n        \n        private SceneContentTracker contentTracker;\n        \n        private SceneLightingExecutor lightingExecutor;\n\n        \n        public override string Name { get; protected set; } = \"Mixed Reality Scene System\";\n\n        #region Actions\n\n        \n        public Action<IEnumerable<string>> OnWillLoadContent { get; set; }\n\n        \n        public Action<IEnumerable<string>> OnContentLoaded { get; set; }\n\n        \n        public Action<IEnumerable<string>> OnWillUnloadContent { get; set; }\n\n        \n        public Action<IEnumerable<string>> OnContentUnloaded { get; set; }\n\n        \n        public Action<string> OnWillLoadLighting { get; set; }\n\n        \n        public Action<string> OnLightingLoaded { get; set; }\n\n        \n        public Action<string> OnWillUnloadLighting { get; set; }\n\n        \n        public Action<string> OnLightingUnloaded { get; set; }\n\n        \n        public Action<string> OnWillLoadScene { get; set; }\n\n        \n        public Action<string> OnSceneLoaded { get; set; }\n\n        \n        public Action<string> OnWillUnloadScene { get; set; }\n\n        \n        public Action<string> OnSceneUnloaded { get; set; }\n\n        #endregion\n\n        #region Properties\n\n        \n        public bool SceneOperationInProgress { get; private set; } = false;\n\n        \n        public float SceneOperationProgress { get; private set; } = 0;\n\n        \n        public bool LightingOperationInProgress { get; private set; } = false;\n\n        \n        public float LightingOperationProgress { get; private set; } = 0;\n\n        \n        public string ActiveLightingScene { get; private set; } = string.Empty;\n\n        \n        public bool WaitingToProceed { get; private set; } = false;\n\n        \n        public bool PrevContentExists => contentTracker.PrevContentExists;\n\n        \n        public bool NextContentExists => contentTracker.NextContentExists;\n\n        \n        public string[] ContentSceneNames => contentTracker.ContentSceneNames;\n\n        \n        public uint SourceId { get; } = 0;\n\n        \n        public string SourceName { get; } = \"Mixed Reality Scene System\";\n\n        #endregion\n\n        #region Service Methods\n\n        \n        public override void Initialize()\n        {\n            \n            contentTracker = new SceneContentTracker(profile);\n            lightingExecutor = new SceneLightingExecutor();\n\n#if UNITY_EDITOR\n            EditorOnInitialize();\n#endif\n\n            if (!Application.isPlaying)\n            {\n                return;\n            }\n\n            if (profile.UseManagerScene)\n            {\n                SetManagerScene(profile.ManagerScene.Name);\n            }\n\n            if (profile.UseLightingScene)\n            {   \n                SetLightingScene(profile.DefaultLightingScene.Name, LightingSceneTransitionType.None);\n            }\n        }\n\n        \n        public override void Enable()\n        {\n#if UNITY_EDITOR\n            EditorOnDisable();\n#endif\n        }\n\n        \n        public override void Disable()\n        {\n#if UNITY_EDITOR\n            EditorOnDisable();\n#endif\n        }\n\n        \n        public override void Destroy()\n        {\n#if UNITY_EDITOR\n            EditorOnDestroy();\n#endif\n        }\n\n        \n        public override void Update()\n        {\n            \n            if (profile.UseLightingScene)\n            {\n                lightingExecutor.UpdateTransition(Time.unscaledDeltaTime);\n            }\n        }\n\n        #endregion\n\n        #region Scene Operations\n\n        \n        public async Task LoadNextContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            string nextContent;\n            if (contentTracker.GetNextContent(wrap, out nextContent))\n            {\n                await LoadContent(new string[] { nextContent }, mode, activationToken);\n            }\n            else\n            {\n                Debug.LogWarning(\"Attempted to load next content when no next content exists. Taking no action.\");\n            }\n        }\n\n        \n        public async Task LoadPrevContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            string prevContent;\n            if (contentTracker.GetPrevContent(wrap, out prevContent))\n            {\n                await LoadContent(new string[] { prevContent }, mode, activationToken);\n            }\n            else\n            {\n                Debug.LogWarning(\"Attempted to load prev content when no next content exists. Taking no action.\");\n            }\n        }\n\n        \n        public async Task LoadContent(string sceneToLoad, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            await LoadContent(new string[] { sceneToLoad }, mode, activationToken);\n        }\n\n        \n        public async Task UnloadContent(string sceneToUnload)\n        {\n            await UnloadContent(new string[] { sceneToUnload });\n        }\n\n        \n        public async Task LoadContentByTag(string tag, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            await LoadContent(profile.GetContentSceneNamesByTag(tag), mode, activationToken);\n        }\n\n        \n        public async Task UnloadContentByTag(string tag)\n        {\n            await UnloadScenesInternal(profile.GetContentSceneNamesByTag(tag), SceneType.Content);\n        }\n\n        \n        public async Task LoadContent(IEnumerable<string> scenesToLoad, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            if (!CanSceneOpProceed(SceneType.Content))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            IEnumerable<string> loadedContentScenes;\n            if (mode == LoadSceneMode.Single && GetLoadedContentScenes(out loadedContentScenes))\n            {\n                await UnloadScenesInternal(loadedContentScenes, SceneType.Content, 0, 0.5f, true);\n                await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken, 0.5f, 1f, false);\n            }\n            else\n            {\n                await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken);\n            }\n\n            await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken);\n        }\n\n        \n        public async Task UnloadContent(IEnumerable<string> scenesToUnload)\n        {\n            if (!CanSceneOpProceed(SceneType.Content))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            await UnloadScenesInternal(scenesToUnload, SceneType.Content);\n        }\n\n        \n        public bool IsContentLoaded(string sceneName)\n        {\n            Scene scene = SceneManager.GetSceneByName(sceneName);",
    "code_repairing_1": "The code is part of a Unity project and defines a `MixedRealitySceneSystem` class that handles various scene-related operations. The class is not complete and is missing parts, such as the `EditorOnInitialize`, `EditorOnDisable`, and `EditorOnDestroy` methods, which are only defined in the Editor version of the code.\n\nThe `OnWillLoadContent`, `OnContentLoaded`, `OnWillUnloadContent`, and `OnContentUnloaded` properties are used to provide events for external components to listen to. These events are used to load and unload content scenes, which are scenes that contain specific content, such as level or game progression.\n\nThe `OnWillLoadLighting`, `OnLightingLoaded`, `OnWillUnloadLighting`, and `OnLightingUnloaded` properties are used to provide events for external components to listen to. These events are used to load and unload lighting scenes, which are scenes that contain runtime lighting settings, such as lighting, fog, and reflections.\n\nThe `OnWillLoadScene`, `OnSceneLoaded`, `OnWillUnloadScene`, and `OnSceneUnloaded` properties are used to provide events for external components to listen to. These events are used to load and unload any type of scene, including content and lighting scenes.\n\nThe `Initialize`, `Enable`, and `Disable` methods are used to initialize, enable, and disable the scene system. The `initialize` method is responsible for setting up the content tracker and lighting executor, and setting the active lighting scene if the profile specifies it.\n\nThe `WaitingToProceed` property is a boolean indicating whether the scene system is waiting for external components to proceed with scene loading or unloading.\n\nThe `PrevContentExists`, `NextContentExists`, and `ContentSceneNames` properties are used to provide information about the content scenes. The `PrevContentExists` property is a boolean indicating whether there is a previous content scene, and the `NextContentExists` property is a boolean indicating whether there is a next content scene. The `ContentSceneNames` property is an array of strings representing the names of all the content scenes.\n\nThe `LoadNextContent`, `LoadPrevContent`, `LoadContent`, `UnloadContent`, `LoadContentByTag`, `UnloadContentByTag`, and `SetLightingScene` methods are used to load and unload content and lighting scenes, respectively. These methods are responsible for updating the scene type progress and calling the appropriate events.\n\nThe `IsContentLoaded` method is used to determine whether a content scene is loaded.\n\nThe `SetManagerScene` method is used to set the manager scene, which is the scene that contains the manager script.\n\nThe `SceneOperationInProgress` and `SceneOperationProgress` properties are used to indicate whether a scene operation is in progress and to provide a progress value for the current scene operation. The `LightingOperationInProgress` and `LightingOperationProgress` properties are used to indicate whether a lighting operation is in progress and to provide a progress value for the current lighting operation.\n\nThe `ActiveLightingScene` property is used to return the name of the active lighting scene.\n\nThe `CanSceneOpProceed` method is used to determine whether a scene operation can proceed.\n\nThe `SetSceneOpProgress` method is used to set the progress of a scene operation.\n\nThe `InvokeWillLoadActions` method is used to invoke the appropriate will load actions for a scene operation.\n\nThe `LoadSceneOp` method is used to load a scene operation and invoke the appropriate will load action.\n\nThe `UnloadSceneOp` method is used to unload a scene operation and invoke the appropriate will unload action.\n\nThe `GetLoadedContentScenes` method is used to retrieve the list of loaded content scenes.\n\nThe `GetManagerScene` method is used to retrieve the manager scene.\n\nThe `GetLightingScene` method is used to retrieve the currently active lighting scene.\n\nThe `GetLightingSceneName` method is used to retrieve the name of the currently active lighting scene.\n\nThe `GetLightingSettings` method is used to retrieve the lighting settings for the currently active lighting scene.\n\nThe `GetRenderSettings` method is used to retrieve the render settings for the currently active lighting scene.\n\nThe `GetSunlightSettings` method is used to retrieve the sunlight settings for the currently active lighting scene.\n\nThe `GetContentSceneNames` method is used to retrieve an array of content scene names.\n\nThe `GetContentSceneIndex` method is used to retrieve the index of a content scene.\n\nThe `GetContentScene` method is used to retrieve a content scene.\n\nThe `GetLightingSceneIndex` method is used to retrieve the index of a lighting scene.\n\nThe `GetLightingScene` method is used to retrieve a lighting scene.\n\nThe `GetLightingSettingsByIndex` method is used to retrieve the lighting settings for a lighting scene.\n\nThe `RuntimeSceneUtils` is a utility class used to provide runtime scene manipulation functionality.\n\nThe `FindScene` method is used to find a scene by name.\n\nThe `SceneActivationToken` class is used to represent a scene activation token. It is used to provide a way for external components to allow a scene to activate or not.\n\nThe `SetReadyToProceed` method is used to set whether a scene activation token is ready to proceed.",
    "code_repairing_2": "````\n\ufeff\n\nusing Microsoft.MixedReality.Toolkit.Utilities;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.SceneManagement;\n\nnamespace Microsoft.MixedReality.Toolkit.SceneSystem\n{\n\n\n    [HelpURL(\"https:\n    public partial class MixedRealitySceneSystem : BaseCoreSystem, IMixedRealitySceneSystem\n    {\n        \n        \n        \n        \n        const float SceneActivationLoadProgress = 0.9f;\n\n        \n        \n        \n        private enum SceneType\n        {\n            Manager = 0,\n            Content = 1,\n            Lighting = 2,\n        }\n\n        public MixedRealitySceneSystem(\n            IMixedRealityServiceRegistrar registrar,\n            MixedRealitySceneSystemProfile profile) : base(registrar, profile)\n        {\n            this.profile = profile;\n        }\n\n        private MixedRealitySceneSystemProfile profile;\n\n        \n        private bool managerSceneOpInProgress;\n        private float managerSceneOpProgress;\n\n        \n        private SceneContentTracker contentTracker;\n        \n        private SceneLightingExecutor lightingExecutor;\n\n        \n        public override string Name { get; protected set; } = \"Mixed Reality Scene System\";\n\n        #region Actions\n\n        \n        public Action<IEnumerable<string>> OnWillLoadContent { get; set; }\n\n        \n        public Action<IEnumerable<string>> OnContentLoaded { get; set; }\n\n        \n        public Action<IEnumerable<string>> OnWillUnloadContent { get; set; }\n\n        \n        public Action<IEnumerable<string>> OnContentUnloaded { get; set; }\n\n        \n        public Action<string> OnWillLoadLighting { get; set; }\n\n        \n        public Action<string> OnLightingLoaded { get; set; }\n\n        \n        public Action<string> OnWillUnloadLighting { get; set; }\n\n        \n        public Action<string> OnLightingUnloaded { get; set; }\n\n        \n        public Action<string> OnWillLoadScene { get; set; }\n\n        \n        public Action<string> OnSceneLoaded { get; set; }\n\n        \n        public Action<string> OnWillUnloadScene { get; set; }\n\n        \n        public Action<string> OnSceneUnloaded { get; set; }\n\n        #endregion\n\n        #region Properties\n\n        \n        public bool SceneOperationInProgress { get; private set; } = false;\n\n        \n        public float SceneOperationProgress { get; private set; } = 0;\n\n        \n        public bool LightingOperationInProgress { get; private set; } = false;\n\n        \n        public float LightingOperationProgress { get; private set; } = 0;\n\n        \n        public string ActiveLightingScene { get; private set; } = string.Empty;\n\n        \n        public bool WaitingToProceed { get; private set; } = false;\n\n        \n        public bool PrevContentExists => contentTracker.PrevContentExists;\n\n        \n        public bool NextContentExists => contentTracker.NextContentExists;\n\n        \n        public string[] ContentSceneNames => contentTracker.ContentSceneNames;\n\n        \n        public uint SourceId { get; } = 0;\n\n        \n        public string SourceName { get; } = \"Mixed Reality Scene System\";\n\n        #endregion\n\n        #region Service Methods\n\n        \n        public override void Initialize()\n        {\n            \n            contentTracker = new SceneContentTracker(profile);\n            lightingExecutor = new SceneLightingExecutor();\n\n#if UNITY_EDITOR\n            EditorOnInitialize();\n#endif\n\n            if (!Application.isPlaying)\n            {\n                return;\n            }\n\n            if (profile.UseManagerScene)\n            {\n                SetManagerScene(profile.ManagerScene.Name);\n            }\n\n            if (profile.UseLightingScene)\n            {   \n                SetLightingScene(profile.DefaultLightingScene.Name, LightingSceneTransitionType.None);\n            }\n        }\n\n        \n        public override void Enable()\n        {\n#if UNITY_EDITOR\n            EditorOnDisable();\n#endif\n        }\n\n        \n        public override void Disable()\n        {\n#if UNITY_EDITOR\n            EditorOnDisable();\n#endif\n        }\n\n        \n        public override void Destroy()\n        {\n#if UNITY_EDITOR\n            EditorOnDestroy();\n#endif\n        }\n\n        \n        public override void Update()\n        {\n            \n            if (profile.UseLightingScene)\n            {\n                lightingExecutor.UpdateTransition(Time.unscaledDeltaTime);\n            }\n        }\n\n        #endregion\n\n        #region Scene Operations\n\n        \n        public async Task LoadNextContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            string nextContent;\n            if (contentTracker.GetNextContent(wrap, out nextContent))\n            {\n                await LoadContent(new string[] { nextContent }, mode, activationToken);\n            }\n            else\n            {\n                Debug.LogWarning(\"Attempted to load next content when no next content exists. Taking no action.\");\n            }\n        }\n\n        \n        public async Task LoadPrevContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            string prevContent;\n            if (contentTracker.GetPrevContent(wrap, out prevContent))\n            {\n                await LoadContent(new string[] { prevContent }, mode, activationToken);\n            }\n            else\n            {\n                Debug.LogWarning(\"Attempted to load prev content when no next content exists. Taking no action.\");\n            }\n        }\n\n        \n        public async Task LoadContent(string sceneToLoad, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            await LoadContent(new string[] { sceneToLoad }, mode, activationToken);\n        }\n\n        \n        public async Task UnloadContent(string sceneToUnload)\n        {\n            await UnloadContent(new string[] { sceneToUnload });\n        }\n\n        \n        public async Task LoadContentByTag(string tag, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            await LoadContent(profile.GetContentSceneNamesByTag(tag), mode, activationToken);\n        }\n\n        \n        public async Task UnloadContentByTag(string tag)\n        {\n            await UnloadScenesInternal(profile.GetContentSceneNamesByTag(tag), SceneType.Content);\n        }\n\n        \n        public async Task LoadContent(IEnumerable<string> scenesToLoad, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            if (!CanSceneOpProceed(SceneType.Content))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            IEnumerable<string> loadedContentScenes;\n            if (mode == LoadSceneMode.Single && GetLoadedContentScenes(out loadedContentScenes))\n            {\n                await UnloadScenesInternal(loadedContentScenes, SceneType.Content, 0, 0.5f, true);\n                await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken, 0.5f, 1f, false);\n            }\n            else\n            {\n                await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken);\n            }\n\n            await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken);\n        }\n\n        \n        public async Task UnloadContent(IEnumerable<string> scenesToUnload)\n        {\n            if (!CanSceneOpProceed(SceneType.Content))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            await UnloadScenesInternal(scenesToUnload, SceneType.Content);\n        }\n\n        \n        public bool IsContentLoaded(string sceneName)\n        {\n            Scene",
    "code_repairing_3": "```\n\npublic async Task LoadScenesInternal(\n    IEnumerable<string> scenesToLoad,\n    SceneType sceneType,\n    SceneActivationToken activationToken = null,\n    float progressOffset = 0,\n    float progressTarget = 1,\n    bool sceneOpInProgressWhenFinished = false)\n{\n\n    activationToken?.SetReadyToProceed(false);\n\n    SetSceneOpProgress(true, progressOffset, sceneType);\n\n    List<string> validNames = new List<string>();\n    List<int> validIndexes = new List<int>();\n\n    foreach (string sceneName in scenesToLoad)\n    {\n        Scene scene;\n        int sceneIndex;\n        if (!RuntimeSceneUtils.FindScene(sceneName, out scene, out sceneIndex))\n        {\n            Debug.LogError(\"Can't load invalid scene \" + sceneName);\n        }\n        else\n        {\n            validIndexes.Add(sceneIndex);\n            validNames.Add(sceneName);\n        }\n    }\n\n    int totalSceneOps = validIndexes.Count;\n    if (totalSceneOps < 1)\n    {\n        Debug.LogWarning(\"No valid scenes found to load.\");\n        SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n        return;\n    }\n\n    InvokeWillLoadActions(validNames, sceneType);\n\n    if (validIndexes.Count > 0)\n    {\n        List<AsyncOperation> loadSceneOps = new List<AsyncOperation>();\n        foreach (int sceneIndex in validIndexes)\n        {\n            Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n            if (scene.isLoaded)\n                continue;\n\n            AsyncOperation sceneOp = SceneManager.LoadSceneAsync(sceneIndex, LoadSceneMode.Additive);\n\n            sceneOp.allowSceneActivation = (activationToken != null) ? activationToken.AllowSceneActivation : true;\n            loadSceneOps.Add(sceneOp);\n        }\n\n        bool completedAllSceneOps = false;\n\n        while (!completedAllSceneOps)\n        {\n            if (!Application.isPlaying)\n            {\n                return;\n            }\n\n            completedAllSceneOps = true;\n            bool readyToProceed = false;\n            bool allowSceneActivation = (activationToken != null) ? activationToken.AllowSceneActivation : true;\n\n            float sceneOpProgress = 0;\n            for (int i = 0; i < loadSceneOps.Count; i++)\n            {\n\n                loadSceneOps[i].allowSceneActivation = allowSceneActivation;\n\n                if (loadSceneOps[i].isDone)\n                {\n                    sceneOpProgress += 1;\n                }\n                else\n                {\n                    readyToProceed |= loadSceneOps[i].progress >= SceneActivationLoadProgress;\n                    sceneOpProgress += loadSceneOps[i].progress;\n                    completedAllSceneOps = false;\n                }\n            }\n\n            activationToken?.SetReadyToProceed(readyToProceed);\n\n            sceneOpProgress = Mathf.Clamp01(SceneOperationProgress / totalSceneOps);\n\n            SetSceneOpProgress(true, Mathf.Lerp(progressOffset, progressTarget, sceneOpProgress), sceneType);\n\n            await Task.Yield();\n        }\n    }\n\n    bool scenesLoadedAndActivated = false;\n    while (!scenesLoadedAndActivated)\n    {\n        if (!Application.isPlaying)\n        {\n            return;\n        }\n\n        scenesLoadedAndActivated = true;\n        foreach (int sceneIndex in validIndexes)\n        {\n            Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n\n            if (!scene.isLoaded)\n            {\n                scenesLoadedAndActivated = false;\n                break;\n            }\n        }\n\n        if (scenesLoadedAndActivated)\n        {\n            InvokeDidLoadActions(validNames, sceneType);\n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n        }\n    }\n}\n```",
    "code_repairing_4": "private async Task LoadScenesInternal(\n            IEnumerable<string> scenesToLoad,\n            SceneType sceneType,\n            SceneActivationToken activationToken = null,\n            float progressOffset = 0,\n            float progressTarget = 1,\n            bool sceneOpInProgressWhenFinished = false)\n        {\n            ...\n        }\n        private async void SetLightingScene(string newLightingSceneName, LightingSceneTransitionType transitionType = LightingSceneTransitionType.None, float transitionDuration = 1f)\n        {\n            ...\n            await Task.Yield();\n        }\n        private async void LoadNextContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            ...\n            await Task.Yield();\n        }\n        private async void UnloadContent(IEnumerable<string> scenesToUnload)\n        {\n            ...\n            await Task.Yield();\n        }\n        private bool CanSceneOpProceed(SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    return !managerSceneOpInProgress || (managerSceneOpInProgress && managerSceneOpProgress >= SceneActivationLoadProgress);\n                case SceneType.Lighting:\n                    return !lightingOperationInProgress || (lightingOperationInProgress && lightingOperationProgress >= SceneActivationLoadProgress);\n                default:\n                    return false;\n            }\n        }\n    }\n}"
}