{"id": "chatcmpl-9yVAkb1DqTPw6e6sy1oifkUAyyHYw", "object": "chat.completion", "created": 1724206534, "model": "gpt-35-turbo", "choices": [{"index": 0, "message": {"role": "assistant", "content": "scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded);\n                }\n\n                \n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n\n                \n                InvokeContentActions(validNames, sceneType);\n\n                await Task.Yield();\n            }\n        }\n\n        \n        \n        private async Task UnloadScenesInternal(IEnumerable<string> scenesToUnload, SceneType sceneType, float progressOffset = 0, float progressTarget = 1, bool sceneOpInProgressWhenFinished = false)\n        {\n            \n            SetSceneOpProgress(true, progressOffset, sceneType);\n\n            \n            List<string> validNames = new List<string>();\n            List<int> validIndexes = new List<int>();\n\n            foreach (string sceneName in scenesToUnload)\n            {\n                \n                Scene scene;\n                int sceneIndex;\n                if (!RuntimeSceneUtils.FindScene(sceneName, out scene, out sceneIndex))\n                {\n                    Debug.LogError(\"Can't unload invalid scene \" + sceneName);\n                }\n                else\n                {\n                    validIndexes.Add(sceneIndex);\n                    validNames.Add(sceneName);\n                }\n            }\n\n            int totalSceneOps = validIndexes.Count;\n            if (totalSceneOps < 1)\n            {\n                Debug.LogWarning(\"No valid scenes found to unload.\");\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n            \n            InvokeWillUnloadActions(validNames, sceneType);\n\n            \n            if (validIndexes.Count > 0)\n            {\n                List<AsyncOperation> unloadSceneOps = new List<AsyncOperation>();\n                foreach (int sceneIndex in validIndexes)\n                {\n                    Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                    if (!scene.isLoaded)\n                        continue;\n\n                    AsyncOperation sceneOp = SceneManager.UnloadSceneAsync(sceneIndex);\n                    unloadSceneOps.Add(sceneOp);\n                }\n\n                \n                bool completedAllSceneOps = false;\n\n                while (!completedAllSceneOps)\n                {\n                    if (!Application.isPlaying)\n                    {   \n                        return;\n                    }\n\n                    completedAllSceneOps = true;\n                    float sceneOpProgress = 0;\n                    for (int i = 0; i < unloadSceneOps.Count; i++)\n                    {\n                        if (unloadSceneOps[i].isDone)\n                        {\n                            sceneOpProgress += 1;\n                        }\n                        else\n                        {\n                            sceneOpProgress += unloadSceneOps[i].progress;\n                            completedAllSceneOps = false;\n                        }\n                    }\n\n                    \n                    SetSceneOpProgress(true, Mathf.Lerp(progressOffset, progressTarget, sceneOpProgress / totalSceneOps), sceneType);\n\n                    await Task.Yield();\n                }\n            }\n\n            \n            bool scenesUnloaded = false;\n            while (!scenesUnloaded)\n            {\n                if (!Application.isPlaying)\n                {   \n                    return;\n                }\n\n                scenesUnloaded = true;\n                foreach (int sceneIndex in validIndexes)\n                {\n                    Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                    scenesUnloaded &= !scene.IsValid();\n                }\n\n                \n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n\n                \n                InvokeContentActions(validNames, sceneType);\n\n                await Task.Yield();\n            }\n        }\n\n        \n        private bool CanSceneOpProceed(SceneType type)\n        {\n            if (SceneOperationInProgress || LightingOperationInProgress)\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return false;\n            }\n\n            if (type == SceneType.Content)\n            {\n                if (WaitingToProceed)\n                {\n                    Debug.Log(\"Waiting on content\");\n                    return false;\n                }\n                \n                if (!managerSceneOpInProgress)\n                {\n                    Debug.LogError(\"No content scene can be loaded/unloaded without first loading the manager scene.\");\n                    return false;\n                }\n            }\n\n            if (type == SceneType.Lighting)\n            {\n                if (!ContentIsInScene(profile.ManagerScene))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        \n        private void SetSceneOpProgress(bool inProgress, float progress, SceneType type)\n        {\n            SceneOperationInProgress = type == SceneType.Content ? inProgress : SceneOperationInProgress;\n            LightingOperationInProgress = type == SceneType.Lighting ? inProgress : LightingOperationInProgress;\n\n            SceneOperationProgress = type == SceneType.Content ? progress : SceneOperationProgress;\n            LightingOperationProgress = type == SceneType.Lighting ? progress : LightingOperationProgress;\n        }\n\n        \n        private void InvokeWillLoadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnWillLoadContent?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnWillLoadLighting?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private void InvokeContentActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnContentLoaded?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnLightingLoaded?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private void InvokeWillUnloadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnWillUnloadContent?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnWillUnloadLighting?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private bool GetLoadedContentScenes(out IEnumerable<string> contentSceneNames)\n        {\n            contentSceneNames = contentTracker.ContentSceneNames;\n            return contentSceneNames.Any();\n        }\n\n        \n        private bool ContentIsInScene(SceneInfo sceneInfo)\n        {\n            return SceneManager.GetSceneByBuildIndex(profile.ManagerScene.BuildIndex).isLoaded;\n        }\n    }\n}\n\"\"\""}, "logprobs": null, "finish_reason": "stop"}, {"index": 1, "message": {"role": "assistant", "content": "scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded);\n                }\n\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n\n                InvokeLoadedActions(validNames, sceneType);\n\n                break;\n            }\n        }\n\n        \n        private async Task UnloadScenesInternal(IEnumerable<string> scenesToUnload, SceneType sceneType, float progressOffset = 0, float progressTarget = 1, bool sceneOpInProgressWhenFinished = false)\n        {\n            SetSceneOpProgress(true, progressOffset, sceneType);\n\n            List<string> validNames = new List<string>();\n            List<int> validIndexes = new List<int>();\n\n            foreach (string sceneName in scenesToUnload)\n            {\n                Scene scene;\n                int sceneIndex;\n                if (!RuntimeSceneUtils.FindScene(sceneName, out scene, out sceneIndex))\n                {\n                    Debug.LogError(\"Can't unload invalid scene \" + sceneName);\n                }\n                else\n                {\n                    validIndexes.Add(sceneIndex);\n                    validNames.Add(sceneName);\n                }\n            }\n\n            int totalSceneOps = validIndexes.Count;\n            if (totalSceneOps < 1)\n            {\n                Debug.LogWarning(\"No valid scenes found to unload.\");\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n            InvokeWillUnloadActions(validNames, sceneType);\n\n            if (validIndexes.Count > 0)\n            {\n                foreach (int sceneIndex in validIndexes)\n                {\n                    Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n\n                    if (!scene.isLoaded)\n                        continue;\n\n                    AsyncOperation sceneOp = SceneManager.UnloadSceneAsync(sceneIndex);\n\n                    bool completedSceneOp = false;\n\n                    while (!completedSceneOp)\n                    {\n                        if (!Application.isPlaying)\n                        {\n                            return;\n                        }\n\n                        completedSceneOp = sceneOp.isDone;\n                        await Task.Yield();\n                    }\n                }\n            }\n\n            InvokeUnloadedActions(validNames, sceneType);\n\n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n        }\n\n        \n        private void InvokeWillLoadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    {\n                        OnWillLoadLighting?.Invoke(sceneNames.LastOrDefault());\n                        break;\n                    }\n                case SceneType.Content:\n                    {\n                        OnWillLoadContent?.Invoke(sceneNames);\n                        break;\n                    }\n                case SceneType.Lighting:\n                    {\n                        OnWillLoadLighting?.Invoke(sceneNames.LastOrDefault());\n                        break;\n                    }\n            }\n        }\n\n        \n        private void InvokeLoadedActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    {\n                        OnSceneLoaded?.Invoke(sceneNames.LastOrDefault());\n                        break;\n                    }\n                case SceneType.Content:\n                    {\n                        OnContentLoaded?.Invoke(sceneNames);\n                        break;\n                    }\n                case SceneType.Lighting:\n                    {\n                        OnLightingLoaded?.Invoke(sceneNames.LastOrDefault());\n                        break;\n                    }\n            }\n        }\n\n        \n        private void InvokeWillUnloadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    {\n                        OnWillUnloadLighting?.Invoke(sceneNames.LastOrDefault());\n                        break;\n                    }\n                case SceneType.Content:\n                    {\n                        OnWillUnloadContent?.Invoke(sceneNames);\n                        break;\n                    }\n                case SceneType.Lighting:\n                    {\n                        OnWillUnloadLighting?.Invoke(sceneNames.LastOrDefault());\n                        break;\n                    }\n            }\n        }\n\n        \n        private void InvokeUnloadedActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    {\n                        OnSceneUnloaded?.Invoke(sceneNames.LastOrDefault());\n                        break;\n                    }\n                case SceneType.Content:\n                    {\n                        OnContentUnloaded?.Invoke(sceneNames);\n                        break;\n                    }\n                case SceneType.Lighting:\n                    {\n                        OnLightingUnloaded?.Invoke(sceneNames.LastOrDefault());\n                        break;\n                    }\n            }\n        }\n\n        \n        private bool CanSceneOpProceed(SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    return !managerSceneOpInProgress;\n                case SceneType.Content:\n                    return !SceneOperationInProgress;\n                case SceneType.Lighting:\n                    return !LightingOperationInProgress;\n                default:\n                    return false;\n            }\n        }\n\n        \n        private void SetSceneOpProgress(bool inProgress, float progress, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    managerSceneOpInProgress = inProgress;\n                    managerSceneOpProgress = progress;\n                    break;\n                case SceneType.Content:\n                    SceneOperationInProgress = inProgress;\n                    SceneOperationProgress = progress;\n                    break;\n                case SceneType.Lighting:\n                    LightingOperationInProgress = inProgress;\n                    LightingOperationProgress = progress;\n                    break;\n            }\n        }\n    }\n}"}, "logprobs": null, "finish_reason": "stop"}, {"index": 2, "message": {"role": "assistant", "content": "                        scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded);\n                }\n\n                if (!scenesLoadedAndActivated)\n                {\n                    await Task.Yield();\n                }\n            }\n\n            \n            InvokeLoadedActions(validNames, sceneType);\n\n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n        }\n\n        \n        private async Task UnloadScenesInternal(IEnumerable<string> scenesToUnload, SceneType sceneType, float progressOffset = 0, float progressTarget = 1, bool sceneOpInProgressWhenFinished = false)\n        {\n            \n            SetSceneOpProgress(true, progressOffset, sceneType);\n\n            List<Scene> scenes = new List<Scene>();\n            foreach (string sceneName in scenesToUnload)\n            {\n                Scene scene = SceneManager.GetSceneByName(sceneName);\n                if (scene.IsValid())\n                {\n                    scenes.Add(scene);\n                }\n                else\n                {\n                    Debug.LogWarning(\"Unload failed - Can't find valid scene with the name: \" + sceneName);\n                }\n            }\n\n            if (scenes.Count == 0)\n            {\n                \n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n            InvokeWillUnloadActions(scenesToUnload, sceneType);\n\n            \n            List<AsyncOperation> unloadOperations = new List<AsyncOperation>();\n            foreach (var scene in scenes)\n            {\n                AsyncOperation unloadOperation = SceneManager.UnloadSceneAsync(scene);\n\n                unloadOperations.Add(unloadOperation);\n            }\n\n            bool allUnloaded = false;\n            while (!allUnloaded)\n            {\n                if (!Application.isPlaying)\n                {   \n                    return;\n                }\n\n                allUnloaded = true;\n                foreach (var unloadOp in unloadOperations)\n                {\n                    allUnloaded &= unloadOp.isDone;\n                }\n\n                if (!allUnloaded)\n                {\n                    await Task.Yield();\n                }\n            }\n\n            InvokeUnloadedActions(scenesToUnload, sceneType);\n\n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n        }\n\n        \n        private void InvokeWillLoadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    OnWillLoadScene?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n                case SceneType.Content:\n                    OnWillLoadContent?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnWillLoadLighting?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private void InvokeLoadedActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    OnSceneLoaded?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n                case SceneType.Content:\n                    OnContentLoaded?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnLightingLoaded?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private void InvokeWillUnloadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    OnWillUnloadScene?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n                case SceneType.Content:\n                    OnWillUnloadContent?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnWillUnloadLighting?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private void InvokeUnloadedActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    OnSceneUnloaded?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n                case SceneType.Content:\n                    OnContentUnloaded?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnLightingUnloaded?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private bool CanSceneOpProceed(SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    return !SceneOperationInProgress && !managerSceneOpInProgress;\n                case SceneType.Content:\n                    return !SceneOperationInProgress;\n                case SceneType.Lighting:\n                    return !LightingOperationInProgress;\n\n                default:\n                    return true;   \n            }\n        }\n\n        \n        private void SetSceneOpProgress(bool keepSceneOpInProgress, float progress, SceneType sceneType)\n        {\n            \n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    managerSceneOpProgress = progress;\n                    managerSceneOpInProgress = keepSceneOpInProgress;\n                    break;\n                case SceneType.Content:\n                    SceneOperationProgress = progress;\n                    SceneOperationInProgress = keepSceneOpInProgress;\n                    break;\n                case SceneType.Lighting:\n                    LightingOperationProgress = progress;\n                    LightingOperationInProgress = keepSceneOpInProgress;\n                    break;\n            }\n        }\n\n        \n        private bool GetLoadedContentScenes(out IEnumerable<string> loadedContentScenes)\n        {\n            loadedContentScenes = contentTracker.ContentSceneNames\n                .Where(sceneName => IsContentLoaded(sceneName));\n\n            return loadedContentScenes.Any();\n        }\n\n#endregion\n    }\n}"}, "logprobs": null, "finish_reason": "stop"}, {"index": 3, "message": {"role": "assistant", "content": "                    scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded);\n                }\n\n                \n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                InvokeContentLoadedActions(validNames, sceneType);\n\n                activationToken?.SetReadyToProceed(true);\n\n                if (sceneOpInProgressWhenFinished)\n                {\n                    \n                    SetSceneOpProgress(false, 0, sceneType);\n                }\n\n                return;\n            }\n        }\n\n        \n        private async Task UnloadScenesInternal(\n            IEnumerable<string> scenesToUnload,\n            SceneType sceneType,\n            float progressOffset = 0,\n            float progressTarget = 1,\n            bool sceneOpInProgressWhenFinished = false)\n        {\n            \n            SetSceneOpProgress(true, progressOffset, sceneType);\n\n            \n            List<string> validNames = new List<string>();\n            List<int> validIndexes = new List<int>();\n\n            foreach (string sceneName in scenesToUnload)\n            {\n                Scene scene;\n                int sceneIndex;\n                if (!RuntimeSceneUtils.FindScene(sceneName, out scene, out sceneIndex))\n                {\n                    Debug.LogError(\"Can't unload invalid scene \" + sceneName);\n                }\n                else\n                {\n                    validIndexes.Add(sceneIndex);\n                    validNames.Add(sceneName);\n                }\n            }\n\n            int totalSceneOps = validIndexes.Count;\n            if (totalSceneOps < 1)\n            {\n                Debug.LogWarning(\"No valid scenes found to unload.\");\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n            \n            InvokeWillUnloadActions(validNames, sceneType);\n\n            \n            if (validIndexes.Count > 0)\n            {\n                List<AsyncOperation> unloadSceneOps = new List<AsyncOperation>();\n                foreach (int sceneIndex in validIndexes)\n                {\n                    Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                    if (!scene.isLoaded)\n                        continue;\n\n                    AsyncOperation sceneOp = SceneManager.UnloadSceneAsync(sceneIndex);\n                    unloadSceneOps.Add(sceneOp);\n                }\n\n                bool completedAllSceneOps = false;\n\n                while (!completedAllSceneOps)\n                {\n                    if (!Application.isPlaying)\n                    {\n                        return;\n                    }\n\n                    completedAllSceneOps = true;\n                    for (int i = 0; i < unloadSceneOps.Count; i++)\n                    {\n                        if (!unloadSceneOps[i].isDone)\n                        {\n                            completedAllSceneOps = false;\n                            break;\n                        }\n                    }\n\n                    SetSceneOpProgress(true, progressTarget, sceneType);\n\n                    await Task.Yield();\n                }\n            }\n\n            \n            InvokeContentUnloadedActions(validNames, sceneType);\n\n            if (sceneOpInProgressWhenFinished)\n            {\n                \n                SetSceneOpProgress(false, 0, sceneType);\n            }\n        }\n\n        \n        private bool CanSceneOpProceed(SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    return !managerSceneOpInProgress;\n                case SceneType.Content:\n                    return !SceneOperationInProgress;\n                case SceneType.Lighting:\n                    return !LightingOperationInProgress;\n                default:\n                    return true;\n            }\n        }\n\n        \n        private void InvokeWillLoadActions(IEnumerable<string> scenesToLoad, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnWillLoadContent?.Invoke(scenesToLoad);\n                    break;\n                case SceneType.Lighting:\n                    OnWillLoadLighting?.Invoke(scenesToLoad.FirstOrDefault());\n                    break;\n                case SceneType.Manager:\n                default:\n                    OnWillLoadScene?.Invoke(scenesToLoad.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private void InvokeContentLoadedActions(IEnumerable<string> scenesLoaded, SceneType sceneType)\n        {\n            \n            SetSceneOpProgress(false, 1, sceneType);\n\n            \n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnContentLoaded?.Invoke(scenesLoaded);\n                    break;\n                case SceneType.Lighting:\n                    OnLightingLoaded?.Invoke(scenesLoaded.FirstOrDefault());\n                    break;\n                case SceneType.Manager:\n                default:\n                    OnSceneLoaded?.Invoke(scenesLoaded.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private void InvokeWillUnloadActions(IEnumerable<string> scenesToUnload, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnWillUnloadContent?.Invoke(scenesToUnload);\n                    break;\n                case SceneType.Lighting:\n                    OnWillUnloadLighting?.Invoke(scenesToUnload.FirstOrDefault());\n                    break;\n                case SceneType.Manager:\n                default:\n                    OnWillUnloadScene?.Invoke(scenesToUnload.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private void InvokeContentUnloadedActions(IEnumerable<string> scenesUnloaded, SceneType sceneType)\n        {\n            \n            SetSceneOpProgress(false, 1, sceneType);\n\n            \n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnContentUnloaded?.Invoke(scenesUnloaded);\n                    break;\n                case SceneType.Lighting:\n                    OnLightingUnloaded?.Invoke(scenesUnloaded.FirstOrDefault());\n                    break;\n                case SceneType.Manager:\n                default:\n                    OnSceneUnloaded?.Invoke(scenesUnloaded.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private async void SetSceneOpProgress(bool sceneOpInProgress, float progress, SceneType sceneType)\n        {\n            SceneOperationInProgress = sceneOpInProgress;\n            SceneOperationProgress = progress;\n\n            if (sceneType == SceneType.Lighting)\n            {\n                LightingOperationInProgress = sceneOpInProgress;\n                LightingOperationProgress = progress;\n            }\n\n            if (sceneType == SceneType.Manager)\n            {\n                managerSceneOpInProgress = sceneOpInProgress;\n                managerSceneOpProgress = progress;\n            }\n\n            if (sceneOpInProgress)\n            {\n                WaitingToProceed = true;\n                await Task.Yield();\n            }\n            else\n            {\n                WaitingToProceed = false;\n            }\n        }\n\n        \n        private bool GetLoadedContentScenes(out IEnumerable<string> loadedContentScenes)\n        {\n            List<string> loadedScenes = new List<string>();\n            for (int i = 0; i < SceneManager.sceneCount; i++)\n            {\n                Scene scene = SceneManager.GetSceneAt(i);\n                if (scene.IsValid() && scene.isLoaded &&\n                    scene.buildIndex != profile.ManagerScene.BuildIndex &&\n                    scene.buildIndex != profile.DefaultLightingScene.BuildIndex &&\n                    !profile.GetLightingSceneNames().Contains(scene.name))\n                {\n                    loadedScenes.Add(scene.name);\n                }\n            }\n\n            loadedContentScenes = loadedScenes;\n            return loadedScenes.Count > 0;\n        }\n    }\n}\n\"\"\"\n\n"}, "logprobs": null, "finish_reason": "stop"}, {"index": 4, "message": {"role": "assistant", "content": "```csharp\n                        scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded);\n```"}, "logprobs": null, "finish_reason": "stop"}], "usage": {"prompt_tokens": 2864, "completion_tokens": 4683, "total_tokens": 7547}, "system_fingerprint": "fp_e49e4201a9"}