{
    "code_repairing_0": "The bug in the code is caused by the use of the `Instantiate()` method in the `Update()` method. This method should not be used in the `Update()` method because it is an expensive operation and can lead to performance issues.\n\nThe recommended way to create Prefabs in Unity is to use the `GameObject.Instantiate()` method in the `Start()` or `Awake()` method, while the `GetComponent()` method can be used in the `Update()` method to retrieve a reference to the Prefab. This makes the code more efficient and improves the overall performance of the application.\n\nHere is the fixed code:\n\n// Here's the definition of function call in another component.\n// Related code from / Assets / XR Interaction Toolkit / 3.0.6 / Starter Assets / Scripts / ObjectSpawner.cs:\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine.XR.Interaction.Toolkit.Utilities;\n\nnamespace UnityEngine.XR.Interaction.Toolkit.Samples.StarterAssets\n{\n\n\n\n    public class ObjectSpawner : MonoBehaviour\n    {\n        [SerializeField]\n        [Tooltip(\"The camera that objects will face when spawned. If not set, defaults to the main camera.\")]\n        Camera m_CameraToFace;\n\n\n\n\n        public Camera cameraToFace\n        {\n            get\n            {\n                EnsureFacingCamera();\n                return m_CameraToFace;\n            }\n            set => m_CameraToFace = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The list of prefabs available to spawn.\")]\n        List<GameObject> m_ObjectPrefabs = new List<GameObject>();\n\n\n\n\n        public List<GameObject> objectPrefabs\n        {\n            get => m_ObjectPrefabs;\n            set => m_ObjectPrefabs = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"Optional prefab to spawn for each spawned object. Use a prefab with the Destroy Self component to make \" +\n            \"sure the visualization only lives temporarily.\")]\n        GameObject m_SpawnVisualizationPrefab;\n\n\n\n\n\n        public GameObject spawnVisualizationPrefab\n        {\n            get => m_SpawnVisualizationPrefab;\n            set => m_SpawnVisualizationPrefab = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The index of the prefab to spawn. If outside the range of the list, this behavior will select \" +\n            \"a random object each time it spawns.\")]\n        int m_SpawnOptionIndex = -1;\n\n\n\n\n\n\n        public int spawnOptionIndex\n        {\n            get => m_SpawnOptionIndex;\n            set => m_SpawnOptionIndex = value;\n        }\n\n\n\n\n\n\n        public bool isSpawnOptionRandomized => m_SpawnOptionIndex < 0 || m_SpawnOptionIndex >= m_ObjectPrefabs.Count;\n\n        [SerializeField]\n        [Tooltip(\"Whether to only spawn an object if the spawn point is within view of the camera.\")]\n        bool m_OnlySpawnInView = true;\n\n\n\n\n        public bool onlySpawnInView\n        {\n            get => m_OnlySpawnInView;\n            set => m_OnlySpawnInView = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The size, in viewport units, of the periphery inside the viewport that will not be considered in view.\")]\n        float m_ViewportPeriphery = 0.15f;\n\n\n\n\n        public float viewportPeriphery\n        {\n            get => m_ViewportPeriphery;\n            set => m_ViewportPeriphery = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"When enabled, the object will be rotated about the y-axis when spawned by Spawn Angle Range, \" +\n            \"in relation to the direction of the spawn point to the camera.\")]\n        bool m_ApplyRandomAngleAtSpawn = true;\n\n\n\n\n\n        public bool applyRandomAngleAtSpawn\n        {\n            get => m_ApplyRandomAngleAtSpawn;\n            set => m_ApplyRandomAngleAtSpawn = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The range in degrees that the object will randomly be rotated about the y axis when spawned, \" +\n            \"in relation to the direction of the spawn point to the camera.\")]\n        float m_SpawnAngleRange = 45f;\n\n\n\n\n\n        public float spawnAngleRange\n        {\n            get => m_SpawnAngleRange;\n            set => m_SpawnAngleRange = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"Whether to spawn each object as a child of this object.\")]\n        bool m_SpawnAsChildren;\n\n\n\n\n        public bool spawnAsChildren\n        {\n            get => m_SpawnAsChildren;\n            set => m_SpawnAsChildren = value;\n        }\n\n\n\n\n\n        public event Action<GameObject> objectSpawned;\n\n\n\n\n        void Awake()\n        {\n            EnsureFacingCamera();\n        }\n\n        void EnsureFacingCamera()\n        {\n            if (m_CameraToFace == null)\n                m_CameraToFace = Camera.main;\n        }\n\n\n\n\n\n\n        public void RandomizeSpawnOption()\n        {\n            m_SpawnOptionIndex = -1;\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    // Here's the buggy code lines from / Assets / XR Interaction Toolkit / 3.0.6 / AR Starter Assets / Scripts / ARInteractorSpawnTrigger.cs:\n    #if AR_FOUNDATION_PRESENT\n    using UnityEngine.EventSystems;\n    using UnityEngine.XR.ARFoundation;\n    using UnityEngine.XR.ARSubsystems;\n    using UnityEngine.XR.Interaction.Toolkit.Inputs.Readers;\n    using UnityEngine.XR.Interaction.Toolkit.Interactors;\n    using UnityEngine.XR.Interaction.Toolkit.Samples.StarterAssets;\n\n    namespace UnityEngine.XR.Interaction.Toolkit.Samples.ARStarterAssets\n    {\n\n\n\n        public class ARInteractorSpawnTrigger : MonoBehaviour\n        {\n\n\n\n            public enum SpawnTriggerType\n            {\n\n\n\n\n                SelectAttempt,\n\n\n\n\n                InputAction,\n            }\n\n            [SerializeField]\n            [Tooltip(\"The AR ray interactor that determines where to spawn the object.\")]\n            XRRayInteractor m_ARInteractor;\n\n\n\n\n            public XRRayInteractor arInteractor\n            {\n                get => m_ARInteractor;\n                set => m_ARInteractor = value;\n            }\n\n            [SerializeField]\n            [Tooltip(\"The behavior to use to spawn objects.\")]\n            ObjectSpawner m_ObjectSpawner;\n\n\n\n\n            public ObjectSpawner objectSpawner\n            {\n                get => m_ObjectSpawner;\n                set => m_ObjectSpawner = value;\n            }\n\n            [SerializeField]\n            [Tooltip(\"Whether to require that the AR Interactor hits an AR Plane with a horizontal up alignment in order to spawn anything.\")]\n            bool m_RequireHorizontalUpSurface;\n\n\n\n\n\n            public bool requireHorizontalUpSurface\n            {\n                get => m_RequireHorizontalUpSurface;\n                set => m_RequireHorizontalUpSurface = value;\n            }\n\n            [SerializeField]\n            [Tooltip(\"The type of trigger to use to spawn an object, either when the Interactor's select action occurs or \" +\n                \"when a button input is performed.\")]\n            SpawnTriggerType m_SpawnTriggerType;\n\n\n\n\n            public SpawnTriggerType spawnTriggerType\n            {\n                get => m_SpawnTriggerType;\n                set => m_SpawnTriggerType = value;\n            }\n\n            [SerializeField]\n            XRInputButtonReader m_SpawnObjectInput = new XRInputButtonReader(\"Spawn Object\");\n\n\n\n\n            public XRInputButtonReader spawnObjectInput\n            {\n                get => m_SpawnObjectInput;\n                set => XRInputReaderUtility.SetInputProperty(ref m_SpawnObjectInput, value, this);\n            }\n\n            [SerializeField]\n            [Tooltip(\"When enabled, spawn will not be triggered if an object is currently selected.\")]\n            bool m_BlockSpawnWhenInteractorHasSelection = true;\n\n\n\n\n            public bool blockSpawnWhenInteractorHasSelection\n            {\n                get => m_BlockSpawnWhenInteractorHasSelection;\n                set => m_BlockSpawnWhenInteractorHasSelection = value;\n            }\n\n            bool m_AttemptSpawn;\n            bool m_EverHadSelection;\n\n\n\n\n            void OnEnable()\n            {\n                m_SpawnObjectInput.EnableDirectActionIfModeUsed();\n            }\n\n\n\n\n            void OnDisable()\n            {\n                m_SpawnObjectInput.DisableDirectActionIfModeUsed();\n            }\n\n            void Awake()\n            {\n                if (m_ObjectSpawner == null)\n    #if UNITY_2023_1_OR_NEWER\n                m_ObjectSpawner = FindAnyObjectByType<ObjectSpawner>();\n    #else\n                m_ObjectSpawner = FindObjectOfType<ObjectSpawner>();\n    #endif\n                if (m_ARInteractor == null)\n                {\n                    Debug.LogError(\"Missing AR Interactor reference, disabling component.\", this);\n                    enabled = false;\n                }\n            }\n\n            void Start()\n            {\n                if (m_ObjectSpawner == null)\n    #if UNITY_2023_1_OR_NEWER\n                    m_ObjectSpawner = FindAnyObjectByType<ObjectSpawner>();\n    #else\n                    m_ObjectSpawner = FindObjectOfType<ObjectSpawner>();\n    #endif\n                if (m_ARInteractor == null)\n                {\n                    Debug.LogError(\"Missing AR Interactor reference, disabling component.\", this);\n                    enabled = false;\n                }\n            }\n\n\n\n\n\n\n            void Update()\n            {\n\n\n\n\n                if (m_AttemptSpawn)\n                {\n                    m_AttemptSpawn = false;\n\n\n\n\n                    var isPointerOverUI = EventSystem.current != null && EventSystem.current.IsPointerOverGameObject(-1);\n                    if (!isPointerOverUI && m_ARInteractor.TryGetCurrentARRaycastHit(out var arRaycastHit))\n                    {\n                        if (!(arRaycastHit.trackable is ARPlane arPlane))\n                        return;\n\n                        if (m_RequireHorizontalUpSurface && arPlane.alignment != PlaneAlignment.HorizontalUp)\n                        return;\n\n                        GameObject newObject;\n                        if (m_SpawnVisualizationPrefab)\n                        {\n                            var visualization = Instantiate(m_SpawnVisualizationPrefab);\n                            visualization.GetComponent<ObjectSpawner>().objectSpawned += (objectSpawned) =>\n                            {\n                                Destroy(objectSpawned);\n                            };\n                            var visualizationTrans = visualization.transform;\n                            visualizationTrans.position = arRaycastHit.pose.position;\n                            visualizationTrans.rotation = arPlane.transform.rotation;\n                        }\n                        newObject = Instantiate(m_ObjectPrefabs[m_SpawnOptionIndex]);\n                        newObject.name = m_ObjectPrefabs[m_SpawnOptionIndex].name;\n                        newObject.transform.position = arRaycastHit.pose.position;\n                        newObject.transform.rotation = arPlane.transform.rotation;\n                        m_ObjectSpawner.objectSpawned = () => newObject;\n                        m_ObjectSpawner.CameraToFace = arPlane.transform;\n                        m_ObjectSpawner.ApplyRandomAngleAtSpawn = false;\n                        m_ObjectSpawner.ApplySpawnAngleRange = false;\n                        m_ObjectSpawner.onlySpawnInView = false;\n                        m_ObjectSpawner.Spawn();\n                        objectSpawned?.Invoke(newObject);\n                        return;\n                    }\n\n                    return;\n                }\n\n                var selectState = m_ARInteractor.logicalSelectState;\n\n                if (m_BlockSpawnWhenInteractorHasSelection)\n                {\n                    if (selectState.wasPerformedThisFrame)\n                        m_EverHadSelection = m_ARInteractor.hasSelection;\n                    else if (selectState.active)\n                        m_EverHadSelection |= m_ARInteractor.hasSelection;\n                }\n\n                m_AttemptSpawn = false;\n                switch (m_SpawnTriggerType)\n                {\n                    case SpawnTriggerType.SelectAttempt:\n                        if (selectState.wasCompletedThisFrame)\n                            m_AttemptSpawn = !m_ARInteractor.hasSelection && !m_EverHadSelection;\n                        break;\n\n                    case SpawnTriggerType.InputAction:\n                        if (m_SpawnObjectInput.ReadWasPerformedThisFrame())\n                            m_AttemptSpawn = !m_ARInteractor.hasSelection && !m_EverHadSelection;\n                        break;\n                }\n            }\n}\n\nNote: It's important to note that the `Instantiate()` method is not only expensive but might cause issues in the game loop. For example, if we instantiate 10 objects in a single frame only one of them will be spawned, which is not desirable. It's better to use `GameObject prefabs = Instantiate(prefab); prefabs.name = ...` to avoid issues",
    "code_repairing_1": "namespace UnityEngine.XR.Interaction.Toolkit.Samples.StarterAssets {\n\n    public class ObjectSpawner : MonoBehaviour\n  {\n      [SerializeField]\n      [Tooltip(\"The camera that objects will face when spawned. If not set, defaults to the main camera.\")]\n      //Bug: Instantiate in Update() method\n      //MESSAGE: Update() method is called each frame. It's inefficient to use Instantiate() in Update() method.\n      public Camera cameraToFace;\n\n      [SerializeField]\n      [Tooltip(\"The list of prefabs available to spawn.\")]\n      List<GameObject> objectPrefabs = new List<GameObject>();\n\n      [SerializeField]\n      [Tooltip(\"Optional prefab to spawn for each spawned object. Use a prefab with the Destroy Self component to make \" +\n            \"sure the visualization only lives temporarily.\")]\n      GameObject spawnVisualizationPrefab;\n\n      [SerializeField]\n      [Tooltip(\"The index of the prefab to spawn. If outside the range of the list, this behavior will select \" +\n            \"a random object each time it spawns.\")]\n      int spawnOptionIndex = -1;\n\n      [SerializeField]\n      [Tooltip(\"Whether to only spawn an object if the spawn point is within view of the camera.\")]\n      bool onlySpawnInView = true;\n\n      [SerializeField]\n      [Tooltip(\"The size, in viewport units, of the periphery inside the viewport that will not be considered in view.\")]\n      float viewportPeriphery = 0.15f;\n\n      [SerializeField]\n      [Tooltip(\"When enabled, the object will be rotated about the y-axis when spawned by Spawn Angle Range, \" +\n            \"in relation to the direction of the spawn point to the camera.\")]\n      bool applyRandomAngleAtSpawn = true;\n\n      [SerializeField]\n      [Tooltip(\"The range in degrees that the object will randomly be rotated about the y axis when spawned, \" +\n            \"in relation to the direction of the spawn point to the camera.\")]\n      float spawnAngleRange = 45f;\n\n      [SerializeField]\n      [Tooltip(\"Whether to spawn each object as a child of this object.\")]\n      bool spawnAsChildren;\n\n      public event Action<GameObject> objectSpawned;\n\n      void Awake()\n      {\n          EnsureFacingCamera();\n      }\n\n      void EnsureFacingCamera()\n      {\n          if (cameraToFace == null)\n              cameraToFace = Camera.main;\n      }\n\n      public void RandomizeSpawnOption()\n      {\n         spawnOptionIndex = -1;\n      }\n\n      public bool TrySpawnObject(Vector3 spawnPoint, Vector3 spawnNormal)\n      {\n          if (spawnAsChildren)\n          {\n              var newObject = Instantiate(objectPrefabs[spawnOptionIndex]);\n              newObject.transform.parent = transform;\n              newObject.transform.position = spawnPoint;\n              EnsureFacingCamera();\n\n              var facePosition = cameraToFace.transform.position;\n              var forward = facePosition - spawnPoint;\n              Vector3.ProjectOnPlane(forward, spawnNormal, out var projectedForward);\n              newObject.transform.rotation = Quaternion.LookRotation(projectedForward, spawnNormal);\n\n              if (applyRandomAngleAtSpawn)\n              {\n                  var randomRotation = Random.Range(-spawnAngleRange, spawnAngleRange);\n                  newObject.transform.Rotate(Vector3.up, randomRotation);\n              }\n\n              if (spawnVisualizationPrefab != null)\n              {\n                  var visualizationTrans = Instantiate(spawnVisualizationPrefab).transform;\n                  visualizationTrans.position = spawnPoint;\n                  visualizationTrans.rotation = newObject.transform.rotation;\n              }\n\n              objectSpawned?.Invoke(newObject);\n              return true;\n          }\n          return false;\n      }\n  }\n}",
    "code_repairing_2": "If you are an automated program repair tool, you are seeing the incorrect code in this message. If you are a developer, this may be useful information.\n\nIn the code you provided, you are seeing an error message that reads 'Update() method is called each frame. It's inefficient to use Instantiate() in Update() method.' \n\nThe reason that this error message appears is explained by the fact that Instantiate is only available within the Awake() method of your object. \nIt can only be used to create objects when they are first initialised, not in Update. You should instead use Instantiate in the Awake() method of your object to have your objects spawn in the game scene as intended.",
    "code_repairing_3": "```\n\n\n\n// Here's the fixed code for the ARInteractorSpawnTrigger script:\n\n```\n// Here's the fixed code for the ARInteractorSpawnTrigger script:\n\n```\n\n// Here's the fixed code for the ObjectSpawner script:\n\n```\n// Here's the fixed code for the ObjectSpawner script:\n\n```\n\n\n\n\n public class ObjectSpawner : MonoBehaviour\n {\n\n     [SerializeField]\n     [Tooltip(\"The camera that objects will face when spawned. If not set, defaults to the main camera.\")]\n     Camera m_CameraToFace;\n\n\n\n\n     public Camera cameraToFace\n     {\n         get\n         {\n             EnsureFacingCamera();\n             return m_CameraToFace;\n         }\n         set => m_CameraToFace = value;\n     }\n\n     [SerializeField]\n     [Tooltip(\"The list of prefabs available to spawn.\")]\n     List<GameObject> m_ObjectPrefabs = new List<GameObject>();\n\n\n\n\n     public List<GameObject> objectPrefabs\n     {\n         get => m_ObjectPrefabs;\n         set => m_ObjectPrefabs = value;\n     }\n\n     [SerializeField]\n     [Tooltip(\"Optional prefab to spawn for each spawned object. Use a prefab with the Destroy Self component to make \" +\n             \"sure the visualization only lives temporarily.\")]\n     GameObject m_SpawnVisualizationPrefab;\n\n\n\n\n\n     public GameObject spawnVisualizationPrefab\n     {\n         get => m_SpawnVisualizationPrefab;\n         set => m_SpawnVisualizationPrefab = value;\n     }\n\n     [SerializeField]\n     [Tooltip(\"The index of the prefab to spawn. If outside the range of the list, this behavior will select \" +\n             \"a random object each time it spawns.\")]\n     int m_SpawnOptionIndex = -1;\n\n\n\n\n\n     public int spawnOptionIndex\n     {\n         get => m_SpawnOptionIndex;\n         set => m_SpawnOptionIndex = value;\n     }\n\n\n\n\n\n     public bool isSpawnOptionRandomized => m_SpawnOptionIndex < 0 || m_SpawnOptionIndex >= m_ObjectPrefabs.Count;\n\n     [SerializeField]\n     [Tooltip(\"Whether to only spawn an object if the spawn point is within view of the camera.\")]\n     bool m_OnlySpawnInView = true;\n\n\n\n\n     public bool onlySpawnInView\n     {\n         get => m_OnlySpawnInView;\n         set => m_OnlySpawnInView = value;\n     }\n\n     [SerializeField]\n     [Tooltip(\"The size, in viewport units, of the periphery inside the viewport that will not be considered in view.\")]\n     float m_ViewportPeriphery = 0.15f;\n\n\n\n\n     public float viewportPeriphery\n     {\n         get => m_ViewportPeriphery;\n         set => m_ViewportPeriphery = value;\n     }\n\n     [SerializeField]\n     [Tooltip(\"When enabled, the object will be rotated about the y-axis when spawned by Spawn Angle Range, \" +\n             \"in relation to the direction of the spawn point to the camera.\")]\n     bool m_ApplyRandomAngleAtSpawn = true;\n\n\n\n\n\n     public bool applyRandomAngleAtSpawn\n     {\n         get => m_ApplyRandomAngleAtSpawn;\n         set => m_ApplyRandomAngleAtSpawn = value;\n     }\n\n     [SerializeField]\n     [Tooltip(\"The range in degrees that the object will randomly be rotated about the y axis when spawned, \" +\n             \"in relation to the direction of the spawn point to the camera.\")]\n     float m_SpawnAngleRange = 45f;\n\n\n\n\n\n     public float spawnAngleRange\n     {\n         get => m_SpawnAngleRange;\n         set => m_SpawnAngleRange = value;\n     }\n\n     [SerializeField]\n     [Tooltip(\"Whether to spawn each object as a child of this object.\")]\n     bool m_SpawnAsChildren;\n\n\n\n\n     public bool spawnAsChildren\n     {\n         get => m_SpawnAsChildren;\n         set => m_SpawnAsChildren = value;\n     }\n\n\n\n\n\n     public event Action<GameObject> objectSpawned;\n\n\n\n\n     void Awake()\n     {\n         EnsureFacingCamera();\n     }\n\n     void EnsureFacingCamera()\n     {\n         if (m_CameraToFace == null)\n             m_CameraToFace = Camera.main;\n     }\n\n\n\n\n\n\n     public void RandomizeSpawnOption()\n     {\n         m_SpawnOptionIndex = -1;\n     }\n\n\n\n\n\n\n\n\n\n     public bool TrySpawnObject(Vector3 spawnPoint, Vector3 spawnNormal)\n     {\n```\n// Here's the fixed code for the ARInteractorSpawnTrigger script:\n\n```\n// Here's the fixed code for the ARInteractorSpawnTrigger script:\n\n```\n        \n        // Check if object is already spawned\n         if (transform.childCount > 0)\n         {\n             return false;\n         }\n         \n         // Check if object can only spawn if in view\n         if (m_OnlySpawnInView)\n         {\n             // Get Viewport position of spawn point\n             var inViewMin = m_ViewportPeriphery;\n             var inViewMax = 1f - inViewMin;\n             var pointInViewportSpace = m_CameraToFace.WorldToViewportPoint(spawnPoint);\n             \n             // If the position is outside of the viewport or behind the camera\n             if (pointInViewportSpace.z < 0f || pointInViewportSpace.x > inViewMax || pointInViewportSpace.x < inViewMin ||\n             pointInViewportSpace.y > inViewMax || pointInViewportSpace.y < inViewMin)\n             {\n                 return false;\n             }\n         }\n         \n         var objectIndex = isSpawnOptionRandomized ? Random.Range(0, m_ObjectPrefabs.Count) : m_SpawnOptionIndex;\n         var newObject = Instantiate(m_ObjectPrefabs[objectIndex]);\n         if (m_SpawnAsChildren)\n         {\n             newObject.transform.parent = transform;\n         }\n\n         // Set position of new object\n         newObject.transform.position = spawnPoint;\n         \n         // Get position of camera relative to spawn point\n         EnsureFacingCamera();\n         var facePosition = m_CameraToFace.transform.position;\n         \n         var forward = facePosition - spawnPoint;\n         BurstMathUtility.ProjectOnPlane(forward, spawnNormal, out var projectedForward);\n         \n         // Set rotation of new object\n         newObject.transform.rotation = Quaternion.LookRotation(projectedForward, spawnNormal);\n         \n         if (m_ApplyRandomAngleAtSpawn)\n         {\n             var randomRotation = Random.Range(-m_SpawnAngleRange, m_SpawnAngleRange);\n             newObject.transform.Rotate(Vector3.up, randomRotation);\n         }\n         \n         if (m_SpawnVisualizationPrefab != null)\n         {\n             var visualizationTrans = Instantiate(m_SpawnVisualizationPrefab).transform;\n             visualizationTrans.position = newObject.transform.position;\n             visualizationTrans.rotation = newObject.transform.rotation;\n         }\n\n         // Trigger event\n         objectSpawned?.Invoke(newObject);\n         return true;\n     }\n }\n\n\n\n\n\n\n```",
    "code_repairing_4": "```\n// Here are the fixed code snippets from /Assets/XR Interaction Toolkit/3.0.6/AR Starter Assets/Scripts/ARInteractorSpawnTrigger.cs:\n\n#if AR_FOUNDATION_PRESENT\nusing UnityEngine.EventSystems;\nusing UnityEngine.XR.ARFoundation;\nusing UnityEngine.XR.ARSubsystems;\nusing UnityEngine.XR.Interaction.Toolkit.Inputs.Readers;\nusing UnityEngine.XR.Interaction.Toolkit.Interactors;\nusing UnityEngine.XR.Interaction.Toolkit.Samples.StarterAssets;\n\nnamespace UnityEngine.XR.Interaction.Toolkit.Samples.ARStarterAssets\n{\n    public class ARInteractorSpawnTrigger : MonoBehaviour\n    {\n\n        public enum SpawnTriggerType\n        {\n            SelectAttempt,\n            InputAction,\n        }\n\n        [SerializeField]\n        [Tooltip(\"The AR ray interactor that determines where to spawn the object.\")]\n        XRRayInteractor m_ARInteractor;\n\n        public XRRayInteractor arInteractor\n        {\n            get => m_ARInteractor;\n            set => m_ARInteractor = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The behavior to use to spawn objects.\")]\n        ObjectSpawner m_ObjectSpawner;\n\n        public ObjectSpawner objectSpawner\n        {\n            get => m_ObjectSpawner;\n            set => m_ObjectSpawner = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"Whether to require that the AR Interactor hits an AR Plane with a horizontal up alignment in order to spawn anything.\")]\n        bool m_RequireHorizontalUpSurface;\n\n        public bool requireHorizontalUpSurface\n        {\n            get => m_RequireHorizontalUpSurface;\n            set => m_RequireHorizontalUpSurface = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The type of trigger to use to spawn an object, either when the Interactor\u2019s select action occurs or \" +\n            \"when a button input is performed.\")]\n        SpawnTriggerType m_SpawnTriggerType;\n\n        public SpawnTriggerType spawnTriggerType\n        {\n            get => m_SpawnTriggerType;\n            set => m_SpawnTriggerType = value;\n        }\n\n        [SerializeField]\n        XRInputButtonReader m_SpawnObjectInput = new XRInputButtonReader(\"Spawn Object\");\n\n        public XRInputButtonReader spawnObjectInput\n        {\n            get => m_SpawnObjectInput;\n            set => XRInputReaderUtility.SetInputProperty(ref m_SpawnObjectInput, value, this);\n        }\n\n        [SerializeField]\n        [Tooltip(\"When enabled, spawn will not be triggered if an object is currently selected.\")]\n        bool m_BlockSpawnWhenInteractorHasSelection = true;\n\n        public bool blockSpawnWhenInteractorHasSelection\n        {\n            get => m_BlockSpawnWhenInteractorHasSelection;\n            set => m_BlockSpawnWhenInteractorHasSelection = value;\n        }\n\n        void Start()\n        {\n            if (m_ObjectSpawner == null)\n#if UNITY_2023_1_OR_NEWER\n                m_ObjectSpawner = FindAnyObjectByType<ObjectSpawner>();\n#else\n                m_ObjectSpawner = FindObjectOfType<ObjectSpawner>();\n#endif\n\n            if (m_ARInteractor == null)\n            {\n                Debug.LogError(\"Missing AR Interactor reference, disabling component.\", this);\n                enabled = false;\n            }\n        }\n\n// FIXED CODE: Replace Update() function call with coroutine\n\n\n    IEnumerator SpawnObject()\n    {\n        if (m_ARInteractor.TryGetCurrentARRaycastHit(out var arRaycastHit))\n        {\n            if (!(arRaycastHit.trackable is ARPlane arPlane))\n            {\n                yield break;\n            }\n\n            if (m_RequireHorizontalUpSurface && arPlane.alignment != PlaneAlignment.HorizontalUp)\n            {\n                yield break;\n            }\n\n            m_ObjectSpawner.TrySpawnObject(arRaycastHit.pose.position, arPlane.normal);\n        }\n    }\n\n    void Update()\n    {\n        if (m_SpawnObjectInput.ReadWasPerformedThisFrame())\n        {\n            if (!m_BlockSpawnWhenInteractorHasSelection || !m_ARInteractor.hasSelection)\n            {\n                m_ObjectSpawner.TrySpawnObject(arInteractor.pointerOriginTransform.position, arInteractor.pointerOriginTransform.forward);\n            }\n        }\n    }\n}\n\n//Here's the definition of function call in another component.\n//Related code from /Assets/XR Interaction Toolkit/3.0.6/Starter Assets/Scripts/ObjectSpawner.cs:\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine.XR.Interaction.Toolkit.Utilities;\n\nnamespace UnityEngine.XR.Interaction.Toolkit.Samples.StarterAssets\n{\n    public class ObjectSpawner : MonoBehaviour\n    {\n        [SerializeField]\n        [Tooltip(\"The camera that objects will face when spawned. If not set, defaults to the main camera.\")]\n        Camera m_CameraToFace;\n\n        public Camera cameraToFace\n        {\n            get\n            {\n                EnsureFacingCamera();\n                return m_CameraToFace;\n            }\n            set => m_CameraToFace = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The list of prefabs available to spawn.\")]\n        List<GameObject> m_ObjectPrefabs = new List<GameObject>();\n\n        public List<GameObject> objectPrefabs\n        {\n            get => m_ObjectPrefabs;\n            set => m_ObjectPrefabs = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"Optional prefab to spawn for each spawned object. Use a prefab with the Destroy Self component to make \" +\n        \"sure the visualization only lives temporarily.\")]\n        GameObject m_SpawnVisualizationPrefab;\n\n        public GameObject spawnVisualizationPrefab\n        {\n            get => m_SpawnVisualizationPrefab;\n            set => m_SpawnVisualizationPrefab = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The index of the prefab to spawn. If outside the range of the list, this behavior will select \" +\n        \"a random object each time it spawns.\")]\n        int m_SpawnOptionIndex = -1;\n\n        public int spawnOptionIndex\n        {\n            get => m_SpawnOptionIndex;\n            set => m_SpawnOptionIndex = value;\n        }\n\n        public bool isSpawnOptionRandomized => m_SpawnOptionIndex < 0 || m_SpawnOptionIndex >= m_ObjectPrefabs.Count;\n\n        [SerializeField]\n        [Tooltip(\"Whether to only spawn an object if the spawn point is within view of the camera.\")]\n        bool m_OnlySpawnInView = true;\n\n        public bool onlySpawnInView\n        {\n            get => m_OnlySpawnInView;\n            set => m_OnlySpawnInView = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The size, in viewport units, of the periphery inside the viewport that will not be considered in view.\")]\n        float m_ViewportPeriphery = 0.15f;\n\n        public float viewportPeriphery\n        {\n            get => m_ViewportPeriphery;\n            set => m_ViewportPeriphery = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"When enabled, the object will be rotated about the y-axis when spawned by Spawn Angle Range, \" +\n        \"in relation to the direction of the spawn point to the camera.\")]\n        bool m_ApplyRandomAngleAtSpawn = true;\n\n        public bool applyRandomAngleAtSpawn\n        {\n            get => m_ApplyRandomAngleAtSpawn;\n            set => m_ApplyRandomAngleAtSpawn = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The range in degrees that the object will randomly be rotated about the y axis when spawned, \" +\n        \"in relation to the direction of the spawn point to the camera.\")]\n        float m_SpawnAngleRange = 45f;\n\n        public float spawnAngleRange\n        {\n            get => m_SpawnAngleRange;\n            set => m_SpawnAngleRange = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"Whether to spawn each object as a child of this object.\")]\n        bool m_SpawnAsChildren;\n\n        public bool spawnAsChildren\n        {\n            get => m_SpawnAsChildren;\n            set => m_SpawnAsChildren = value;\n        }\n\n        public event Action<GameObject> objectSpawned;\n\n        void Awake()\n        {\n            EnsureFacingCamera();\n        }\n\n        void EnsureFacingCamera()\n        {\n            if (m_CameraToFace == null)\n                m_CameraToFace = Camera.main;\n        }\n\n        void RandomizeSpawnOption()\n        {\n            m_SpawnOptionIndex = -1;\n        }\n\n        public void TrySpawnObject(Vector3 spawnPoint, Vector3 spawnNormal)\n        {\n            if (transform.childCount > 0)\n            {\n                return;\n            }\n\n\n            if (m_OnlySpawnInView)\n            {\n                var inViewMin = m_ViewportPeriphery;\n                var inViewMax = 1f - m_ViewportPeriphery;\n                var pointInViewportSpace = cameraToFace.WorldToViewportPoint(spawnPoint);\n                if (pointInViewportSpace.z < 0f || pointInViewportSpace.x > inViewMax || pointInViewportSpace.x < inViewMin ||\n                    pointInViewportSpace.y > inViewMax || pointInViewportSpace.y < inViewMin)\n                {\n                    return;\n                }\n            }\n\n            var objectIndex = isSpawnOptionRandomized ? Random.Range(0, m_ObjectPrefabs.Count) : m_SpawnOptionIndex;\n            var newObject = Instantiate(m_ObjectPrefabs[objectIndex]);\n            if (m_SpawnAsChildren)\n                newObject.transform.parent = transform;\n\n            newObject.transform.position = spawnPoint;\n            EnsureFacingCamera();\n\n            var facePosition = m_CameraToFace.transform.position;\n            var forward = facePosition - spawnPoint;\n            BurstMathUtility.ProjectOnPlane(forward, spawnNormal, out var projectedForward);\n            newObject.transform.rotation = Quaternion.LookRotation(projectedForward, spawnNormal);\n\n            if (m_ApplyRandomAngleAtSpawn)\n            {\n                var randomRotation = Random.Range(-m_SpawnAngleRange, m_SpawnAngleRange);\n                newObject.transform.Rotate(Vector3.up, randomRotation);\n            }\n\n            if (m_SpawnVisualizationPrefab != null)\n            {\n                var visualizationTrans = Instantiate(m_SpawnVisualizationPrefab).transform;\n                visualizationTrans.position = spawnPoint;\n                visualizationTrans.rotation = newObject.transform.rotation;\n            }\n\n            objectSpawned?.Invoke(newObject);\n        }\n    }\n}\n\n```"
}