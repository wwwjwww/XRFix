{
  "test_code": "    public override void Update(GameObject gameObject, Camera mainCamera,\n        OVRMixedRealityCaptureConfiguration configuration, OVRManager.TrackingOrigin trackingOrigin)\n    {\n#if OVR_ANDROID_MRC\n        if (skipFrame && OVRPlugin.Media.IsCastingToRemoteClient())\n        {\n            isFrameSkipped = !isFrameSkipped;\n            if (isFrameSkipped)\n            {\n                return;\n            }\n        }\n#endif\n\n<BUGS>        RefreshCameraObjects(gameObject, mainCamera, configuration);\n<BUGE>\n\n        OVRPlugin.SetHandNodePoseStateLatency(0.0);\n\n\n        OVRPose stageToLocalPose =\n            OVRPlugin.GetTrackingTransformRelativePose(OVRPlugin.TrackingOrigin.Stage).ToOVRPose();\n        OVRPose localToStagePose = stageToLocalPose.Inverse();\n        OVRPose head = localToStagePose * OVRPlugin.GetNodePose(OVRPlugin.Node.Head, OVRPlugin.Step.Render).ToOVRPose();\n        OVRPose leftC = localToStagePose *\n                        OVRPlugin.GetNodePose(OVRPlugin.Node.HandLeft, OVRPlugin.Step.Render).ToOVRPose();\n        OVRPose rightC = localToStagePose *\n                         OVRPlugin.GetNodePose(OVRPlugin.Node.HandRight, OVRPlugin.Step.Render).ToOVRPose();\n        OVRPlugin.Media.SetMrcHeadsetControllerPose(head.ToPosef(), leftC.ToPosef(), rightC.ToPosef());\n\n#if OVR_ANDROID_MRC\n        RefreshAudioFilter(mainCamera);\n\n        int drawTextureIndex = (frameIndex / 2) % 2;\n        int castTextureIndex = 1 - drawTextureIndex;\n\n        backgroundCamera.enabled = (frameIndex % 2) == 0;\n        foregroundCamera.enabled = (frameIndex % 2) == 1;\n\n        if (frameIndex % 2 == 0)\n        {\n            if (lastMrcEncodeFrameSyncId != -1)\n            {\n                OVRPlugin.Media.SyncMrcFrame(lastMrcEncodeFrameSyncId);\n                lastMrcEncodeFrameSyncId = -1;\n            }\n\n            lastMrcEncodeFrameSyncId = CastMrcFrame(castTextureIndex);\n            SetCameraTargetTexture(drawTextureIndex);\n        }\n\n        ++frameIndex;\n#endif\n\n        backgroundCamera.clearFlags = mainCamera.clearFlags;\n        backgroundCamera.backgroundColor = mainCamera.backgroundColor;\n        if (configuration.dynamicCullingMask)\n        {\n            backgroundCamera.cullingMask = (mainCamera.cullingMask & ~configuration.extraHiddenLayers) |\n                                           configuration.extraVisibleLayers;\n        }\n\n        backgroundCamera.nearClipPlane = mainCamera.nearClipPlane;\n        backgroundCamera.farClipPlane = mainCamera.farClipPlane;\n\n        if (configuration.dynamicCullingMask)\n        {\n            foregroundCamera.cullingMask = (mainCamera.cullingMask & ~configuration.extraHiddenLayers) |\n                                           configuration.extraVisibleLayers;\n        }\n\n        foregroundCamera.nearClipPlane = mainCamera.nearClipPlane;\n        foregroundCamera.farClipPlane = mainCamera.farClipPlane;\n\n        if (OVRMixedReality.useFakeExternalCamera || OVRPlugin.GetExternalCameraCount() == 0)\n        {\n            OVRPose worldSpacePose = new OVRPose();\n            OVRPose trackingSpacePose = new OVRPose();\n            trackingSpacePose.position = trackingOrigin == OVRManager.TrackingOrigin.EyeLevel\n                ? OVRMixedReality.fakeCameraEyeLevelPosition\n                : OVRMixedReality.fakeCameraFloorLevelPosition;\n            trackingSpacePose.orientation = OVRMixedReality.fakeCameraRotation;\n            worldSpacePose = OVRExtensions.ToWorldSpacePose(trackingSpacePose, mainCamera);\n\n            backgroundCamera.fieldOfView = OVRMixedReality.fakeCameraFov;\n            backgroundCamera.aspect = OVRMixedReality.fakeCameraAspect;\n            foregroundCamera.fieldOfView = OVRMixedReality.fakeCameraFov;\n            foregroundCamera.aspect = OVRMixedReality.fakeCameraAspect;\n\n            if (cameraInTrackingSpace)\n            {\n                backgroundCamera.transform.FromOVRPose(trackingSpacePose, true);\n                foregroundCamera.transform.FromOVRPose(trackingSpacePose, true);\n            }\n            else\n            {\n                backgroundCamera.transform.FromOVRPose(worldSpacePose);\n                foregroundCamera.transform.FromOVRPose(worldSpacePose);\n            }\n        }\n        else\n        {\n            OVRPlugin.CameraExtrinsics extrinsics;\n            OVRPlugin.CameraIntrinsics intrinsics;\n\n\n            if (OVRPlugin.GetMixedRealityCameraInfo(0, out extrinsics, out intrinsics))\n            {\n                float fovY = Mathf.Atan(intrinsics.FOVPort.UpTan) * Mathf.Rad2Deg * 2;\n                float aspect = intrinsics.FOVPort.LeftTan / intrinsics.FOVPort.UpTan;\n                backgroundCamera.fieldOfView = fovY;\n                backgroundCamera.aspect = aspect;\n                foregroundCamera.fieldOfView = fovY;\n                foregroundCamera.aspect = intrinsics.FOVPort.LeftTan / intrinsics.FOVPort.UpTan;\n\n                if (cameraInTrackingSpace)\n                {\n                    OVRPose trackingSpacePose = ComputeCameraTrackingSpacePose(extrinsics);\n                    backgroundCamera.transform.FromOVRPose(trackingSpacePose, true);\n                    foregroundCamera.transform.FromOVRPose(trackingSpacePose, true);\n                }\n                else\n                {\n                    OVRPose worldSpacePose = ComputeCameraWorldSpacePose(extrinsics, mainCamera);\n                    backgroundCamera.transform.FromOVRPose(worldSpacePose);\n                    foregroundCamera.transform.FromOVRPose(worldSpacePose);\n                }\n#if OVR_ANDROID_MRC\n                cameraPoseTimeArray[drawTextureIndex] = extrinsics.LastChangedTimeSeconds;\n#endif\n            }\n            else\n            {\n                Debug.LogError(\"Failed to get external camera information\");\n                return;\n            }\n        }\n\n        Vector3 headToExternalCameraVec = mainCamera.transform.position - foregroundCamera.transform.position;\n        float clipDistance = Vector3.Dot(headToExternalCameraVec, foregroundCamera.transform.forward);\n        foregroundCamera.farClipPlane = Mathf.Max(foregroundCamera.nearClipPlane + 0.001f, clipDistance);\n    }\n\n/*Addition Code for reference:\n    private void RefreshCameraObjects(GameObject parentObject, Camera mainCamera,\n        OVRMixedRealityCaptureConfiguration configuration)\n    {\n        if (mainCamera.gameObject != previousMainCameraObject)\n        {\n            Debug.LogFormat(\"[OVRExternalComposition] Camera refreshed. Rebind camera to {0}\",\n                mainCamera.gameObject.name);\n\n            OVRCompositionUtil.SafeDestroy(ref backgroundCameraGameObject);\n            backgroundCamera = null;\n            OVRCompositionUtil.SafeDestroy(ref foregroundCameraGameObject);\n            foregroundCamera = null;\n\n            RefreshCameraRig(parentObject, mainCamera);\n\n            Debug.Assert(backgroundCameraGameObject == null);\n            if (configuration.instantiateMixedRealityCameraGameObject != null)\n            {\n                backgroundCameraGameObject =\n                    configuration.instantiateMixedRealityCameraGameObject(mainCamera.gameObject,\n                        OVRManager.MrcCameraType.Background);\n            }\n            else\n            {\n                backgroundCameraGameObject = Object.Instantiate(mainCamera.gameObject);\n            }\n\n            backgroundCameraGameObject.name = \"OculusMRC_BackgroundCamera\";\n            backgroundCameraGameObject.transform.parent =\n                cameraInTrackingSpace ? cameraRig.trackingSpace : parentObject.transform;\n            if (backgroundCameraGameObject.GetComponent<AudioListener>())\n            {\n                Object.Destroy(backgroundCameraGameObject.GetComponent<AudioListener>());\n            }\n\n            if (backgroundCameraGameObject.GetComponent<OVRManager>())\n            {\n                Object.Destroy(backgroundCameraGameObject.GetComponent<OVRManager>());\n            }\n\n            backgroundCamera = backgroundCameraGameObject.GetComponent<Camera>();\n            backgroundCamera.tag = \"Untagged\";\n#if USING_MRC_COMPATIBLE_URP_VERSION\n            var backgroundCamData = backgroundCamera.GetUniversalAdditionalCameraData();\n            if (backgroundCamData != null)\n            {\n                backgroundCamData.allowXRRendering = false;\n            }\n#elif USING_URP\n            Debug.LogError(\"Using URP with MRC is only supported with URP version 10.0.0 or higher. Consider using Unity 2020 or higher.\");\n#else\n            backgroundCamera.stereoTargetEye = StereoTargetEyeMask.None;\n#endif\n            backgroundCamera.depth = 99990.0f;\n            backgroundCamera.rect = new Rect(0.0f, 0.0f, 0.5f, 1.0f);\n            backgroundCamera.cullingMask = (backgroundCamera.cullingMask & ~configuration.extraHiddenLayers) |\n                                           configuration.extraVisibleLayers;\n#if OVR_ANDROID_MRC\n            backgroundCamera.targetTexture = mrcRenderTextureArray[0];\n            if (!renderCombinedFrame)\n            {\n                backgroundCamera.rect = new Rect(0.0f, 0.0f, 1.0f, 1.0f);\n            }\n#endif\n\n            Debug.Assert(foregroundCameraGameObject == null);\n            if (configuration.instantiateMixedRealityCameraGameObject != null)\n            {\n                foregroundCameraGameObject =\n                    configuration.instantiateMixedRealityCameraGameObject(mainCamera.gameObject,\n                        OVRManager.MrcCameraType.Foreground);\n            }\n            else\n            {\n                foregroundCameraGameObject = Object.Instantiate(mainCamera.gameObject);\n            }\n\n            foregroundCameraGameObject.name = \"OculusMRC_ForgroundCamera\";\n            foregroundCameraGameObject.transform.parent =\n                cameraInTrackingSpace ? cameraRig.trackingSpace : parentObject.transform;\n            if (foregroundCameraGameObject.GetComponent<AudioListener>())\n            {\n                Object.Destroy(foregroundCameraGameObject.GetComponent<AudioListener>());\n            }\n\n            if (foregroundCameraGameObject.GetComponent<OVRManager>())\n            {\n                Object.Destroy(foregroundCameraGameObject.GetComponent<OVRManager>());\n            }\n\n            foregroundCamera = foregroundCameraGameObject.GetComponent<Camera>();\n            foregroundCamera.tag = \"Untagged\";\n#if USING_MRC_COMPATIBLE_URP_VERSION\n            var foregroundCamData = foregroundCamera.GetUniversalAdditionalCameraData();\n            if (foregroundCamData != null)\n            {\n                foregroundCamData.allowXRRendering = false;\n            }\n#elif USING_URP\n            Debug.LogError(\"Using URP with MRC is only supported with URP version 10.0.0 or higher. Consider using Unity 2020 or higher.\");\n#else\n            foregroundCamera.stereoTargetEye = StereoTargetEyeMask.None;\n#endif\n            foregroundCamera.depth =\n                backgroundCamera.depth + 1.0f; // enforce the forground be rendered after the background\n            foregroundCamera.rect = new Rect(0.5f, 0.0f, 0.5f, 1.0f);\n            foregroundCamera.clearFlags = CameraClearFlags.Color;\n#if OVR_ANDROID_MRC\n            foregroundCamera.backgroundColor = configuration.externalCompositionBackdropColorQuest;\n#else\n            foregroundCamera.backgroundColor = configuration.externalCompositionBackdropColorRift;\n#endif\n            foregroundCamera.cullingMask = (foregroundCamera.cullingMask & ~configuration.extraHiddenLayers) |\n                                           configuration.extraVisibleLayers;\n\n#if OVR_ANDROID_MRC\n            if (renderCombinedFrame)\n            {\n                foregroundCamera.targetTexture = mrcRenderTextureArray[0];\n            }\n            else\n            {\n                foregroundCamera.targetTexture = mrcForegroundRenderTextureArray[0];\n                foregroundCamera.rect = new Rect(0.0f, 0.0f, 1.0f, 1.0f);\n            }\n#endif\n\n\n\n\n\n\n\n\n            previousMainCameraObject = mainCamera.gameObject;\n        }\n    }\n*/"
}