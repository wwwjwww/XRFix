{
    "code_repairing_0": "Here is the fixed code:\n\n\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing UnityEngine;\n\n\npublic static class BkgndThread\n{\n    public class Dispatcher\n    {\n        \n\n        ThreadStart pending;\n\n        public void Schedule(ThreadStart function)\n        {\n            if (requestQueue == null)\n                MakeRequestQueue();\n\n            bool must_release = false;\n            lock (requestQueue)\n            {\n                if (pending == null)\n                {\n                    requestQueue.Enqueue(this);\n                    must_release = true;\n                }\n                pending = function;\n            }\n            if (must_release)\n                semaphore.Release();\n            bkgnd_thread_dispatcher_working = true;\n        }\n\n        ThreadStart Pop()\n        {\n            ThreadStart result = pending;\n            pending = null;\n            return result;\n        }\n\n        static Queue<Dispatcher> requestQueue;\n        static Semaphore semaphore;\n        static bool bkgnd_thread_dispatcher_working = false;\n\n        static void MakeRequestQueue()\n        {\n            requestQueue = new Queue<Dispatcher>();\n            semaphore = new Semaphore(0, int.MaxValue);\n            Start(() =>\n            {\n                while (true)\n                {\n                    semaphore.WaitOne();\n\n                    Dispatcher dispatcher;\n                    ThreadStart function;\n                    lock (requestQueue)\n                    {\n                        dispatcher = requestQueue.Dequeue();\n                        function = dispatcher.Pop();\n                    }\n                    function();\n                }\n            });\n        }\n\n        public static void WaitUntilThreadIdle()\n        {\n            if (bkgnd_thread_dispatcher_working)\n            {\n                var wait_until_done = new Dispatcher();\n                var ev = new AutoResetEvent(false);\n                wait_until_done.Schedule(() => ev.Set());\n                ev.WaitOne();\n                bkgnd_thread_dispatcher_working = false;\n            }\n        }\n    }\n\n\n    public class Compute<T> : Dispatcher\n    {\n        volatile bool got_answer;\n        public volatile bool interrupt;\n        T result;\n\n        public delegate T RunDelegate();\n        public delegate T RunDelegateWithCompute(Compute<T> compute);\n\n        public Compute(RunDelegateWithCompute run_delegate)\n        {\n            Schedule(() =>\n            {\n                T result1 = run_delegate(this);\n                lock (this)\n                {\n                    result = result1;\n                    got_answer = true;\n                }\n            });\n        }\n\n\n}\n```",
    "code_repairing_1": "FIXED CODE:\n\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing UnityEngine;\n\npublic static class BkgndThread\n{\n    public class Dispatcher\n    {\n        ThreadStart pending;\n\n        public void Schedule(ThreadStart function)\n        {\n            if (requestQueue == null)\n                MakeRequestQueue();\n\n            bool must_release = false;\n            lock (requestQueue)\n            {\n                if (pending == null)\n                {\n                    requestQueue.Enqueue(this);\n                    must_release = true;\n                }\n                pending = function;\n            }\n            if (must_release)\n                semaphore.Release();\n            bkgnd_thread_dispatcher_working = true;\n        }\n\n        ThreadStart Pop()\n        {\n            ThreadStart result = pending;\n            pending = null;\n            return result;\n        }\n\n        static Queue<Dispatcher> requestQueue;\n        static Semaphore semaphore;\n        static bool bkgnd_thread_dispatcher_working = false;\n\n        static void MakeRequestQueue()\n        {\n            requestQueue = new Queue<Dispatcher>();\n            semaphore = new Semaphore(0, int.MaxValue);\n            Start(() =>\n            {\n                while (true)\n                {\n                    semaphore.WaitOne();\n\n                    Dispatcher dispatcher;\n                    ThreadStart function;\n                    lock (requestQueue)\n                    {\n                        dispatcher = requestQueue.Dequeue();\n                        function = dispatcher.Pop();\n                    }\n                    function();\n                }\n            });\n        }\n\n        public static void WaitUntilThreadIdle()\n        {\n            if (bkgnd_thread_dispatcher_working)\n            {\n                var wait_until_done = new Dispatcher();\n                var ev = new AutoResetEvent(false);\n                wait_until_done.Schedule(() => ev.Set());\n                ev.WaitOne();\n                bkgnd_thread_dispatcher_working = false;\n            }\n        }\n    }\n\n\n    public class Compute<T> : Dispatcher\n    {\n        volatile bool got_answer;\n        public volatile bool interrupt;\n        T result;\n\n        public delegate T RunDelegate();\n        public delegate T RunDelegateWithCompute(Compute<T> compute);\n\n        public Compute(RunDelegate run_delegate)\n        {\n            Schedule(() =>\n            {\n                T result1 = run_delegate();\n                lock (this)\n                {\n                    result = result1;\n                    got_answer = true;\n                }\n            });\n        }\n\n        public T GetResult()\n        {\n            while (!got_answer)\n            {\n                if (interrupt)\n                    throw new OperationCanceledException();\n                Thread.Sleep(1);\n            }\n            return result;\n        }\n\n        public void Cancel()\n        {\n            interrupt = true;\n        }\n    }\n}",
    "code_repairing_2": "FIXED CODE:\n\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing UnityEngine;\n\n\npublic static class BkgndThread\n{\n    public class Dispatcher\n    {\n        \n\n        ThreadStart pending;\n\n        public void Schedule(ThreadStart function)\n        {\n            if (requestQueue == null)\n                MakeRequestQueue();\n\n            bool must_release = false;\n            lock (requestQueue)\n            {\n                if (pending == null)\n                {\n                    requestQueue.Enqueue(this);\n                    must_release = true;\n                }\n                pending = function;\n            }\n            if (must_release)\n                semaphore.Release();\n            bkgnd_thread_dispatcher_working = true;\n        }\n\n        ThreadStart Pop()\n        {\n            ThreadStart result = pending;\n            pending = null;\n            return result;\n        }\n\n        static Queue<Dispatcher> requestQueue;\n        static Semaphore semaphore;\n        static bool bkgnd_thread_dispatcher_working = false;\n\n        static void MakeRequestQueue()\n        {\n            requestQueue = new Queue<Dispatcher>();\n            semaphore = new Semaphore(0, int.MaxValue);\n            Start(() =>\n            {\n                while (true)\n                {\n                    semaphore.WaitOne();\n\n                    Dispatcher dispatcher;\n                    ThreadStart function;\n                    lock (requestQueue)\n                    {\n                        dispatcher = requestQueue.Dequeue();\n                        function = dispatcher.Pop();\n                    }\n                    function();\n                }\n            });\n        }\n\n        public static void WaitUntilThreadIdle()\n        {\n            if (bkgnd_thread_dispatcher_working)\n            {\n                var wait_until_done = new Dispatcher();\n                var ev = new AutoResetEvent(false);\n                wait_until_done.Schedule(() => ev.Set());\n                ev.WaitOne();\n                bkgnd_thread_dispatcher_working = false;\n            }\n        }\n    }\n\n\n    public class Compute<T> : Dispatcher\n    {\n        volatile bool got_answer;\n        public volatile bool interrupt;\n        T result;\n\n        public delegate T RunDelegate();\n        public delegate T RunDelegateWithCompute(Compute<T> compute);\n\n        public Compute(RunDelegate run_delegate)\n        {\n            Schedule(() =>\n            {\n                T result1 = run_delegate();\n                lock (this)\n                {\n                    result = result1;\n                    got_answer = true;\n                }\n            });\n        }\n\n\n        public T Result()\n        {\n            while (!got_answer || interrupt)\n            {\n                Thread.Yield();\n            }\n            interrupt = false;\n            return result;\n        }\n\n        public void Cancel()\n        {\n            interrupt = true;\n        }\n    }\n}",
    "code_repairing_3": "```\n\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing UnityEngine;\n\npublic static class BkgndThread {\n\n    public class Dispatcher {\n        ThreadStart pending;\n\n        public void Schedule() {\n            if (requestQueue == null) {\n                MakeRequestQueue();\n            }\n            bool must_release = false;\n            lock (requestQueue) {\n                if (pending == null) {\n                    requestQueue.Enqueue(this);\n                    must_release = true;\n                }\n                pending = function;\n            }\n            if (must_release) {\n                semaphore.Release();\n            }\n            bkgnd_thread_dispatcher_working = true;\n        }\n\n        ThreadStart Pop() {\n            ThreadStart result = pending;\n            pending = null;\n            return result;\n        }\n\n        static Queue<Dispatcher> requestQueue;\n        static Semaphore semaphore;\n        static bool bkgnd_thread_dispatcher_working = false;\n\n        static void MakeRequestQueue() {\n            requestQueue = new Queue<Dispatcher>();\n            semaphore = new Semaphore(0, int.MaxValue);\n            Start(() => {\n                while (true) {\n                    semaphore.WaitOne();\n\n                    Dispatcher dispatcher;\n                    ThreadStart function;\n                    lock (requestQueue) {\n                        dispatcher = requestQueue.Dequeue();\n                        function = dispatcher.Pop();\n                    }\n                    function();\n                }\n            });\n        }\n\n        public static void WaitUntilThreadIdle() {\n            if (bkgnd_thread_dispatcher_working) {\n                var wait_until_done = new Dispatcher();\n                var ev = new AutoResetEvent(false);\n                wait_until_done.Schedule(() => ev.Set());\n                ev.WaitOne();\n                bkgnd_thread_dispatcher_working = false;\n            }\n        }\n    }\n\n\n    public class Compute<T> : Dispatcher {\n        volatile bool got_answer;\n        public volatile bool interrupt;\n        T result;\n\n        public delegate T RunDelegate();\n        public delegate T RunDelegateWithCompute(Compute<T> compute);\n\n        public Compute(RunDelegate run_delegate) {\n            Schedule(() => {\n                T result1 = run_delegate();\n                lock (this) {\n                    result = result1;\n                    got_answer = true;\n                }\n            });\n        }\n\n        public Compute(RunDelegateWithCompute run_delegate) {\n            Schedule(() => {\n                T result1 = run_delegate(this);\n                lock (this) {\n                    result = result1;\n                    got_answer = true;\n                }\n            });\n        }\n    }\n}\n```",
    "code_repairing_4": "FIXED CODE:\n\n\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing UnityEngine;\n\n\npublic static class BkgndThread\n{\n    public class Dispatcher\n    {\n        \n\n        ThreadStart pending;\n\n        public void Schedule(ThreadStart function)\n        {\n            if (requestQueue == null)\n                MakeRequestQueue();\n\n            bool must_release = false;\n            lock (requestQueue)\n            {\n                if (pending == null)\n                {\n                    requestQueue.Enqueue(this);\n                    must_release = true;\n                }\n                pending = function;\n            }\n            if (must_release)\n                semaphore.Release();\n            bkgnd_thread_dispatcher_working = true;\n        }\n\n        ThreadStart Pop()\n        {\n            ThreadStart result = pending;\n            pending = null;\n            return result;\n        }\n\n        static Queue<Dispatcher> requestQueue;\n        static Semaphore semaphore;\n        static bool bkgnd_thread_dispatcher_working = false;\n\n        static void MakeRequestQueue()\n        {\n            requestQueue = new Queue<Dispatcher>();\n            semaphore = new Semaphore(0, int.MaxValue);\n            Start(() =>\n            {\n                while (true)\n                {\n                    semaphore.WaitOne();\n\n                    Dispatcher dispatcher;\n                    ThreadStart function;\n                    lock (requestQueue)\n                    {\n                        dispatcher = requestQueue.Dequeue();\n                        function = dispatcher.Pop();\n                    }\n                    function();\n                }\n            });\n        }\n\n        public static void WaitUntilThreadIdle()\n        {\n            if (bkgnd_thread_dispatcher_working)\n            {\n                var wait_until_done = new Dispatcher();\n                var ev = new AutoResetEvent(false);\n                wait_until_done.Schedule(() => ev.Set());\n                ev.WaitOne();\n                bkgnd_thread_dispatcher_working = false;\n            }\n        }\n    }\n\n\n    public class Compute<T> : Dispatcher\n    {\n        volatile bool got_answer;\n        public volatile bool interrupt;\n        T result;\n\n        public delegate T RunDelegate();\n        public delegate T RunDelegateWithCompute(Compute<T> compute);\n\n        public Compute(RunDelegate run_delegate)\n        {\n            Schedule(() =>\n            {\n                T result1 = run_delegate();\n                lock (this)\n                {\n                    result = result1;\n                    got_answer = true;\n                }\n            });\n        }\n\n\n\n        public T GetResult()\n        {\n            WaitUntilThreadIdle();\n            return result;\n        }\n    }\n}"
}