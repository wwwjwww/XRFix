{
    "code_repairing_0": "using System;\n using System.Collections;\n using System.Collections.Generic;\n using System.Runtime.InteropServices;\n using UnityEngine;\n\n using Node = UnityEngine.XR.XRNode;\n\n\n public static class OVRInput\n {\n     [Flags]\n     \n     public enum Button\n     {\n         None = 0,\n         One = 0x00000001,\n         Two = 0x00000002,\n         Three = 0x00000004,\n         Four = 0x00000008,\n         Start = 0x00001000,\n         Back = 0x00002000,\n         PrimaryShoulder = 0x00001000,\n         PrimaryIndexTrigger = 0x00002000,\n         PrimaryHandTrigger = 0x00004000,\n         PrimaryThumbstick = 0x00008000,\n         PrimaryThumbstickUp = 0x00010000,\n         PrimaryThumbstickDown = 0x00020000,\n         PrimaryThumbstickLeft = 0x00040000,\n         PrimaryThumbstickRight = 0x00080000,\n         PrimaryTouchpad = 0x00000400,\n         SecondaryShoulder = 0x00100000,\n         SecondaryIndexTrigger = 0x00200000,\n         SecondaryHandTrigger = 0x00400000,\n         SecondaryThumbstick = 0x00800000,\n         SecondaryThumbstickUp = 0x01000000,\n         SecondaryThumbstickDown = 0x02000000,\n         SecondaryThumbstickLeft = 0x04000000,\n         SecondaryThumbstickRight = 0x08000000,\n         SecondaryTouchpad = 0x00000800,\n         DpadUp = 0x00000010,\n         DpadDown = 0x00000020,\n         DpadLeft = 0x00000040,\n         DpadRight = 0x00000080,\n         Up = 0x10000000,\n         Down = 0x20000000,\n         Left = 0x40000000,\n         Right = unchecked((int)0x80000000),\n         Any = ~None,\n     }\n }\nFINAL CODE:\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing UnityEngine;\n\nusing Node = UnityEngine.XR.XRNode;\n\n\n\n\npublic static class OVRInput2\n{\n    [Flags]\n    \n    public enum Button\n    {\n        None = 0,\n        One = 0x00000001,\n        Two = 0x00000002,\n        Three = 0x00000004,\n        Four = 0x00000008,\n        Start = 0x00001000,\n        Back = 0x00002000,\n        PrimaryShoulder = 0x00001000,\n        PrimaryIndexTrigger = 0x00002000,\n        PrimaryHandTrigger = 0x00004000,\n        PrimaryThumbstick = 0x00008000,\n        PrimaryThumbstickUp = 0x00010000,\n        PrimaryThumbstickDown = 0x00020000,\n        PrimaryThumbstickLeft = 0x00040000,\n        PrimaryThumbstickRight = 0x00080000,\n        PrimaryTouchpad = 0x00000400,\n        SecondaryShoulder = 0x00100000,\n        SecondaryIndexTrigger = 0x00200000,\n        SecondaryHandTrigger = 0x00400000,\n        SecondaryThumbstick = 0x00800000,\n        SecondaryThumbstickUp = 0x01000000,\n        SecondaryThumbstickDown = 0x02000000,\n        SecondaryThumbstickLeft = 0x04000000,\n        SecondaryThumbstickRight = 0x08000000,\n        SecondaryTouchpad = 0x00000800,\n        DpadUp = 0x00000010,\n        DpadDown = 0x00000020,\n        DpadLeft = 0x00000040,\n        DpadRight = 0x00000080,\n        Up = 0x10000000,\n        Down = 0x20000000,\n        Left = 0x40000000,\n        Right = unchecked((int)0x80000000),\n        Any = ~None,\n    }\n\n    [Flags]\n    \n    public enum RawButton\n    {\n        None = 0,\n        A = 0x00000001,\n        B = 0x00000002,\n        X = 0x00000100,\n        Y = 0x00000200,\n        Start = 0x00000002,\n        Back = 0x00000008,\n        LShoulder = 0x00000800,\n        LIndexTrigger = 0x10000000,\n        LHandTrigger = 0x20000000,\n        LThumbstick = 0x00000400,\n        LThumbstickUp = 0x00000010,\n        LThumbstickDown = 0x00000020,\n        LThumbstickLeft = 0x00000040,\n        LThumbstickRight = 0x00000080,\n        LTouchpad = 0x40000000,\n        RShoulder = 0x00000008,\n        RIndexTrigger = 0x04000000,\n        RHandTrigger = 0x08000000,\n        RThumbstick = 0x00000004,\n        RThumbstickUp = 0x00001000,\n        RThumbstickDown = 0x00002000,\n        RThumbstickLeft = 0x00004000,\n        RThumbstickRight = 0x00008000,\n        RTouchpad = 0x80000000,\n        DpadUp = 0x00010000,\n        DpadDown = 0x00020000,\n        DpadLeft = 0x00040000,\n        DpadRight = 0x00080000,\n        Any = ~None,\n    }\n\n    [Flags]\n    \n    public enum Touch\n    {\n        None = 0,\n        One = Button.One,\n        Two = Button.Two,\n        Three = Button.Three,\n        Four = Button.Four,\n        PrimaryIndexTrigger = Button.PrimaryIndexTrigger,\n        PrimaryThumbstick = Button.PrimaryThumbstick,\n        PrimaryThumbRest = 0x00001000,",
    "code_repairing_1": "private static bool IsValidOpenVRDevice(uint deviceId)\n {\n     return deviceId != OVR.OpenVR.OpenVR.k_unTrackedDeviceIndex_Hmd && OVR.OpenVR.OpenVR.System.IsTrackedDeviceConnected(deviceId);\n }",
    "code_repairing_2": "private static bool IsValidOpenVRDevice(uint deviceId)\n  {\n      OVR.OpenVR.CVRSystem system = OVR.OpenVR.OpenVR.System;\n      return (deviceId != 255 && deviceId != 256) && IsTrackedDeviceConnected(deviceId);\n  }\n\n\n private static bool IsTrackedDeviceConnected(uint deviceId)\n {\n     OVR.OpenVR.CVRSystem system = OVR.OpenVR.OpenVR.System;\n     return system != null && system.IsTrackedDeviceConnected(deviceId);\n }\n\n\n private static bool IsControllerDeviceConnected(uint deviceId)\n {\n     OVR.OpenVR.CVRSystem system = OVR.OpenVR.OpenVR.System;\n     return system != null && system.GetTrackedDeviceClass(deviceId) == OVR.OpenVR.ETrackedDevic\nEproperty.Controller;\n }\n\n\n private static bool IsTrackedDeviceConnected(uint deviceId)\n {\n     OVR.OpenVR.CVRSystem system = OVR.OpenVR.OpenVR.System;\n     return system != null && system.IsTrackedDeviceConnected(deviceId);\n }\n\n\n private static bool IsTracke\n}\n\n\n public static bool IsControllerConnected(Controller controllerType)\n{\n\n\n\n\n\n\n\n    if (OVRManager.loadedXRDevice == OVRManager.XRDevice.OpenVR)\n    {\n        if ((controllerType & Controller.LTouch) != 0)\n        {\n            return IsValidOpenVRDevice(openVRControllerDetails[0].deviceI\n            return IsValidOpenVRDevice(openVRControllerDetails[0].dev\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  private static bool IsControllerConnected(Controller controllerType)\n  {\n      if ((controllerType & Controller.RTouch) != 0)\n          return IsValidOpenVRDevice(openVRControllerDetails[1].deviceId);\n      if ((controllerType & Controller.LHand) != 0)\n           return IsTrackedDeviceConnected(((int) openVRControllerDetails[0].state.ul\n       return true;\n\n\n\n\n      if ((controllerType & Controller.RHand) != 0)\n          return IsTrackedDeviceConnected(((int) openVRControllerDetails[1].state.u\n       return true;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  private static bool ShouldResolveController(Controller controllerType, Controller controllerMask)\n  {\n      if ((controllerMask & Controller.OneHand) != 0)\n      {\n          return ((controllerType & Controller.Touch) != 0);\n      }\n      if ((controllerMask & Controller.BothHands) != 0)\n      {\n          return ((controllerType & Controller.Hands) != 0);\n      }\n      return ((controllerType & controllerMask) != 0);\n  }\n\n \n }\n```",
    "code_repairing_3": "private static bool IsValidOpenVRDevice(uint deviceId)\n\t{\n\t\treturn (deviceId >= 0 && deviceId < OVR.OpenVR.k_unMaxTrackedDeviceCount);\n\t}\n\n private static bool IsValidOpenVRDevice(uint deviceId)\n\t{\n\t\treturn (deviceId >= 0 && deviceId < OVR.OpenVR.k_unMaxTrackedDeviceCount);\n\t}\n\n private static float CalculateAbsMax(float maxValue, float axis)\n\t{\n\t\tif (Mathf.Abs(axis) > maxValue)\n\t\t{\n\t\t\tmaxValue = axis;\n\t\t}\n\t\treturn maxValue;\n\t}\n\n private static Vector2 CalculateAbsMax(Vector2 maxValue, Vector2 axis)\n\t{\n\t\tmaxValue.x = Mathf.Max(maxValue.x, Mathf.Abs(axis.x));\n\t\tmaxValue.y = Mathf.Max(maxValue.y, Mathf.Abs(axis.y));\n\t\treturn maxValue;\n\t}\n\n private static Vector3 CalculateAbsMax(Vector3 maxValue, Vector3 axis)\n\t{\n\t\tmaxValue.x = Mathf.Max(maxValue.x, Mathf.Abs(axis.x));\n\t\tmaxValue.y = Mathf.Max(maxValue.y, Mathf.Abs(axis.y));\n\t\tmaxValue.z = Mathf.Max(maxValue.z, Mathf.Abs(axis.z));\n\t\treturn maxValue;\n\t}\n\n private static float CalculateDeadzone(float value, float deadzone)\n\t{\n\t\treturn (Mathf.Abs(value) > deadzone) ? Mathf.Sign(value) * (Mathf.Abs(value) - deadzone) / (1.0f - deadzone) : 0.0f;\n\t}\n\n private static Vector2 CalculateDeadzone(Vector2 value, float deadzone)\n\t{\n\t\tvalue.x = (Mathf.Abs(value.x) > deadzone) ? Mathf.Sign(value.x) * (Mathf.Abs(value.x) - deadzone) / (1.0f - deadzone) : 0.0f;\n\t\tvalue.y = (Mathf.Abs(value.y) > deadzone) ? Mathf.Sign(value.y) * (Mathf.Abs(value.y) - deadzone) / (1.0f - deadzone) : 0.0f;\n\t\treturn value;\n\t}\n\n private static Vector3 CalculateDeadzone(Vector3 value, float deadzone)\n\t{\n\t\tvalue.x = (Mathf.Abs(value.x) > deadzone) ? Mathf.Sign(value.x) * (Mathf.Abs(value.x) - deadzone) / (1.0f - deadzone) : 0.0f;\n\t\tvalue.y = (Mathf.Abs(value.y) > deadzone) ? Mathf.Sign(value.y) * (Mathf.Abs(value.y) - deadzone) / (1.0f - deadzone) : 0.0f;\n\t\tvalue.z = (Mathf.Abs(value.z) > deadzone) ? Mathf.Sign(value.z) * (Mathf.Abs(value.z) - deadzone) / (1.0f - deadzone) : 0.0f;\n\t\treturn value;\n\t}\n\n private static bool ShouldResolveController(Controller controllerType, Controller controllerMask)\n\t{\n\t\tif ((controllerType & controllerMask) == controllerType)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\nprivate static bool ShouldResolveController(Controller controllerType, Controller controllerMask)\n\t{\n\t\tif ((controllerType & controllerMask) == controllerType)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\nprivate static bool ShouldResolveController(Controller controllerType, Controller controllerMask)\n\t{\n\t\tif ((controllerType & controllerMask) == controllerType)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n private static bool ShouldResolveController(Controller controllerType, Controller controllerMask)\n\t{\n\t\tif ((controllerType & controllerMask) == controllerType)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\nprivate static bool ShouldResolveController(Controller controllerType, Controller controllerMask)\n\t{\n\t\tif ((controllerType & controllerMask) == controllerType)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n private static bool ShouldResolveController(Controller controllerType, Controller controllerMask)\n\t{\n\t\tif ((controllerType & controllerMask) == controllerType)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\nprivate static bool ShouldResolveController(Controller controllerType, Controller controllerMask)\n\t{\n\t\tif ((controllerType & controllerMask) == controllerType)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\nprivate static bool ShouldResolveController(Controller controllerType, Controller controllerMask)\n\t{\n\t\tif ((controllerType & controllerMask) == controllerType)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\nprivate static bool ShouldResolveController(Controller controllerType, Controller controllerMask)\n\t{\n\t\tif ((controllerType & controllerMask) == controllerType)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\nprivate static bool ShouldResolveController(Controller controllerType, Controller controllerMask)\n\t{\n\t\tif ((controllerType & controllerMask) == controllerType)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturollerType, Controller controllerMask)\n\t{\n\t\tif ((controllerType & controllerMask) == controllerType)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\nprivate static bool ShouldResolveController(Controller controllerType, Controller controllerMask)\n\t{\n\t\tif ((controllerType & controllerMask) == controllerType)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\nprivate static bool ShouldResolveController(Controller controllerType, Controller controllerMask)\n\t{\n\t\tif ((controllerType & controllerMask) == controllerType)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\nprivate static bool ShouldResolveController(Controller controllerType, Controller controllerMask)\n\t{\n\t\tif ((controllerType & controllerMask) == controllerType)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\nprivate static bool ShouldResolveController(Controller controllerType, Controller controllerMask)\n\t{\n\t\tif ((controllerType & controllerMask) == controllerType)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n private static bool ShouldResolveController(Controller contr",
    "code_repairing_4": "```c#\n  using System;\n  using System.Collections;\n  using System.Collections.Generic;\n  using System.Runtime.InteropServices;\n  using UnityEngine;\n\n  public static class OVRInput\n  {\n      [Flags]\n      public enum Button\n      {\n          None                      = 0,          \n          One                       = 0x00000001, \n          Two                       = 0x00000002, \n          Three                     = 0x00000004, \n          Four                      = 0x00000008, \n          Start                     = 0x00000100, \n          Back                      = 0x00000200, \n      }\n\n      [Flags]\n      public enum RawButton\n      {\n          None                      = 0,          \n          A                         = 0x00000001, \n          B                         = 0x00000002, \n          X                         = 0x00000100, \n          Y                         = 0x00000200, \n      }\n\n      [Flags]\n      public enum Touch\n      {\n          None                      = 0,\n          One                       = 0x00000001, \n          Two                       = 0x00000002, \n          Three                     = 0x00000004, \n          Four                      = 0x00000008, \n      }\n\n      [Flags]\n      public enum RawTouch\n      {\n          None                      = 0,          \n          A                         = 0x00000001, \n          B                         = 0x00000002, \n      }\n\n      [Flags]\n      public enum NearTouch\n      {\n          None                      = 0,          \n          PrimaryIndexTrigger       = 0x00000001, \n      }\n\n      [Flags]\n      public enum RawNearTouch\n      {\n          None                      = 0,          \n          LIndexTrigger             = 0x00000001, \n      }\n\n      [Flags]\n      public enum Axis1D\n      {\n          None                      = 0,     \n          PrimaryIndexTrigger       = 0x01,  \n      }\n\n      [Flags]\n      public enum RawAxis1D\n      {\n          None                      = 0,     \n          LIndexTrigger             = 0x01,  \n      }\n\n      [Flags]\n      public enum Axis2D\n      {\n          None                      = 0,     \n          PrimaryThumbstick         = 0x01,  \n      }\n\n      [Flags]\n      public enum RawAxis2D\n      {\n          None                      = 0,     \n          LThumbstick               = 0x01,  \n      }\n\n      public enum OpenVRButton //: ulong\n      {\n          None                      = 0,  \n          Two              = 0x0002,  \n          RThumbstick      = 0x10000000,  \n          Grip             = 0x0004,  \n      }\n\n      public static bool GetDown(Button virtualMask, Controller controllerMask = Controller.Active)\n      {\n          return GetResolvedButtonDown(virtualMask, RawButton.None, controllerMask);\n      }\n  }\n  ```"
}