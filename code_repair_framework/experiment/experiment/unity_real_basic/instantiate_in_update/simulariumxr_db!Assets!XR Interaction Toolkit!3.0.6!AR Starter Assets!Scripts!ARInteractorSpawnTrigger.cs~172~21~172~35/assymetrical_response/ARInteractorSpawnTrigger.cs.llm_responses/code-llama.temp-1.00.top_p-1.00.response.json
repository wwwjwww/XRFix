{
    "code_repairing_0": "Here is the updated code with the `Instantiate` function call moved to the `Start()` method, where building an object pool is more appropriate:\n```\nusing UnityEngine.EventSystems;\nusing UnityEngine.XR.ARFoundation;\nusing UnityEngine.XR.ARSubsystems;\nusing UnityEngine.XR.Interaction.Toolkit.Inputs.Readers;\nusing UnityEngine.XR.Interaction.Toolkit.Interactors;\nusing UnityEngine.XR.Interaction.Toolkit.Samples.StarterAssets;\n\nnamespace UnityEngine.XR.Interaction.Toolkit.Samples.ARStarterAssets\n{\n    public class ARInteractorSpawnTrigger : MonoBehaviour\n    {\n        public enum SpawnTriggerType\n        {\n            SelectAttempt,\n            InputAction,\n        }\n\n        [SerializeField]\n        [Tooltip(\"The AR ray interactor that determines where to spawn the object.\")]\n        XRRayInteractor m_ARInteractor;\n\n        public XRRayInteractor arInteractor\n        {\n            get => m_ARInteractor;\n            set => m_ARInteractor = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The behavior to use to spawn objects.\")]\n        ObjectSpawner m_ObjectSpawner;\n\n        public ObjectSpawner objectSpawner\n        {\n            get => m_ObjectSpawner;\n            set => m_ObjectSpawner = value;\n        }\n\n        bool m_RequireHorizontalUpSurface;\n\n        [SerializeField]\n        [Tooltip(\"Whether to require that the AR Interactor hits an AR Plane with a horizontal up alignment in order to spawn anything.\")]\n        bool m_RequireHorizontalUpSurface;\n\n        public bool requireHorizontalUpSurface\n        {\n            get => m_RequireHorizontalUpSurface;\n            set => m_RequireHorizontalUpSurface = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The type of trigger to use to spawn an object, either when the Interactor's select action occurs or \" +\n            \"when a button input is performed.\")]\n        SpawnTriggerType m_SpawnTriggerType;\n\n        public SpawnTriggerType spawnTriggerType\n        {\n            get => m_SpawnTriggerType;\n            set => m_SpawnTriggerType = value;\n        }\n\n        [SerializeField]\n        XRInputButtonReader m_SpawnObjectInput = new XRInputButtonReader(\"Spawn Object\");\n\n        public XRInputButtonReader spawnObjectInput\n        {\n            get => m_SpawnObjectInput;\n            set => XRInputReaderUtility.SetInputProperty(ref m_SpawnObjectInput, value, this);\n        }\n\n        [SerializeField]\n        [Tooltip(\"When enabled, spawn will not be triggered if an object is currently selected.\")]\n        bool m_BlockSpawnWhenInteractorHasSelection = true;\n\n        public bool blockSpawnWhenInteractorHasSelection\n        {\n            get => m_BlockSpawnWhenInteractorHasSelection;\n            set => m_BlockSpawnWhenInteractorHasSelection = value;\n        }\n\n        bool m_AttemptSpawn;\n        bool m_EverHadSelection;\n\n        void OnEnable()\n        {\n            m_SpawnObjectInput.EnableDirectActionIfModeUsed();\n        }\n\n        void OnDisable()\n        {\n            m_SpawnObjectInput.DisableDirectActionIfModeUsed();\n        }\n\n        void Start()\n        {\n            if (m_ObjectSpawner == null)\n#if UNITY_2023_1_OR_NEWER\n                m_ObjectSpawner = FindAnyObjectByType<ObjectSpawner>();\n#else\n                m_ObjectSpawner = FindObjectOfType<ObjectSpawner>();\n#endif\n\n            if (m_ARInteractor == null)\n            {\n                Debug.LogError(\"Missing AR Interactor reference, disabling component.\", this);\n                enabled = false;\n            }\n\n            ObjectPool<GameObject> pool = new ObjectPool<GameObject>(20);\n\n            // Load the objects into the pool\n            foreach (var prefab in m_ObjectPrefabs)\n            {\n                var loaded = Instantiate(prefab);\n                pool.Add(loaded);\n            }\n        }\n\n        public bool TrySpawnObject(Vector3 spawnPoint, Vector3 spawnNormal)\n        {\n            var pool = GameObject.Find(\"ObjectPool\").GetComponent<ObjectPool<GameObject>>();\n            var newObject = pool.Get();\n\n            newObject.transform.position = spawnPoint;\n            EnsureFacingCamera();\n\n            var facePosition = m_CameraToFace.transform.position;\n            var forward = facePosition - spawnPoint;\n            BurstMathUtility.ProjectOnPlane(forward, spawnNormal, out var projectedForward);\n            newObject.transform.rotation = Quaternion.LookRotation(projectedForward, spawnNormal);\n\n            if (m_ApplyRandomAngleAtSpawn)\n            {\n                var randomRotation = Random.Range(-m_SpawnAngleRange, m_SpawnAngleRange);\n                newObject.transform.Rotate(Vector3.up, randomRotation);\n            }\n\n            if (m_SpawnVisualizationPrefab != null)\n            {\n                var visualizationTrans = Instantiate(m_SpawnVisualizationPrefab).transform;\n                visualizationTrans.position = spawnPoint;\n                visualizationTrans.rotation = newObject.transform.rotation;\n            }\n\n            objectSpawned?.Invoke(newObject);\n            return true;\n        }\n    }\n}\n```\nThe changes made to the code are as follows:\n\n* The `Instantiate` function call has been moved to the `Start()` method, where building an object pool is more appropriate.\n* A new `ObjectPool` component has been added to the object pool game object, which manages the prefabs in the pool.\n* The `TrySpawnObject` method now retrieves a prefab from the object pool using the `Get()` method and returns it.\n\nThis modification should help reduce the CPU load caused by the `Instantiate` function call in the `Update()` method.",
    "code_repairing_1": "```\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine.XR.Interaction.Toolkit.Utilities;\n\nnamespace UnityEngine.XR.Interaction.Toolkit.Samples.StarterAssets\n{\n\n\n  public class ObjectSpawner : MonoBehaviour\n  {\n    [SerializeField]\n    [Tooltip(\"The camera that objects will face when spawned. If not set, defaults to the main camera.\")]\n    Camera m_CameraToFace;\n\n\n    public Camera cameraToFace\n    {\n      get\n      {\n        EnsureFacingCamera();\n        return m_CameraToFace;\n      }\n      set => m_CameraToFace = value;\n    }\n\n    [SerializeField]\n    [Tooltip(\"The list of prefabs available to spawn.\")]\n    List<GameObject> m_ObjectPrefabs = new List<GameObject>();\n\n\n    public List<GameObject> objectPrefabs\n    {\n      get => m_ObjectPrefabs;\n      set => m_ObjectPrefabs = value;\n    }\n\n    [SerializeField]\n    [Tooltip(\"Optional prefab to spawn for each spawned object. Use a prefab with the Destroy Self component to make \" +\n        \"sure the visualization only lives temporarily.\")]\n    GameObject m_SpawnVisualizationPrefab;\n\n\n    public GameObject spawnVisualizationPrefab\n    {\n      get => m_SpawnVisualizationPrefab;\n      set => m_SpawnVisualizationPrefab = value;\n    }\n\n    [SerializeField]\n    [Tooltip(\"The index of the prefab to spawn. If outside the range of the list, this behavior will select \" +\n        \"a random object each time it spawns.\")]\n    int m_SpawnOptionIndex = -1;\n\n\n    public int spawnOptionIndex\n    {\n      get => m_SpawnOptionIndex;\n      set => m_SpawnOptionIndex = value;\n    }\n    bool m_OnlySpawnInView = true;\n\n\n    public bool onlySpawnInView\n    {\n      get => m_OnlySpawnInView;\n      set => m_OnlySpawnInView = value;\n    }\n    private List<ObjectSpawner> pool;\n\n\n    public void Start()\n    {\n        ObjectSpawnerPool(this);\n    }\n\n    static public void ObjectSpawnerPool(ObjectSpawner sp)\n    {\n        if (sp == null) return;\n        if (pool == null) pool = new List<ObjectSpawner>();\n        pool.Add(sp);\n    }\n\n    [SerializeField]\n    [Tooltip(\"The size, in viewport units, of the periphery inside the viewport that will not be considered in view.\")]\n    float m_ViewportPeriphery = 0.15f;\n\n\n    public float viewportPeriphery\n    {\n      get => m_ViewportPeriphery;\n      set => m_ViewportPeriphery = value;\n    }\n\n    [SerializeField]\n    [Tooltip(\"Whether to spawn each object as a child of this object.\")]\n    bool m_SpawnAsChildren;\n\n\n    public bool spawnAsChildren\n    {\n      get => m_SpawnAsChildren;\n      set => m_SpawnAsChildren = value;\n    }\n\n\n  ...............................................................................................\n\n     //you can try to build an object pool before Update() method has been called.\n     public bool TrySpawnObject(Vector3 spawnPoint, Vector3 spawnNormal)\n     {\n       if ( pool !=null && pool.Count > 0)\n       {\n         foreach (var b in pool)\n         {\n           if (pool.TryGetValue(b, out var value))\n           {\n             pool.Remove(b);\n           }\n         }\n       }\n       else if (transform.childCount > 0)\n       {\n         return false;\n       }\n\n       if (m_OnlySpawnInView)\n       {\n         var inViewMin = m_ViewportPeriphery;\n         var inViewMax = 1f - m_ViewportPeriphery;\n         var pointInViewportSpace = cameraToFace.WorldToViewportPoint(spawnPoint);\n         if (pointInViewportSpace.z < 0f || pointInViewportSpace.x > inViewMax || pointInViewportSpace.x < inViewMin ||\n           pointInViewportSpace.y > inViewMax || pointInViewportSpace.y < inViewMin)\n         {\n           return false;\n         }\n       }\n\n       var objectIndex = isSpawnOptionRandomized ? Random.Range(0, m_ObjectPrefabs.Count) : m_SpawnOptionIndex;\n       var newObject = Instantiate(m_ObjectPrefabs[objectIndex]);\n       if (m_SpawnAsChildren)\n         newObject.transform.parent = transform;\n\n       newObject.transform.position = spawnPoint;\n       EnsureFacingCamera();\n\n       var facePosition = m_CameraToFace.transform.position;\n       var forward = facePosition - spawnPoint;\n       BurstMathUtility.ProjectOnPlane(forward, spawnNormal, out var projectedForward);\n       newObject.transform.rotation = Quaternion.LookRotation(projectedForward, spawnNormal);\n\n       if (m_ApplyRandomAngleAtSpawn)\n       {\n         var randomRotation = Random.Range(-m_SpawnAngleRange, m_SpawnAngleRange);\n         newObject.transform.Rotate(Vector3.up, randomRotation);\n       }\n\n       if (m_SpawnVisualizationPrefab != null)\n       {\n         var visualizationTrans = Instantiate(m_SpawnVisualizationPrefab).transform;\n         visualizationTrans.position = spawnPoint;\n         visualizationTrans.rotation = newObject.transform.rotation;\n       }\n\n       objectSpawned?.Invoke(newObject);\n       return true;\n     }\n\n     void Awake()\n     {\n       EnsureFacingCamera();\n     }\n\n     void EnsureFacingCamera()\n     {\n       if (m_CameraToFace == null)\n         m_CameraToFace = Camera.main;\n     }\n   }\n}\n```",
    "code_repairing_2": "To fix the issue with the `Instantiate` method being called in the `Update` method, you can try to build an object pool before the `Update` method has been called.\n\nYou can do this by adding the following code in the `Start` method of the `ARInteractorSpawnTrigger` script:\n```csharp\n#if AR_FOUNDATION_PRESENT\nusing UnityEngine.EventSystems;\nusing UnityEngine.XR.ARFoundation;\nusing UnityEngine.XR.ARSubsystems;\nusing UnityEngine.XR.Interaction.Toolkit.Inputs.Readers;\nusing UnityEngine.XR.Interaction.Toolkit.Interactors;\nusing UnityEngine.XR.Interaction.Toolkit.Samples.StarterAssets;\n\nnamespace UnityEngine.XR.Interaction.Toolkit.Samples.ARStarterAssets\n{\n    public class ARInteractorSpawnTrigger : MonoBehaviour\n    {\n        private ObjectPool _objectPool;\n\n        public void BuildObjectPool()\n        {\n            _objectPool = new ObjectPool();\n            _objectPool.BuildPool(10, m_ObjectPrefabs);\n        }\n\n        void Start()\n        {\n            BuildObjectPool();\n        }\n\n        // rest of the code\n}\n```\nThis will create an object pool of size 10, which you can use to avoid the cost of allocating and deallocating objects constantly.\n\nIn addition, you can also consider using a technique called \"entity-component system\" or \"ECS\", which is a lightweight and efficient way to manage gameobjects.\n\nIn Unity, you can use the `MonoBehaviour` class as a component, which allows you to add additional functionality to existing components in the game.\n\nHere is an example of how to use an entity-component system to spawn objects:\n```csharp\n#if AR_FOUNDATION_PRESENT\nusing UnityEngine.EventSystems;\nusing UnityEngine.XR.ARFoundation;\nusing UnityEngine.XR.ARSubsystems;\nusing UnityEngine.XR.Interaction.Toolkit.Inputs.Readers;\nusing UnityEngine.XR.Interaction.Toolkit.Interactors;\nusing UnityEngine.XR.Interaction.Toolkit.Samples.StarterAssets;\n\nnamespace UnityEngine.XR.Interaction.Toolkit.Samples.ARStarterAssets\n{\n    public class ARInteractorSpawnTrigger : MonoBehaviour\n    {\n        [SerializeField]\n        [Tooltip(\"The AR ray interactor that determines where to spawn the object.\")]\n        XRRayInteractor m_ARInteractor;\n\n        [SerializeField]\n        [Tooltip(\"The behavior to use to spawn objects.\")]\n        ObjectSpawner m_ObjectSpawner;\n\n        // Other code\n\n        private readonly List<GameObject> _spawnQueue = new List<GameObject>();\n        private readonly Dictionary<GameObject, bool> _objectsInPool = new Dictionary<GameObject, bool>();\n\n        // Pool management\n        private void SpawnObject(ARRaycastHit hit)\n        {\n            // Get free object from pool\n            GameObject newObject = _objectSpawner.GetObjectFromPool();\n\n            // Add object to spawn queue\n            _spawnQueue.Add(newObject);\n\n            // Set spawn position and rotation\n            newObject.transform.position = hit.pose.position;\n            newObject.transform.rotation = Quaternion.LookRotation(hit.ray.direction, hit.pose.up);\n\n            // Add object to object pool\n            _objectsInPool.Add(newObject, true);\n        }\n\n        private void Update()\n        {\n            // Process spawn queue\n            foreach (GameObject spawnedObject in _spawnQueue)\n            {\n                // Check if object is still in pool\n                if (_objectsInPool.ContainsKey(spawnedObject) && !_objectsInPool[spawnedObject])\n                {\n                    // If not, remove object from spawn queue and destroy it\n                    _spawnQueue.Remove(spawnedObject);\n                    Destroy(spawnedObject);\n                }\n            }\n        }\n\n        // Rest of the code\n\n        private class ObjectPooling\n        {\n            private static List<GameObject> _pool = new List<GameObject>();\n\n            // Build pool\n            public void BuildPool(int size, GameObject[] prefabs)\n            {\n                for (int i = 0; i < size; i++)\n                {\n                    GameObject obj = Instantiate(prefabs[i]);\n                    _pool.Add(obj);\n                }\n            }\n\n            // Get object from pool\n            public GameObject GetObjectFromPool()\n            {\n                if (_pool.Count == 0)\n                {\n                    Debug.LogError(\"Pool is empty.\");\n                    return null;\n                }\n                else\n                {\n                    return _pool[0];\n                }\n            }\n        }\n\n    }\n}\n```\nThis will create an entity-component system using `MonoBehaviour` as a component, which allows you to add additional functionality to existing components in the game.\nYou can also use this technique to improve the performance by using a `List` of gameobjects to store the objects you want to be pooled.\n\nHowever, keep in mind that this approach may still cause performance bottlenecks, especially if you spawn many objects.\n\nIn this case, you may consider using a prefab pooling system, where you create a prefab with the object you want to be pooled, and then instantiate it when you need it.\nThis can give you a significant performance boost over the other approaches, because prefabs are already instantiated and can be quickly instantiated.\n\nIn Unity, you can use the `PrefabUtility` class to create a prefab, and then use the `GameObject.Instantiate` method to create an instance of the prefab.\nFor example:\n```csharp\nusing UnityEngine;\n\npublic class MyScript: MonoBehaviour\n{\n    public GameObject MyPrefab;\n\n    private void Start()\n    {\n        GameObject instance = GameObject.Instantiate(MyPrefab);\n        instance.transform.position = Vector3.zero;\n    }\n}\n```\nIn this example, we create a prefab called `MyPrefab` and then instantiate it using the `GameObject.Instantiate` method. We also set its position to the origin using the `transform.position` property.",
    "code_repairing_3": "The bug described in the issue can be fixed by building an object pool in the Start() method before Update() is called. Here's the code fix:\n\n//Here's the definition of function call in another component.\n//Related code from /Assets/XR Interaction Toolkit/3.0.6/Starter Assets/Scripts/ObjectSpawner.cs:\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine.XR.Interaction.Toolkit.Utilities;\n#if AR_FOUNDATION_PRESENT\nusing UnityEngine.XR.ARFoundation;\n#endif\n\nnamespace UnityEngine.XR.Interaction.Toolkit.Samples.StarterAssets\n{\n    public class ARInteractorSpawnTrigger : MonoBehaviour\n    {\n        public enum SpawnTriggerType\n        {\n            SelectAttempt,\n            InputAction\n        }\n\n        [SerializeField]\n        [Tooltip(\"The AR ray interactor that determines where to spawn the object.\")]\n        XRRayInteractor m_ARInteractor;\n\n        public XRRayInteractor arInteractor\n        {\n            get { return m_ARInteractor; }\n            set { m_ARInteractor = value; }\n        }\n\n        [SerializeField]\n        [Tooltip(\"The behavior to use to spawn objects.\")]\n        ObjectSpawner m_ObjectSpawner;\n\n        public ObjectSpawner objectSpawner\n        {\n            get { return m_ObjectSpawner; }\n            set { m_ObjectSpawner = value;\n                 // Build the object pool before the start of the game\n                 if (value != null && value.objectPrefabs.Count > 0)\n                 {\n                     for (int i = 0; i < value.objectPrefabs.Count; i++)\n                     {\n                         GameObject spawnedObj = Instantiate(value.objectPrefabs[i]);\n                         spawnedObj.transform.parent = this.transform;\n                         spawnedObj.transform.position = Vector3.zero;\n                     }\n                 \n                     Debug.Log(\"Built Object Pool\");\n                 }\n             }\n        }\n\n        [SerializeField]\n        [Tooltip(\"Whether to require that the AR Interactor hits an AR Plane with a horizontal up alignment in order to spawn anything.\")]\n        bool m_RequireHorizontalUpSurface;\n\n        public bool requireHorizontalUpSurface\n        {\n            get { return m_RequireHorizontalUpSurface; }\n            set { m_RequireHorizontalUpSurface = value; }\n        }\n\n        [SerializeField]\n        [Tooltip(\"The type of trigger to use to spawn an object, either when the Interactor's select action occurs or \" +\n        \"when a button input is performed.\")]\n        SpawnTriggerType m_SpawnTriggerType;\n\n        public SpawnTriggerType spawnTriggerType\n        {\n            get { return m_SpawnTriggerType; }\n            set { m_SpawnTriggerType = value; }\n        }\n\n        [SerializeField]\n        XRInputButtonReader m_SpawnObjectInput = new XRInputButtonReader(\"Spawn Object\");\n\n        public XRInputButtonReader spawnObjectInput\n        {\n            get { return m_SpawnObjectInput; }\n            set { XRInputReaderUtility.SetInputProperty(ref m_SpawnObjectInput, value, this); }\n        }\n\n        [SerializeField]\n        [Tooltip(\"When enabled, spawn will not be triggered if an object is currently selected.\")]\n        bool m_BlockSpawnWhenInteractorHasSelection = true;\n\n        public bool blockSpawnWhenInteractorHasSelection\n        {\n            get { return m_BlockSpawnWhenInteractorHasSelection; }\n            set { m_BlockSpawnWhenInteractorHasSelection = value; }\n        }\n\n        bool m_AttemptSpawn = false;\n        bool m_EverHadSelection;\n\n        void OnEnable()\n        {\n            m_SpawnObjectInput.EnableDirectActionIfModeUsed();\n        }\n\n        void OnDisable()\n        {\n            m_SpawnObjectInput.DisableDirectActionIfModeUsed();\n        }\n\n        void Start()\n        {\n        }\n    }\n}",
    "code_repairing_4": "Here's the fixed code:\nFINAL CODE:\n\n//Herere the buggy code lines from /Assets/XR Interaction Toolkit/3.0.6/AR Starter Assets/Scripts/ARInteractorSpawnTrigger.cs:\nusing System.Collections;\nusing UnityEngine;\nusing UnityEngine.EventSystems;\nusing UnityEngine.XR.ARFoundation;\nusing UnityEngine.XR.ARSubsystems;\nusing UnityEngine.XR.Interaction.Toolkit.Inputs.Readers;\nusing UnityEngine.XR.Interaction.Toolkit.Interactors;\nusing UnityEngine.XR.Interaction.Toolkit.Samples.StarterAssets;\n\nnamespace UnityEngine.XR.Interaction.Toolkit.Samples.ARStarterAssets\n{\n\n\n\npublic class ARInteractorSpawnTrigger : MonoBehaviour\n{\n\n\n\n public enum SpawnTriggerType\n {\n\n\n\n\n SelectAttempt,\n\n\n\n\n InputAction,\n }\n\n [SerializeField]\n [Tooltip(\"The AR ray interactor that determines where to spawn the object.\")]\n XRRayInteractor m_ARInteractor;\n\n\n\n\n public XRRayInteractor arInteractor\n {\n get => m_ARInteractor;\n set => m_ARInteractor = value;\n }\n\n [SerializeField]\n [Tooltip(\"The behavior to use to spawn objects.\")]\n ObjectSpawner m_ObjectSpawner;\n\n\n\n\n public ObjectSpawner objectSpawner\n {\n get => m_ObjectSpawner;\n set => m_ObjectSpawner = value;\n }\n\n [SerializeField]\n [Tooltip(\"Whether to require that the AR Interactor hits an AR Plane with a horizontal up alignment in order to spawn anything.\")]\n bool m_RequireHorizontalUpSurface;\n\n\n\n\n\n public bool requireHorizontalUpSurface\n {\n get => m_RequireHorizontalUpSurface;\n set => m_RequireHorizontalUpSurface = value;\n }\n\n [SerializeField]\n [Tooltip(\"The type of trigger to use to spawn an object, either when the Interactor's select action occurs or \" +\n \"when a button input is performed.\")]\n SpawnTriggerType m_SpawnTriggerType;\n\n\n\n\n public SpawnTriggerType spawnTriggerType\n {\n get => m_SpawnTriggerType;\n set => m_SpawnTriggerType = value;\n }\n\n [SerializeField]\n XRInputButtonReader m_SpawnObjectInput = new XRInputButtonReader(\"Spawn Object\");\n\n\n\n\n public XRInputButtonReader spawnObjectInput\n {\n get => m_SpawnObjectInput;\n set => XRInputReaderUtility.SetInputProperty(ref m_SpawnObjectInput, value, this);\n }\n\n [SerializeField]\n [Tooltip(\"When enabled, spawn will not be triggered if an object is currently selected.\")]\n bool m_BlockSpawnWhenInteractorHasSelection = true;\n\n\n\n\n\n public bool blockSpawnWhenInteractorHasSelection\n {\n get => m_BlockSpawnWhenInteractorHasSelection;\n set => m_BlockSpawnWhenInteractorHasSelection = value;\n }\n\n bool m_AttemptSpawn;\n bool m_EverHadSelection;\n\n\n\n\n void OnEnable()\n {\n m_SpawnObjectInput.EnableDirectActionIfModeUsed();\n }\n\n\n\n\n void OnDisable()\n {\n m_SpawnObjectInput.DisableDirectActionIfModeUsed();\n }\n\n\n\n\n void FixedUpdate()\n {\n if (m_AttemptSpawn)\n {\n m_AttemptSpawn = false;\n\n\n\n\n\n\n /* BUG: Instantiate in Update() method\n * MESSAGE: Update() method is called each frame. It's inefficient to use Instantiate() in Update() method.\n *         void Update()\n *         {\n * \n * \n * \n *         if (m_AttemptSpawn)\n *          {\n *              m_AttemptSpawn = false;\n * \n * \n *              var isPointerOverUI = EventSystem.current != null && EventSystem.current.IsPointerOverGameObject(-1);\n *              if (!isPointerOverUI && m_ARInteractor.TryGetCurrentARRaycastHit(out var arRaycastHit))\n *              {\n *                  if (!(arRaycastHit.trackable is ARPlane arPlane))\n *                      return;\n * \n *                  if (m_RequireHorizontalUpSurface && arPlane.alignment != PlaneAlignment.HorizontalUp)\n *                      return;\n * \n *                  m_ObjectSpawner.TrySpawnObject(arRaycastHit.pose.position, arPlane.normal);\n *              }\n * \n *              return;\n *          }\n * \n *          var selectState = m_ARInteractor.logicalSelectState;\n * \n *          if (m_BlockSpawnWhenInteractorHasSelection)\n *          {\n *              if (selectState.wasPerformedThisFrame)\n *                  m_EverHadSelection = m_ARInteractor.hasSelection;\n *              else if (selectState.active)\n *                  m_EverHadSelection |= m_ARInteractor.hasSelection;\n *          }\n * \n *          m_AttemptSpawn = false;\n *          switch (m_SpawnTriggerType)\n *          {\n *              case SpawnTriggerType.SelectAttempt:\n *                  if (selectState.wasCompletedThisFrame)\n *                      m_AttemptSpawn = !m_ARInteractor.hasSelection && !m_EverHadSelection;\n *                  break;\n * \n *              case SpawnTriggerType.InputAction:\n *                  if (m_SpawnObjectInput.ReadWasPerformedThisFrame())\n *                      m_AttemptSpawn = !m_ARInteractor.hasSelection && !m_EverHadSelection;\n *                  break;\n *          }\n *      }\n//Here's the definition of function call in another component.\n//Related code from /Assets/XR Interaction Toolkit/3.0.6/Starter Assets/Scripts/ObjectSpawner.cs:\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine.XR.Interaction.Toolkit.Utilities;\n\nnamespace UnityEngine.XR.Interaction.Toolkit.Samples.StarterAssets\n{\n\n\n\npublic class ObjectSpawner : MonoBehaviour\n{\n[SerializeField]\n[Tooltip(\"The camera that objects will face when spawned. If not set, defaults to the main camera.\")]\nCamera m_CameraToFace;\n\n\n\n\npublic Camera cameraToFace\n{\nget\n{\nEnsureFacingCamera();\nreturn m_CameraToFace;\n}\nset => m_CameraToFace = value;\n}\n\n[SerializeField]\n[Tooltip(\"The list of prefabs available to spawn.\")]\nList<GameObject> m_ObjectPrefabs = new List<GameObject>();\n\n\n\n\npublic List<GameObject> objectPrefabs\n{\nget => m_ObjectPrefabs;\nset => m_ObjectPrefabs = value;\n}\n\n[SerializeField]\n[Tooltip(\"Optional prefab to spawn for each spawned object. Use a prefab with the Destroy Self component to make \" +\n\"sure the visualization only lives temporarily.\")]\nGameObject m_SpawnVisualizationPrefab;\n\n\n\n\n\npublic GameObject spawnVisualizationPrefab\n{\nget => m_SpawnVisualizationPrefab;\nset => m_SpawnVisualizationPrefab = value;\n}\n\n[SerializeField]\n[Tooltip(\"The index of the prefab to spawn. If outside the range of the list, this behavior will select \" +\n\"a random object each time it spawns.\")]\nint m_SpawnOptionIndex = -1;\n\n\n\n\n\n\npublic int spawnOptionIndex\n{\nget => m_SpawnOptionIndex;\nset => m_SpawnOptionIndex = value;\n}\n\n\n\n\n\n\npublic bool isSpawnOptionRandomized => m_SpawnOptionIndex < 0 || m_SpawnOptionIndex >= m_ObjectPrefabs.Count;\n\n[SerializeField]\n[Tooltip(\"Whether to only spawn an object if the spawn point is within view of the camera.\")]\nbool m_OnlySpawnInView = true;\n\n\n\n\npublic bool onlySpawnInView\n{\nget => m_OnlySpawnInView;\nset => m_OnlySpawnInView = value;\n}\n\n[SerializeField]\n[Tooltip(\"The size, in viewport units, of the periphery inside the viewport that will not be considered in view.\")]\nfloat m_ViewportPeriphery = 0.15f;\n\n\n\n\npublic float viewportPeriphery\n{\nget => m_ViewportPeriphery;\nset => m_ViewportPeriphery = value;\n}\n\n[SerializeField]\n[Tooltip(\"When enabled, the object will be rotated about the y-axis when spawned by Spawn Angle Range, \" +\n\"in relation to the direction of the spawn point to the camera.\")]\nbool m_ApplyRandomAngleAtSpawn = true;\n\n\n\n\n\npublic bool applyRandomAngleAtSpawn\n{\nget => m_ApplyRandomAngleAtSpawn;\nset => m_ApplyRandomAngleAtSpawn = value;\n}\n\n[SerializeField]\n[Tooltip(\"The range in degrees that the object will randomly be rotated about the y axis when spawned, \" +\n\"in relation to the direction of the spawn point to the camera.\")]\nfloat m_SpawnAngleRange = 45f;\n\n\n\n\n\npublic float spawnAngleRange\n{\nget => m_SpawnAngleRange;\nset => m_SpawnAngleRange = value;\n}\n\n[SerializeField]\n[Tooltip(\"Whether to spawn each object as a child of this object.\")]\nbool m_SpawnAsChildren;\n\n\n\n\npublic bool spawnAsChildren\n{\nget => m_SpawnAsChildren;\nset => m_SpawnAsChildren = value;\n}\n\n\n\n\n\npublic event Action<GameObject> objectSpawned;\n\n\n\n\nvoid Awake()\n{\nEnsureFacingCamera();\n}\n\nvoid EnsureFacingCamera()\n{\nif (m_CameraToFace == null)\nm_CameraToFace = Camera.main;\n}\n\n\n\n\n\n\npublic void RandomizeSpawnOption()\n{\nm_SpawnOptionIndex = -1;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n*         public bool TrySpawnObject(Vector3 spawnPoint, Vector3 spawnNormal)\n*         {\n*             if (transform.childCount > 0)\n*             {\n*                 return false;\n*             }\n*             \n*             if (m_OnlySpawnInView)\n*             {\n*                 var inViewMin = m_ViewportPeriphery;\n*                 var inViewMax = 1f - m_ViewportPeriphery;\n*                 var pointInViewportSpace = cameraToFace.WorldToViewportPoint(spawnPoint);\n*                 if (pointInViewportSpace.z < 0f || pointInViewportSpace.x > inViewMax || pointInViewportSpace.x < inViewMin ||\n*                     pointInViewportSpace.y > inViewMax || pointInViewportSpace.y < inViewMin)\n*                 {\n*                     return false;\n*                 }\n*             }\n* \n*             var objectIndex = isSpawnOptionRandomized ? Random.Range(0, m_ObjectPrefabs.Count) : m_SpawnOptionIndex;\n*             var newObject = Instantiate(m_ObjectPrefabs[objectIndex]);\n*             if (m_SpawnAsChildren)\n*                 newObject.transform.parent = transform;\n* \n*             newObject.transform.position = spawnPoint;\n*             EnsureFacingCamera();\n* \n*             var facePosition = m_CameraToFace.transform.position;\n*             var forward = facePosition - spawnPoint;\n*             BurstMathUtility.ProjectOnPlane(forward, spawnNormal, out var projectedForward);\n*             newObject.transform.rotation = Quaternion.LookRotation(projectedForward, spawnNormal);\n* \n*             if (m_ApplyRandomAngleAtSpawn)\n*             {\n*                 var randomRotation = Random.Range(-m_SpawnAngleRange, m_SpawnAngleRange);\n*                 newObject.transform.Rotate(Vector3.up, randomRotation);\n*             }\n* \n*             if (m_SpawnVisualizationPrefab != null)\n*             {\n*                 var visualizationTrans = Instantiate(m_SpawnVisualizationPrefab).transform;\n*                 visualizationTrans.position = spawnPoint;\n*                 visualizationTrans.rotation = newObject.transform.rotation;\n*             }\n* \n*             objectSpawned?.Invoke(newObject);\n*             return true;\n*         }\n\n* //Here's the definition of function call in another component.\n* //Related code from /Assets/XR Interaction Toolkit/3.0.6/StarterAssets/Scripts/ObjectSpawner.cs:\n/*\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine.XR.Interaction.Toolkit.Utilities;\n\nnamespace UnityEngine.XR.Interaction.Toolkit.Samples.StarterAssets\n{\n\n\n\npublic class ObjectSpawner : MonoBehaviour\n{\n[SerializeField]\n[Tooltip(\"The camera that objects will face when spawned. If not set, defaults to the main camera.\")]\nCamera m_CameraToFace;\n\n\n\n\npublic Camera cameraToFace\n{\nget\n{\nEnsureFacingCamera();\nreturn m_CameraToFace;\n}\nset => m_CameraToFace = value;\n}\n\n[SerializeField]\n[Tooltip(\"The list of prefabs available to spawn.\")]\nList<GameObject> m_ObjectPrefabs = new List<GameObject>();\n\n\n\n\npublic List<GameObject> objectPrefabs\n{\nget => m_ObjectPrefabs;\nset => m_ObjectPrefabs = value;\n}\n\n[SerializeField]\n[Tooltip(\"Optional prefab to spawn for each spawned object. Use a prefab with the Destroy Self component to make \" +\n\"sure the visualization only lives temporarily.\")]\nGameObject m_SpawnVisualizationPrefab;\n\n\n\n\n\npublic GameObject spawnVisualizationPrefab\n{\nget => m_SpawnVisualizationPrefab;\nset => m_SpawnVisualizationPrefab = value;\n}\n\n[SerializeField]\n[Tooltip(\"The index of the prefab to spawn. If outside the range of the list, this behavior will select \" +\n\"a random object each time it spawns.\")]\nint m_SpawnOptionIndex = -1;\n\n\n\n\n\n\npublic int spawnOptionIndex\n{\nget => m_SpawnOptionIndex;\nset => m_SpawnOptionIndex = value;\n}\n\n\n\n\n\n\npublic bool isSpawnOptionRandomized => m_SpawnOptionIndex < 0 || m_SpawnOptionIndex >= m_ObjectPrefabs.Count;\n\n[SerializeField]\n[Tooltip(\"Whether to only spawn an object if the spawn point is within view of the camera.\")]\nbool m_OnlySpawnInView = true;\n\n\n\n\npublic bool onlySpawnInView\n{\nget => m_OnlySpawnInView;\nset => m_OnlySpawnInView = value;\n}\n\n[SerializeField]\n[Tooltip(\"The size, in viewport units, of the periphery inside the viewport that will not be considered in view.\")]\nfloat m_ViewportPeriphery = 0.15f;\n\n\n\n\npublic float viewportPeriphery\n{\nget => m_ViewportPeriphery;\nset => m_ViewportPeriphery = value;\n}\n\n[SerializeField]\n[Tooltip(\"When enabled, the object will be rotated about the y-axis when spawned by Spawn Angle Range, \" +\n\"in relation to the direction of the spawn point to the camera.\")]\nbool m_ApplyRandomAngleAtSpawn = true;\n\n\n\n\n\npublic bool applyRandomAngleAtSpawn\n{\nget => m_ApplyRandomAngleAtSpawn;\nset => m_ApplyRandomAngleAtSpawn"
}