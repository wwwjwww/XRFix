"{\"id\":\"chatcmpl-B4fg7isC6lcvdzpfMaB30vymIQybX\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\n// FIXED CODE: OVROverlaySample.cs\\n\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\nusing System;\\n\\nnamespace OculusSampleFramework\\n{\\n    public class OVROverlaySample : MonoBehaviour\\n    {\\n        bool inMenu;\\n\\n        const string ovrOverlayID = \\\"OVROverlayID\\\";\\n        const string applicationID = \\\"ApplicationID\\\";\\n        const string noneID = \\\"NoneID\\\";\\n\\n        Toggle applicationRadioButton;\\n        Toggle noneRadioButton;\\n\\n        [Header(\\\"App vs Compositor Comparison Settings\\\")]\\n        public GameObject mainCamera;\\n        public GameObject uiCamera;\\n        public GameObject uiGeoParent;\\n        public GameObject worldspaceGeoParent;\\n        public OVROverlay cameraRenderOverlay;\\n        public OVROverlay renderingLabelOverlay;\\n        public Texture applicationLabelTexture;\\n        public Texture compositorLabelTexture;\\n\\n        [Header(\\\"Level Loading Sim Settings\\\")]\\n        public GameObject prefabForLevelLoadSim;\\n        public OVROverlay cubemapOverlay;\\n        public OVROverlay loadingTextQuadOverlay;\\n        public float distanceFromCamToLoadText;\\n        public float cubeSpawnRadius;\\n        public float heightBetweenItems;\\n        public int numObjectsPerLevel;\\n        public int numLevels;\\n        public int numLoopsTrigger = 500000000;\\n        List<GameObject> spawnedCubes = new List<GameObject>();\\n\\n        Queue<GameObject> objectPool = new Queue<GameObject>();\\n\\n        #region MonoBehaviour handler\\n\\n        void Start()\\n        {\\n            DebugUIBuilder.instance.AddLabel(\\\"OVROverlay Sample\\\");\\n            DebugUIBuilder.instance.AddDivider();\\n            DebugUIBuilder.instance.AddLabel(\\\"Level Loading Example\\\");\\n            DebugUIBuilder.instance.AddButton(\\\"Simulate Level Load\\\", TriggerLoad);\\n            DebugUIBuilder.instance.AddButton(\\\"Destroy Cubes\\\", TriggerUnload);\\n            DebugUIBuilder.instance.AddDivider();\\n            DebugUIBuilder.instance.AddLabel(\\\"OVROverlay vs. Application Render Comparison\\\");\\n            DebugUIBuilder.instance\\n                .AddRadio(\\\"OVROverlay\\\", \\\"group\\\", delegate(Toggle t) { RadioPressed(ovrOverlayID, \\\"group\\\", t); })\\n                .GetComponentInChildren<Toggle>();\\n            applicationRadioButton = DebugUIBuilder.instance\\n                .AddRadio(\\\"Application\\\", \\\"group\\\", delegate(Toggle t) { RadioPressed(applicationID, \\\"group\\\", t); })\\n                .GetComponentInChildren<Toggle>();\\n            noneRadioButton = DebugUIBuilder.instance\\n                .AddRadio(\\\"None\\\", \\\"group\\\", delegate(Toggle t) { RadioPressed(noneID, \\\"group\\\", t); })\\n                .GetComponentInChildren<Toggle>();\\n\\n            DebugUIBuilder.instance.Show();\\n\\n            CameraAndRenderTargetSetup();\\n            cameraRenderOverlay.enabled = true;\\n            cameraRenderOverlay.currentOverlayShape = OVROverlay.OverlayShape.Quad;\\n            spawnedCubes.Capacity = numObjectsPerLevel * numLevels;\\n\\n            // Initialize object pool\\n            InitializeObjectPool();\\n        }\\n\\n        void Update()\\n        {\\n            if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))\\n            {\\n                if (inMenu) DebugUIBuilder.instance.Hide();\\n                else DebugUIBuilder.instance.Show();\\n                inMenu = !inMenu;\\n            }\\n\\n            if (Input.GetKeyDown(KeyCode.A))\\n            {\\n                TriggerLoad();\\n            }\\n        }\\n\\n        #endregion\\n\\n        #region Private Functions\\n\\n        void InitializeObjectPool()\\n        {\\n            for (int i = 0; i < numObjectsPerLevel * numLevels; i++)\\n            {\\n                var newInst = Instantiate(prefabForLevelLoadSim);\\n                newInst.SetActive(false);\\n                objectPool.Enqueue(newInst);\\n            }\\n        }\\n\\n        GameObject GetPooledObject()\\n        {\\n            if (objectPool.Count > 0)\\n            {\\n                var obj = objectPool.Dequeue();\\n                obj.SetActive(true);\\n                return obj;\\n            }\\n            else\\n            {\\n                var newObj = Instantiate(prefabForLevelLoadSim);\\n                newObj.SetActive(false);\\n                spawnedCubes.Add(newObj);\\n                return newObj;\\n            }\\n        }\\n\\n        void ReturnPooledObject(GameObject obj)\\n        {\\n            obj.SetActive(false);\\n            objectPool.Enqueue(obj);\\n        }\\n\\n        void SimulateLevelLoad()\\n        {\\n            int numToPrint = 0;\\n            for (int p = 0; p < numLoopsTrigger; p++)\\n            {\\n                numToPrint++;\\n            }\\n\\n            Debug.Log(\\\"Finished \\\" + numToPrint + \\\" Loops\\\");\\n            Vector3 playerPos = mainCamera.transform.position;\\n            playerPos.y = 0.5f;\\n\\n            for (int j = 0; j < numLevels; j++)\\n            {\\n                for (var i = 0; i < numObjectsPerLevel; i++)\\n                {\\n                    var angle = i * Mathf.PI * 2 / numObjectsPerLevel;\\n                    float stagger = (i % 2 == 0) ? 1.5f : 1.0f;\\n                    var pos = new Vector3(Mathf.Cos(angle), 0, Mathf.Sin(angle)) * cubeSpawnRadius * stagger;\\n                    pos.y = j * heightBetweenItems;\\n                    var newInst = GetPooledObject();\\n                    newInst.transform.position = pos + playerPos;\\n                    var newObjTransform = newInst.transform;\\n                    newObjTransform.LookAt(playerPos);\\n                    Vector3 newAngle = newObjTransform.rotation.eulerAngles;\\n                    newAngle.x = 0.0f;\\n                    newObjTransform.rotation = Quaternion.Euler(newAngle);\\n                }\\n            }\\n        }\\n\\n        void ClearObjects()\\n        {\\n            foreach (var obj in spawnedCubes)\\n            {\\n                ReturnPooledObject(obj);\\n            }\\n            spawnedCubes.Clear();\\n        }\\n\\n        // The other existing functions remain unchanged\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}},{\"finish_reason\":\"stop\",\"index\":1,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\nusing System;\\n\\nnamespace OculusSampleFramework\\n{\\n    // ... (other code remains unchanged)\\n\\n    public class OVROverlaySample : MonoBehaviour\\n    {\\n        // ... (other member variables remain unchanged)\\n\\n        [Header(\\\"Level Loading Sim Settings\\\")]\\n        public GameObject prefabForLevelLoadSim;\\n        public OVROverlay cubemapOverlay;\\n        public OVROverlay loadingTextQuadOverlay;\\n        public float distanceFromCamToLoadText;\\n        public float cubeSpawnRadius;\\n        public float heightBetweenItems;\\n        public int numObjectsPerLevel;\\n        public int numLevels;\\n        public int numLoopsTrigger = 500000000;\\n        List<GameObject> spawnedCubes = new List<GameObject>();\\n        private Queue<GameObject> objectPool = new Queue<GameObject>();\\n\\n        #region MonoBehaviour handler\\n\\n        void Start()\\n        {\\n            DebugUIBuilder.instance.AddLabel(\\\"OVROverlay Sample\\\");\\n            DebugUIBuilder.instance.AddDivider();\\n            DebugUIBuilder.instance.AddLabel(\\\"Level Loading Example\\\");\\n            DebugUIBuilder.instance.AddButton(\\\"Simulate Level Load\\\", TriggerLoad);\\n            DebugUIBuilder.instance.AddButton(\\\"Destroy Cubes\\\", TriggerUnload);\\n            DebugUIBuilder.instance.AddDivider();\\n            DebugUIBuilder.instance.AddLabel(\\\"OVROverlay vs. Application Render Comparison\\\");\\n            DebugUIBuilder.instance\\n                .AddRadio(\\\"OVROverlay\\\", \\\"group\\\", delegate (Toggle t) { RadioPressed(ovrOverlayID, \\\"group\\\", t); })\\n                .GetComponentInChildren<Toggle>();\\n            applicationRadioButton = DebugUIBuilder.instance\\n                .AddRadio(\\\"Application\\\", \\\"group\\\", delegate (Toggle t) { RadioPressed(applicationID, \\\"group\\\", t); })\\n                .GetComponentInChildren<Toggle>();\\n            noneRadioButton = DebugUIBuilder.instance\\n                .AddRadio(\\\"None\\\", \\\"group\\\", delegate (Toggle t) { RadioPressed(noneID, \\\"group\\\", t); })\\n                .GetComponentInChildren<Toggle>();\\n\\n            DebugUIBuilder.instance.Show();\\n\\n            CameraAndRenderTargetSetup();\\n            cameraRenderOverlay.enabled = true;\\n            cameraRenderOverlay.currentOverlayShape = OVROverlay.OverlayShape.Quad;\\n            spawnedCubes.Capacity = numObjectsPerLevel * numLevels;\\n\\n            // Create an object pool\\n            for (int i = 0; i < numObjectsPerLevel * numLevels; i++)\\n            {\\n                var obj = Instantiate(prefabForLevelLoadSim);\\n                obj.SetActive(false);\\n                objectPool.Enqueue(obj);\\n            }\\n        }\\n\\n        // ... (update function and other methods remain unchanged)\\n\\n        void SimulateLevelLoad()\\n        {\\n            int numToPrint = 0;\\n            for (int p = 0; p < numLoopsTrigger; p++)\\n            {\\n                numToPrint++;\\n            }\\n\\n            Debug.Log(\\\"Finished \\\" + numToPrint + \\\" Loops\\\");\\n            Vector3 playerPos = mainCamera.transform.position;\\n            playerPos.y = 0.5f;\\n\\n            for (int j = 0; j < numLevels; j++)\\n            {\\n                for (var i = 0; i < numObjectsPerLevel; i++)\\n                {\\n                    var angle = i * Mathf.PI * 2 / numObjectsPerLevel;\\n                    float stagger = (i % 2 == 0) ? 1.5f : 1.0f;\\n                    var pos = new Vector3(Mathf.Cos(angle), 0, Mathf.Sin(angle)) * cubeSpawnRadius * stagger;\\n                    pos.y = j * heightBetweenItems;\\n                    if(objectPool.Count > 0)\\n                    {\\n                        var newInst = objectPool.Dequeue();\\n                        newInst.transform.position = pos + playerPos;\\n                        newInst.SetActive(true);\\n                        var newObjTransform = newInst.transform;\\n                        newObjTransform.LookAt(playerPos);\\n                        Vector3 newAngle = newObjTransform.rotation.eulerAngles;\\n                        newAngle.x = 0.0f;\\n                        newObjTransform.rotation = Quaternion.Euler(newAngle);\\n                        spawnedCubes.Add(newInst);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // ... (rest of the code unchanged)\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}},{\"finish_reason\":\"stop\",\"index\":2,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\nusing System;\\n\\nnamespace OculusSampleFramework\\n{\\n    public enum EUiDisplayType\\n    {\\n        EUDT_WorldGeoQuad,\\n        EUDT_OverlayQuad,\\n        EUDT_None,\\n        EUDT_MaxDislayTypes\\n    }\\n\\n    public class OVROverlaySample : MonoBehaviour\\n    {\\n        bool inMenu;\\n        const string ovrOverlayID = \\\"OVROverlayID\\\";\\n        const string applicationID = \\\"ApplicationID\\\";\\n        const string noneID = \\\"NoneID\\\";\\n\\n        Toggle applicationRadioButton;\\n        Toggle noneRadioButton;\\n\\n        [Header(\\\"App vs Compositor Comparison Settings\\\")]\\n        public GameObject mainCamera;\\n        public GameObject uiCamera;\\n        public GameObject uiGeoParent;\\n        public GameObject worldspaceGeoParent;\\n        public OVROverlay cameraRenderOverlay;\\n        public OVROverlay renderingLabelOverlay;\\n\\n        public Texture applicationLabelTexture;\\n        public Texture compositorLabelTexture;\\n\\n        [Header(\\\"Level Loading Sim Settings\\\")]\\n        public GameObject prefabForLevelLoadSim;\\n        public OVROverlay cubemapOverlay;\\n        public OVROverlay loadingTextQuadOverlay;\\n        public float distanceFromCamToLoadText;\\n        public float cubeSpawnRadius;\\n        public float heightBetweenItems;\\n        public int numObjectsPerLevel;\\n        public int numLevels;\\n        public int numLoopsTrigger = 500000000;\\n        List<GameObject> spawnedCubes = new List<GameObject>();\\n        Queue<GameObject> objectPool = new Queue<GameObject>();\\n\\n        #region MonoBehaviour handler\\n\\n        void Start()\\n        {\\n            DebugUIBuilder.instance.AddLabel(\\\"OVROverlay Sample\\\");\\n            DebugUIBuilder.instance.AddDivider();\\n            DebugUIBuilder.instance.AddLabel(\\\"Level Loading Example\\\");\\n            DebugUIBuilder.instance.AddButton(\\\"Simulate Level Load\\\", TriggerLoad);\\n            DebugUIBuilder.instance.AddButton(\\\"Destroy Cubes\\\", TriggerUnload);\\n            DebugUIBuilder.instance.AddDivider();\\n            DebugUIBuilder.instance.AddLabel(\\\"OVROverlay vs. Application Render Comparison\\\");\\n            DebugUIBuilder.instance\\n                .AddRadio(\\\"OVROverlay\\\", \\\"group\\\", delegate(Toggle t) { RadioPressed(ovrOverlayID, \\\"group\\\", t); })\\n                .GetComponentInChildren<Toggle>();\\n            applicationRadioButton = DebugUIBuilder.instance\\n                .AddRadio(\\\"Application\\\", \\\"group\\\", delegate(Toggle t) { RadioPressed(applicationID, \\\"group\\\", t); })\\n                .GetComponentInChildren<Toggle>();\\n            noneRadioButton = DebugUIBuilder.instance\\n                .AddRadio(\\\"None\\\", \\\"group\\\", delegate(Toggle t) { RadioPressed(noneID, \\\"group\\\", t); })\\n                .GetComponentInChildren<Toggle>();\\n\\n            DebugUIBuilder.instance.Show();\\n\\n            CameraAndRenderTargetSetup();\\n            cameraRenderOverlay.enabled = true;\\n            cameraRenderOverlay.currentOverlayShape = OVROverlay.OverlayShape.Quad;\\n            spawnedCubes.Capacity = numObjectsPerLevel * numLevels;\\n\\n            InitializeObjectPool();\\n        }\\n\\n        void Update()\\n        {\\n            if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))\\n            {\\n                if (inMenu) DebugUIBuilder.instance.Hide();\\n                else DebugUIBuilder.instance.Show();\\n                inMenu = !inMenu;\\n            }\\n\\n            if (Input.GetKeyDown(KeyCode.A))\\n            {\\n                TriggerLoad();\\n            }\\n        }\\n\\n        #endregion\\n\\n        #region Private Functions\\n\\n        void InitializeObjectPool()\\n        {\\n            int totalObjects = numObjectsPerLevel * numLevels;\\n            for (int i = 0; i < totalObjects; i++)\\n            {\\n                GameObject obj = Instantiate(prefabForLevelLoadSim);\\n                obj.SetActive(false);\\n                objectPool.Enqueue(obj);\\n            }\\n        }\\n\\n        void ActivateWorldGeo()\\n        {\\n            worldspaceGeoParent.SetActive(true);\\n            uiGeoParent.SetActive(false);\\n            uiCamera.SetActive(false);\\n            cameraRenderOverlay.enabled = false;\\n            renderingLabelOverlay.enabled = true;\\n            renderingLabelOverlay.textures[0] = applicationLabelTexture;\\n            Debug.Log(\\\"Switched to ActivateWorldGeo\\\");\\n        }\\n\\n        void ActivateOVROverlay()\\n        {\\n            worldspaceGeoParent.SetActive(false);\\n            uiCamera.SetActive(true);\\n            cameraRenderOverlay.enabled = true;\\n            uiGeoParent.SetActive(true);\\n            renderingLabelOverlay.enabled = true;\\n            renderingLabelOverlay.textures[0] = compositorLabelTexture;\\n            Debug.Log(\\\"Switched to ActivateOVROverlay\\\");\\n        }\\n\\n        void ActivateNone()\\n        {\\n            worldspaceGeoParent.SetActive(false);\\n            uiCamera.SetActive(false);\\n            cameraRenderOverlay.enabled = false;\\n            uiGeoParent.SetActive(false);\\n            renderingLabelOverlay.enabled = false;\\n            Debug.Log(\\\"Switched to ActivateNone\\\");\\n        }\\n\\n        void TriggerLoad()\\n        {\\n            StartCoroutine(WaitforOVROverlay());\\n        }\\n\\n        IEnumerator WaitforOVROverlay()\\n        {\\n            Transform camTransform = mainCamera.transform;\\n            Transform uiTextOverlayTrasnform = loadingTextQuadOverlay.transform;\\n            Vector3 newPos = camTransform.position + camTransform.forward * distanceFromCamToLoadText;\\n            newPos.y = camTransform.position.y;\\n            uiTextOverlayTrasnform.position = newPos;\\n            cubemapOverlay.enabled = true;\\n            loadingTextQuadOverlay.enabled = true;\\n            noneRadioButton.isOn = true;\\n            yield return new WaitForSeconds(0.1f);\\n            ClearObjects();\\n            SimulateLevelLoad();\\n            cubemapOverlay.enabled = false;\\n            loadingTextQuadOverlay.enabled = false;\\n            yield return null;\\n        }\\n\\n        void TriggerUnload()\\n        {\\n            ClearObjects();\\n            applicationRadioButton.isOn = true;\\n        }\\n\\n        void CameraAndRenderTargetSetup()\\n        {\\n            float overlayWidth = cameraRenderOverlay.transform.localScale.x;\\n            float overlayHeight = cameraRenderOverlay.transform.localScale.y;\\n            float overlayRadius = cameraRenderOverlay.transform.localScale.z;\\n\\n#if UNITY_ANDROID\\n            float hmdPanelResWidth = 2560;\\n            float hmdPanelResHeight = 1440;\\n#else\\n            float hmdPanelResWidth = 2160;\\n            float hmdPanelResHeight = 1200;\\n#endif\\n\\n            float singleEyeScreenPhysicalResX = hmdPanelResWidth * 0.5f;\\n            float singleEyeScreenPhysicalResY = hmdPanelResHeight;\\n\\n            float halfFovY = mainCamera.GetComponent<Camera>().fieldOfView / 2;\\n            float screenSizeYInWorld = 2 * overlayRadius * Mathf.Tan(Mathf.Deg2Rad * halfFovY);\\n            float pixelDensityYPerWorldUnit = singleEyeScreenPhysicalResY / screenSizeYInWorld;\\n            float renderTargetHeight = pixelDensityYPerWorldUnit * overlayWidth;\\n\\n            float renderTargetWidth = 0.0f;\\n\\n            float screenSizeXInWorld = screenSizeYInWorld * mainCamera.GetComponent<Camera>().aspect;\\n            float pixelDensityXPerWorldUnit = singleEyeScreenPhysicalResX / screenSizeXInWorld;\\n            renderTargetWidth = pixelDensityXPerWorldUnit * overlayWidth;\\n\\n            float orthographicSize = overlayHeight / 2.0f;\\n            float orthoCameraAspect = overlayWidth / overlayHeight;\\n            uiCamera.GetComponent<Camera>().orthographicSize = orthographicSize;\\n            uiCamera.GetComponent<Camera>().aspect = orthoCameraAspect;\\n\\n            if (uiCamera.GetComponent<Camera>().targetTexture != null)\\n                uiCamera.GetComponent<Camera>().targetTexture.Release();\\n\\n            RenderTexture overlayRT = new RenderTexture(\\n                (int)renderTargetWidth * 2,\\n                (int)renderTargetHeight * 2,\\n                0,\\n                RenderTextureFormat.ARGB32,\\n                RenderTextureReadWrite.sRGB);\\n            Debug.Log(\\\"Created RT of resolution w: \\\" + renderTargetWidth + \\\" and h: \\\" + renderTargetHeight);\\n\\n            overlayRT.hideFlags = HideFlags.DontSave;\\n            overlayRT.useMipMap = true;\\n            overlayRT.filterMode = FilterMode.Trilinear;\\n            overlayRT.anisoLevel = 4;\\n#if UNITY_5_5_OR_NEWER\\n            overlayRT.autoGenerateMips = true;\\n#else\\n            overlayRT.generateMips = true;\\n#endif\\n            uiCamera.GetComponent<Camera>().targetTexture = overlayRT;\\n\\n            cameraRenderOverlay.textures[0] = overlayRT;\\n        }\\n\\n        void SimulateLevelLoad()\\n        {\\n            int numToPrint = 0;\\n            for (int p = 0; p < numLoopsTrigger; p++)\\n            {\\n                numToPrint++;\\n            }\\n\\n            Debug.Log(\\\"Finished \\\" + numToPrint + \\\" Loops\\\");\\n            Vector3 playerPos = mainCamera.transform.position;\\n            playerPos.y = 0.5f;\\n\\n            for (int j = 0; j < numLevels; j++)\\n            {\\n                for (var i = 0; i < numObjectsPerLevel; i++)\\n                {\\n                    if (objectPool.Count > 0)\\n                    {\\n                        var obj = objectPool.Dequeue();\\n                        var angle = i * Mathf.PI * 2 / numObjectsPerLevel;\\n                        float stagger = (i % 2 == 0) ? 1.5f : 1.0f;\\n                        var pos = new Vector3(Mathf.Cos(angle), 0, Mathf.Sin(angle)) * cubeSpawnRadius * stagger;\\n                        pos.y = j * heightBetweenItems;\\n                        obj.transform.position = pos + playerPos;\\n                        obj.transform.rotation = Quaternion.LookRotation(mainCamera.transform.position - obj.transform.position);\\n                        obj.SetActive(true);\\n                        spawnedCubes.Add(obj);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}},{\"finish_reason\":\"stop\",\"index\":3,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\nusing System;\\n\\nnamespace OculusSampleFramework\\n{\\n    public class OVROverlaySample : MonoBehaviour\\n    {\\n        bool inMenu;\\n        const string ovrOverlayID = \\\"OVROverlayID\\\";\\n        const string applicationID = \\\"ApplicationID\\\";\\n        const string noneID = \\\"NoneID\\\";\\n\\n        Toggle applicationRadioButton;\\n        Toggle noneRadioButton;\\n\\n        [Header(\\\"App vs Compositor Comparison Settings\\\")]\\n\\n        public GameObject mainCamera;\\n        public GameObject uiCamera;\\n        public GameObject uiGeoParent;\\n        public GameObject worldspaceGeoParent;\\n        public OVROverlay cameraRenderOverlay;\\n        public OVROverlay renderingLabelOverlay;\\n        public Texture applicationLabelTexture;\\n        public Texture compositorLabelTexture;\\n\\n        [Header(\\\"Level Loading Sim Settings\\\")]\\n        public GameObject prefabForLevelLoadSim;\\n        public OVROverlay cubemapOverlay;\\n        public OVROverlay loadingTextQuadOverlay;\\n        public float distanceFromCamToLoadText;\\n        public float cubeSpawnRadius;\\n        public float heightBetweenItems;\\n        public int numObjectsPerLevel;\\n        public int numLevels;\\n        public int numLoopsTrigger = 500000000;\\n        List<GameObject> spawnedCubes = new List<GameObject>();\\n        Queue<GameObject> pooledObjects = new Queue<GameObject>();\\n\\n        #region MonoBehaviour handler\\n\\n        void Start()\\n        {\\n            DebugUIBuilder.instance.AddLabel(\\\"OVROverlay Sample\\\");\\n            DebugUIBuilder.instance.AddDivider();\\n            DebugUIBuilder.instance.AddLabel(\\\"Level Loading Example\\\");\\n            DebugUIBuilder.instance.AddButton(\\\"Simulate Level Load\\\", TriggerLoad);\\n            DebugUIBuilder.instance.AddButton(\\\"Destroy Cubes\\\", TriggerUnload);\\n            DebugUIBuilder.instance.AddDivider();\\n            DebugUIBuilder.instance.AddLabel(\\\"OVROverlay vs. Application Render Comparison\\\");\\n            DebugUIBuilder.instance\\n                .AddRadio(\\\"OVROverlay\\\", \\\"group\\\", delegate(Toggle t) { RadioPressed(ovrOverlayID, \\\"group\\\", t); })\\n                .GetComponentInChildren<Toggle>();\\n            applicationRadioButton = DebugUIBuilder.instance\\n                .AddRadio(\\\"Application\\\", \\\"group\\\", delegate(Toggle t) { RadioPressed(applicationID, \\\"group\\\", t); })\\n                .GetComponentInChildren<Toggle>();\\n            noneRadioButton = DebugUIBuilder.instance\\n                .AddRadio(\\\"None\\\", \\\"group\\\", delegate(Toggle t) { RadioPressed(noneID, \\\"group\\\", t); })\\n                .GetComponentInChildren<Toggle>();\\n\\n            DebugUIBuilder.instance.Show();\\n\\n            CameraAndRenderTargetSetup();\\n            cameraRenderOverlay.enabled = true;\\n            cameraRenderOverlay.currentOverlayShape = OVROverlay.OverlayShape.Quad;\\n            spawnedCubes.Capacity = numObjectsPerLevel * numLevels;\\n            PrepareObjects();\\n        }\\n\\n        void Update()\\n        {\\n            if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))\\n            {\\n                if (inMenu) DebugUIBuilder.instance.Hide();\\n                else DebugUIBuilder.instance.Show();\\n                inMenu = !inMenu;\\n            }\\n\\n            if (Input.GetKeyDown(KeyCode.A))\\n            {\\n                TriggerLoad();\\n            }\\n        }\\n\\n        #endregion\\n\\n        #region Private Functions\\n\\n        void PrepareObjects()\\n        {\\n            int totalObjects = numObjectsPerLevel * numLevels;\\n            for (int i = 0; i < totalObjects; i++)\\n            {\\n                GameObject obj = Instantiate(prefabForLevelLoadSim);\\n                obj.SetActive(false);\\n                pooledObjects.Enqueue(obj);\\n            }\\n        }\\n\\n        GameObject GetPooledObject(Vector3 position, Quaternion rotation)\\n        {\\n            if (pooledObjects.Count > 0)\\n            {\\n                GameObject obj = pooledObjects.Dequeue();\\n                obj.transform.position = position;\\n                obj.transform.rotation = rotation;\\n                obj.SetActive(true);\\n                return obj;\\n            }\\n            else\\n            {\\n                GameObject obj = Instantiate(prefabForLevelLoadSim, position, rotation);\\n                return obj;\\n            }\\n        }\\n\\n        void ActivateWorldGeo()\\n        {\\n            worldspaceGeoParent.SetActive(true);\\n            uiGeoParent.SetActive(false);\\n            uiCamera.SetActive(false);\\n            cameraRenderOverlay.enabled = false;\\n            renderingLabelOverlay.enabled = true;\\n            renderingLabelOverlay.textures[0] = applicationLabelTexture;\\n            Debug.Log(\\\"Switched to ActivateWorldGeo\\\");\\n        }\\n\\n        void ActivateOVROverlay()\\n        {\\n            worldspaceGeoParent.SetActive(false);\\n            uiCamera.SetActive(true);\\n            cameraRenderOverlay.enabled = true;\\n            uiGeoParent.SetActive(true);\\n            renderingLabelOverlay.enabled = true;\\n            renderingLabelOverlay.textures[0] = compositorLabelTexture;\\n            Debug.Log(\\\"Switched to ActivateOVROVerlay\\\");\\n        }\\n\\n        void ActivateNone()\\n        {\\n            worldspaceGeoParent.SetActive(false);\\n            uiCamera.SetActive(false);\\n            cameraRenderOverlay.enabled = false;\\n            uiGeoParent.SetActive(false);\\n            renderingLabelOverlay.enabled = false;\\n            Debug.Log(\\\"Switched to ActivateNone\\\");\\n        }\\n\\n        void TriggerLoad()\\n        {\\n            StartCoroutine(WaitforOVROverlay());\\n        }\\n\\n        IEnumerator WaitforOVROverlay()\\n        {\\n            Transform camTransform = mainCamera.transform;\\n            Transform uiTextOverlayTrasnform = loadingTextQuadOverlay.transform;\\n            Vector3 newPos = camTransform.position + camTransform.forward * distanceFromCamToLoadText;\\n            newPos.y = camTransform.position.y;\\n            uiTextOverlayTrasnform.position = newPos;\\n            cubemapOverlay.enabled = true;\\n            loadingTextQuadOverlay.enabled = true;\\n            noneRadioButton.isOn = true;\\n            yield return new WaitForSeconds(0.1f);\\n            ClearObjects();\\n            SimulateLevelLoad();\\n            cubemapOverlay.enabled = false;\\n            loadingTextQuadOverlay.enabled = false;\\n            yield return null;\\n        }\\n\\n        void TriggerUnload()\\n        {\\n            ClearObjects();\\n            applicationRadioButton.isOn = true;\\n        }\\n\\n        void CameraAndRenderTargetSetup()\\n        {\\n            float overlayWidth = cameraRenderOverlay.transform.localScale.x;\\n            float overlayHeight = cameraRenderOverlay.transform.localScale.y;\\n            float overlayRadius = cameraRenderOverlay.transform.localScale.z;\\n\\n#if UNITY_ANDROID\\n\\n            float hmdPanelResWidth = 2560;\\n            float hmdPanelResHeight = 1440;\\n#else\\n\\n            float hmdPanelResWidth = 2160;\\n            float hmdPanelResHeight = 1200;\\n#endif\\n\\n            float singleEyeScreenPhysicalResX = hmdPanelResWidth * 0.5f;\\n            float singleEyeScreenPhysicalResY = hmdPanelResHeight;\\n\\n            float halfFovY = mainCamera.GetComponent<Camera>().fieldOfView / 2;\\n            float screenSizeYInWorld = 2 * overlayRadius * Mathf.Tan(Mathf.Deg2Rad * halfFovY);\\n            float pixelDensityYPerWorldUnit = singleEyeScreenPhysicalResY / screenSizeYInWorld;\\n            float renderTargetHeight = pixelDensityYPerWorldUnit * overlayWidth;\\n\\n            float renderTargetWidth = 0.0f;\\n\\n            float screenSizeXInWorld = screenSizeYInWorld * mainCamera.GetComponent<Camera>().aspect;\\n            float pixelDensityXPerWorldUnit = singleEyeScreenPhysicalResX / screenSizeXInWorld;\\n            renderTargetWidth = pixelDensityXPerWorldUnit * overlayWidth;\\n\\n            float orthographicSize = overlayHeight / 2.0f;\\n            float orthoCameraAspect = overlayWidth / overlayHeight;\\n            uiCamera.GetComponent<Camera>().orthographicSize = orthographicSize;\\n            uiCamera.GetComponent<Camera>().aspect = orthoCameraAspect;\\n\\n            if (uiCamera.GetComponent<Camera>().targetTexture != null)\\n                uiCamera.GetComponent<Camera>().targetTexture.Release();\\n\\n            RenderTexture overlayRT = new RenderTexture(\\n                (int)renderTargetWidth * 2,\\n                (int)renderTargetHeight * 2,\\n                0,\\n                RenderTextureFormat.ARGB32,\\n                RenderTextureReadWrite.sRGB);\\n            Debug.Log(\\\"Created RT of resolution w: \\\" + renderTargetWidth + \\\" and h: \\\" + renderTargetHeight);\\n\\n            overlayRT.hideFlags = HideFlags.DontSave;\\n            overlayRT.useMipMap = true;\\n            overlayRT.filterMode = FilterMode.Trilinear;\\n            overlayRT.anisoLevel = 4;\\n#if UNITY_5_5_OR_NEWER\\n            overlayRT.autoGenerateMips = true;\\n#else\\n        overlayRT.generateMips = true;\\n#endif\\n            uiCamera.GetComponent<Camera>().targetTexture = overlayRT;\\n\\n            cameraRenderOverlay.textures[0] = overlayRT;\\n        }\\n\\n        void SimulateLevelLoad()\\n        {\\n            int numToPrint = 0;\\n            for (int p = 0; p < numLoopsTrigger; p++)\\n            {\\n                numToPrint++;\\n            }\\n\\n            Debug.Log(\\\"Finished \\\" + numToPrint + \\\" Loops\\\");\\n            Vector3 playerPos = mainCamera.transform.position;\\n            playerPos.y = 0.5f;\\n\\n            for (int j = 0; j < numLevels; j++)\\n            {\\n                for (var i = 0; i < numObjectsPerLevel; i++)\\n                {\\n                    var angle = i * Mathf.PI * 2 / numObjectsPerLevel;\\n                    float stagger = (i % 2 == 0) ? 1.5f : 1.0f;\\n                    var pos = new Vector3(Mathf.Cos(angle), 0, Mathf.Sin(angle)) * cubeSpawnRadius * stagger;\\n                    pos.y = j * heightBetweenItems;\\n                    var newInst = GetPooledObject(pos + playerPos, Quaternion.identity);\\n                    var newObjTransform = newInst.transform;\\n                    newObjTransform.LookAt(playerPos);\\n                    Vector3 newAngle = newObjTransform.rotation.eulerAngles;\\n                    newAngle.x = 0.0f;\\n                    newObjTransform.rotation = Quaternion.Euler(newAngle);\\n                    spawnedCubes.Add(newInst);\\n                }\\n            }\\n        }\\n\\n        void ClearObjects()\\n        {\\n            foreach (var obj in spawnedCubes)\\n            {\\n                obj.SetActive(false);\\n                pooledObjects.Enqueue(obj);\\n            }\\n            spawnedCubes.Clear();\\n        }\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}},{\"finish_reason\":\"stop\",\"index\":4,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\nusing System;\\n\\nnamespace OculusSampleFramework\\n{\\n    public enum EUiDisplayType\\n    {\\n        EUDT_WorldGeoQuad,\\n        EUDT_OverlayQuad,\\n        EUDT_None,\\n        EUDT_MaxDislayTypes\\n    }\\n\\n    public class OVROverlaySample : MonoBehaviour\\n    {\\n        bool inMenu;\\n\\n        const string ovrOverlayID = \\\"OVROverlayID\\\";\\n        const string applicationID = \\\"ApplicationID\\\";\\n        const string noneID = \\\"NoneID\\\";\\n\\n        Toggle applicationRadioButton;\\n        Toggle noneRadioButton;\\n\\n        [Header(\\\"App vs Compositor Comparison Settings\\\")]\\n        public GameObject mainCamera;\\n        public GameObject uiCamera;\\n        public GameObject uiGeoParent;\\n        public GameObject worldspaceGeoParent;\\n\\n        public OVROverlay cameraRenderOverlay;\\n        public OVROverlay renderingLabelOverlay;\\n\\n        public Texture applicationLabelTexture;\\n        public Texture compositorLabelTexture;\\n\\n        [Header(\\\"Level Loading Sim Settings\\\")]\\n        public GameObject prefabForLevelLoadSim;\\n        public OVROverlay cubemapOverlay;\\n        public OVROverlay loadingTextQuadOverlay;\\n        public float distanceFromCamToLoadText;\\n        public float cubeSpawnRadius;\\n        public float heightBetweenItems;\\n        public int numObjectsPerLevel;\\n        public int numLevels;\\n        public int numLoopsTrigger = 500000000;\\n        List<GameObject> spawnedCubes = new List<GameObject>();\\n\\n        // Object pool to reduce instantiations in Update\\n        private Queue<GameObject> objectPool = new Queue<GameObject>();\\n\\n        private void Awake()\\n        {\\n            InitializeObjectPool();\\n        }\\n\\n        void Start()\\n        {\\n            DebugUIBuilder.instance.AddLabel(\\\"OVROverlay Sample\\\");\\n            DebugUIBuilder.instance.AddDivider();\\n            DebugUIBuilder.instance.AddLabel(\\\"Level Loading Example\\\");\\n            DebugUIBuilder.instance.AddButton(\\\"Simulate Level Load\\\", TriggerLoad);\\n            DebugUIBuilder.instance.AddButton(\\\"Destroy Cubes\\\", TriggerUnload);\\n            DebugUIBuilder.instance.AddDivider();\\n            DebugUIBuilder.instance.AddLabel(\\\"OVROverlay vs. Application Render Comparison\\\");\\n            DebugUIBuilder.instance\\n                .AddRadio(\\\"OVROverlay\\\", \\\"group\\\", delegate (Toggle t) { RadioPressed(ovrOverlayID, \\\"group\\\", t); })\\n                .GetComponentInChildren<Toggle>();\\n            applicationRadioButton = DebugUIBuilder.instance\\n                .AddRadio(\\\"Application\\\", \\\"group\\\", delegate (Toggle t) { RadioPressed(applicationID, \\\"group\\\", t); })\\n                .GetComponentInChildren<Toggle>();\\n            noneRadioButton = DebugUIBuilder.instance\\n                .AddRadio(\\\"None\\\", \\\"group\\\", delegate (Toggle t) { RadioPressed(noneID, \\\"group\\\", t); })\\n                .GetComponentInChildren<Toggle>();\\n\\n            DebugUIBuilder.instance.Show();\\n\\n            CameraAndRenderTargetSetup();\\n            cameraRenderOverlay.enabled = true;\\n            cameraRenderOverlay.currentOverlayShape = OVROverlay.OverlayShape.Quad;\\n            spawnedCubes.Capacity = numObjectsPerLevel * numLevels;\\n        }\\n\\n        void Update()\\n        {\\n            if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))\\n            {\\n                if (inMenu) DebugUIBuilder.instance.Hide();\\n                else DebugUIBuilder.instance.Show();\\n                inMenu = !inMenu;\\n            }\\n\\n            if (Input.GetKeyDown(KeyCode.A))\\n            {\\n                TriggerLoad();\\n            }\\n        }\\n\\n        #region Private Functions\\n\\n        private void InitializeObjectPool()\\n        {\\n            int poolSize = numObjectsPerLevel * numLevels;\\n            for (int i = 0; i < poolSize; i++)\\n            {\\n                GameObject newObj = Instantiate(prefabForLevelLoadSim);\\n                newObj.SetActive(false);\\n                objectPool.Enqueue(newObj);\\n            }\\n        }\\n\\n        GameObject GetPooledObject()\\n        {\\n            if (objectPool.Count > 0)\\n            {\\n                GameObject obj = objectPool.Dequeue();\\n                obj.SetActive(true);\\n                return obj;\\n            }\\n            else\\n            {\\n                // If the pool is empty, instantiate a new object\\n                return Instantiate(prefabForLevelLoadSim);\\n            }\\n        }\\n\\n        void ReturnObjectToPool(GameObject obj)\\n        {\\n            obj.SetActive(false);\\n            objectPool.Enqueue(obj);\\n        }\\n\\n        void ActivateWorldGeo()\\n        {\\n            worldspaceGeoParent.SetActive(true);\\n            uiGeoParent.SetActive(false);\\n            uiCamera.SetActive(false);\\n            cameraRenderOverlay.enabled = false;\\n            renderingLabelOverlay.enabled = true;\\n            renderingLabelOverlay.textures[0] = applicationLabelTexture;\\n            Debug.Log(\\\"Switched to ActivateWorldGeo\\\");\\n        }\\n\\n        void ActivateOVROverlay()\\n        {\\n            worldspaceGeoParent.SetActive(false);\\n            uiCamera.SetActive(true);\\n            cameraRenderOverlay.enabled = true;\\n            uiGeoParent.SetActive(true);\\n            renderingLabelOverlay.enabled = true;\\n            renderingLabelOverlay.textures[0] = compositorLabelTexture;\\n            Debug.Log(\\\"Switched to ActivateOVROverlay\\\");\\n        }\\n\\n        void ActivateNone()\\n        {\\n            worldspaceGeoParent.SetActive(false);\\n            uiCamera.SetActive(false);\\n            cameraRenderOverlay.enabled = false;\\n            uiGeoParent.SetActive(false);\\n            renderingLabelOverlay.enabled = false;\\n            Debug.Log(\\\"Switched to ActivateNone\\\");\\n        }\\n\\n        void TriggerLoad()\\n        {\\n            StartCoroutine(WaitforOVROverlay());\\n        }\\n\\n        IEnumerator WaitforOVROverlay()\\n        {\\n            Transform camTransform = mainCamera.transform;\\n            Transform uiTextOverlayTransform = loadingTextQuadOverlay.transform;\\n            Vector3 newPos = camTransform.position + camTransform.forward * distanceFromCamToLoadText;\\n            newPos.y = camTransform.position.y;\\n            uiTextOverlayTransform.position = newPos;\\n            cubemapOverlay.enabled = true;\\n            loadingTextQuadOverlay.enabled = true;\\n            noneRadioButton.isOn = true;\\n            yield return new WaitForSeconds(0.1f);\\n            ClearObjects();\\n            SimulateLevelLoad();\\n            cubemapOverlay.enabled = false;\\n            loadingTextQuadOverlay.enabled = false;\\n            yield return null;\\n        }\\n\\n        void TriggerUnload()\\n        {\\n            ClearObjects();\\n            applicationRadioButton.isOn = true;\\n        }\\n\\n        void CameraAndRenderTargetSetup()\\n        {\\n            float overlayWidth = cameraRenderOverlay.transform.localScale.x;\\n            float overlayHeight = cameraRenderOverlay.transform.localScale.y;\\n            float overlayRadius = cameraRenderOverlay.transform.localScale.z;\\n\\n#if UNITY_ANDROID\\n            float hmdPanelResWidth = 2560;\\n            float hmdPanelResHeight = 1440;\\n#else\\n            float hmdPanelResWidth = 2160;\\n            float hmdPanelResHeight = 1200;\\n#endif\\n\\n            float singleEyeScreenPhysicalResX = hmdPanelResWidth * 0.5f;\\n            float singleEyeScreenPhysicalResY = hmdPanelResHeight;\\n\\n            float halfFovY = mainCamera.GetComponent<Camera>().fieldOfView / 2;\\n            float screenSizeYInWorld = 2 * overlayRadius * Mathf.Tan(Mathf.Deg2Rad * halfFovY);\\n            float pixelDensityYPerWorldUnit = singleEyeScreenPhysicalResY / screenSizeYInWorld;\\n            float renderTargetHeight = pixelDensityYPerWorldUnit * overlayWidth;\\n\\n            float renderTargetWidth = 0.0f;\\n\\n            float screenSizeXInWorld = screenSizeYInWorld * mainCamera.GetComponent<Camera>().aspect;\\n            float pixelDensityXPerWorldUnit = singleEyeScreenPhysicalResX / screenSizeXInWorld;\\n            renderTargetWidth = pixelDensityXPerWorldUnit * overlayWidth;\\n\\n            float orthographicSize = overlayHeight / 2.0f;\\n            float orthoCameraAspect = overlayWidth / overlayHeight;\\n            uiCamera.GetComponent<Camera>().orthographicSize = orthographicSize;\\n            uiCamera.GetComponent<Camera>().aspect = orthoCameraAspect;\\n\\n            if (uiCamera.GetComponent<Camera>().targetTexture != null)\\n                uiCamera.GetComponent<Camera>().targetTexture.Release();\\n\\n            RenderTexture overlayRT = new RenderTexture(\\n                (int)renderTargetWidth * 2,\\n                (int)renderTargetHeight * 2,\\n                0,\\n                RenderTextureFormat.ARGB32,\\n                RenderTextureReadWrite.sRGB);\\n            Debug.Log(\\\"Created RT of resolution w: \\\" + renderTargetWidth + \\\" and h: \\\" + renderTargetHeight);\\n\\n            overlayRT.hideFlags = HideFlags.DontSave;\\n            overlayRT.useMipMap = true;\\n            overlayRT.filterMode = FilterMode.Trilinear;\\n            overlayRT.anisoLevel = 4;\\n#if UNITY_5_5_OR_NEWER\\n            overlayRT.autoGenerateMips = true;\\n#else\\n        overlayRT.generateMips = true;\\n#endif\\n            uiCamera.GetComponent<Camera>().targetTexture = overlayRT;\\n\\n            cameraRenderOverlay.textures[0] = overlayRT;\\n        }\\n\\n        void ClearObjects()\\n        {\\n            foreach (var obj in spawnedCubes)\\n            {\\n                ReturnObjectToPool(obj);\\n            }\\n            spawnedCubes.Clear();\\n        }\\n\\n        void SimulateLevelLoad()\\n        {\\n            int numToPrint = 0;\\n            for (int p = 0; p < numLoopsTrigger; p++)\\n            {\\n                numToPrint++;\\n            }\\n\\n            Debug.Log(\\\"Finished \\\" + numToPrint + \\\" Loops\\\");\\n            Vector3 playerPos = mainCamera.transform.position;\\n            playerPos.y = 0.5f;\\n\\n            for (int j = 0; j < numLevels; j++)\\n            {\\n                for (var i = 0; i < numObjectsPerLevel; i++)\\n                {\\n                    var angle = i * Mathf.PI * 2 / numObjectsPerLevel;\\n                    float stagger = (i % 2 == 0) ? 1.5f : 1.0f;\\n                    var pos = new Vector3(Mathf.Cos(angle), 0, Mathf.Sin(angle)) * cubeSpawnRadius * stagger;\\n                    pos.y = j * heightBetweenItems;\\n                    var newInst = GetPooledObject();\\n                    newInst.transform.position = pos + playerPos;\\n                    var newObjTransform = newInst.transform;\\n                    newObjTransform.LookAt(playerPos);\\n                    Vector3 newAngle = newObjTransform.rotation.eulerAngles;\\n                    newAngle.x = 0.0f;\\n                    newObjTransform.rotation = Quaternion.Euler(newAngle);\\n                    spawnedCubes.Add(newInst);\\n                }\\n            }\\n        }\\n\\n        #endregion\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1740453223,\"model\":\"gpt-4o-2024-08-06\",\"object\":\"chat.completion\",\"service_tier\":\"default\",\"system_fingerprint\":\"fp_eb9dce56a8\",\"usage\":{\"completion_tokens\":8538,\"prompt_tokens\":2386,\"total_tokens\":10924,\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":0,\"rejected_prediction_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0}}}"