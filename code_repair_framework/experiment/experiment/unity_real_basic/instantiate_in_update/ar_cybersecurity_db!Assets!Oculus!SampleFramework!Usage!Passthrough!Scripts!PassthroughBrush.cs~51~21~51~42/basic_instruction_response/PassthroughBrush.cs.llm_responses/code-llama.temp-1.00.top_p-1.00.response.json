{
    "code_repairing_0": "//Here're the buggy code lines from /Assets/Oculus/SampleFramework/Usage/Passthrough/Scripts/PassthroughBrush.cs:\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PassthroughBrush : MonoBehaviour\n{\n    public OVRInput.Controller controllerHand = OVRInput.Controller.None;\n    public GameObject prefabLineSegment;\n    public GameObject lineContainerPrefab;\n    public bool forceActive = true;\n    LineRenderer currentLineSegment = null;\n    List<Vector3> inkPositions = new List<Vector3>();\n    float minInkDist = 0.01f;\n    float strokeWidth = 0.1f;\n    float strokeLength = 0.0f;\n\n    public enum BrushState\n    {\n        Idle,\n        Inking\n    };\n\n    BrushState brushStatus = BrushState.Idle;\n\n    private void OnDisable()\n    {\n        brushStatus = BrushState.Idle;\n    }\n\n// BUG: Instantiate in Update() method\n// MESSAGE: Update() method is called each frame. It's inefficient to use Instantiate() in Update() method.\n//    void LateUpdate()\n//    {\n//\n//        transform.rotation = Quaternion.LookRotation(transform.position - Camera.main.transform.position);\n//\n//        if (!(controllerHand == OVRInput.Controller.LTouch || controllerHand == OVRInput.Controller.RTouch))\n//        {\n//            return;\n//        }\n//\n//        Vector3 tipPosition = transform.position;\n//        switch (brushStatus)\n//        {\n//            case BrushState.Idle:\n//                if (OVRInput.GetUp(OVRInput.Button.One, controllerHand))\n//                {\n//                    UndoInkLine();\n//                }\n//\n//                if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\n//                {\n//                    StartLine(tipPosition);\n//                    brushStatus = BrushState.Inking;\n//                }\n//\n//                break;\n//            case BrushState.Inking:\n//\n//                UpdateLine(tipPosition);\n//                if (OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\n//                {\n//                    brushStatus = BrushState.Idle;\n//                }\n//\n//                break;\n//        }\n//    }\n\n// FIXED CODE:\n    public void StartLine(Vector3 inkPos)\n    {\n        if(!lineContainer)\n        {\n            lineContainer = Instantiate(lineContainerPrefab);\n        }\n\n        currentLineSegment = Instantiate(prefabLineSegment, transform);\n        currentLineSegment.positionCount = 1;\n        currentLineSegment.SetPosition(0, inkPos);\n        strokeWidth = currentLineSegment.startWidth;\n        strokeLength = 0.0f;\n        inkPositions.Clear();\n        inkPositions.Add(inkPos);\n        currentLineSegment.transform.parent = lineContainer.transform;\n\n    }",
    "code_repairing_1": "```csharp\n  void LateUpdate()\n{\n\n    transform.rotation = Quaternion.LookRotation(transform.position - Camera.main.transform.position);\n\n    if (!(controllerHand == OVRInput.Controller.LTouch || controllerHand == OVRInput.Controller.RTouch))\n    {\n        return;\n    }\n\n    Vector3 tipPosition = transform.position;\n    switch (brushStatus)\n    {\n        case BrushState.Idle:\n            if (OVRInput.GetUp(OVRInput.Button.One, controllerHand))\n            {\n                UndoInkLine();\n            }\n\n            if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\n            {\n                StartLine(tipPosition);\n                brushStatus = BrushState.Inking;\n            }\n\n            break;\n        case BrushState.Inking:\n\n            UpdateLine(tipPosition);\n            if (OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\n            {\n                brushStatus = BrushState.Idle;\n            }\n\n            break;\n    }\n}\n\nvoid StartLine(Vector3 inkPos)\n{\n        GameObject newLine = Instantiate(lineSegmentPrefab, inkPos, Quaternion.identity);\n        currentLineSegment = newLine.GetComponent<LineRenderer>();\n        currentLineSegment.positionCount = 1;\n        currentLineSegment.SetPosition(0, inkPos);\n        strokeWidth = currentLineSegment.startWidth;\n        strokeLength = 0.0f;\n        inkPositions.Clear();\n        inkPositions.Add(inkPos);\n        newLine.transform.parent = lineContainer.transform;\n}\n```\n\nWith these fixes the issue should be resolved.",
    "code_repairing_2": "// Buggy code removed\n\n// FIXED CODE:\nvoid UpdateLine(Vector3 inkPos)\n{\n    if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\n    {\n        StartLine(inkPos);\n        brushStatus = BrushState.Inking;\n    }\n    if (brushStatus == BrushState.Idle)\n        return;\n    // Update the ink line\n    if (inkPositions != null)\n    {\n        inkPositions.Add(inkPos);\n    }\n    else\n    {\n        inkPositions = new List<Vector3>();\n        inkPositions.Add(inkPos);\n    }\n    if (inkPositions.Count > 1)\n    {\n        float distance = 0;\n        Vector3 lastInkPos = inkPositions[inkPositions.Count - 1];\n        for (int i = 0; i < inkPositions.Count - 1; i++)\n        {\n            distance += Vector3.Distance(lastInkPos, inkPositions[i]);\n        }\n        strokeLength = distance / strokeWidth;\n    }\n    currentLineSegment.positionCount = inkPositions.Count;\n    for (int i = 0; i < inkPositions.Count; i++)\n    {\n        currentLineSegment.SetPosition(i, inkPositions[i]);\n    }\n}\n\nvoid LateUpdate()\n{\n    transform.rotation = Quaternion.LookRotation(transform.position - Camera.main.transform.position);\n\n    if (!(controllerHand == OVRInput.Controller.LTouch || controllerHand == OVRInput.Controller.RTouch))\n    {\n        return;\n    }\n\n    Vector3 tipPosition = transform.position;\n\n    switch (brushStatus)\n    {\n        case BrushState.Idle:\n            if (OVRInput.GetUp(OVRInput.Button.One, controllerHand))\n            {\n                UndoInkLine();\n            }\n\n            if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\n            {\n                StartLine(tipPosition);\n                brushStatus = BrushState.Inking;\n            }\n\n            break;\n        case BrushState.Inking:\n\n            UpdateLine(tipPosition);\n            if (OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\n            {\n                brushStatus = BrushState.Idle;\n            }\n\n            break;\n    }\n}",
    "code_repairing_3": "```\n public class PassthroughBrush : MonoBehaviour {\n\n    /*** BUG FIXED CODE ***/\n    private void StartLine(Vector3 inkPos)\n    {\n        GameObject newLine = Instantiate(lineSegmentPrefab, inkPos, Quaternion.identity);\n        currentLineSegment = newLine.GetComponent<LineRenderer>();\n        currentLineSegment.positionCount = 1;\n        currentLineSegment.SetPosition(0, inkPos);\n        strokeWidth = currentLineSegment.startWidth;\n        strokeLength = 0.0f;\n        inkPositions.Clear();\n        inkPositions.Add(inkPos);\n        newLine.transform.parent = lineContainer.transform;\n    }\n\n//   BUG FIXED CODE\n    private void UpdateLine(Vector3 inkPos)\n    {\n        currentLineSegment.positionCount++;\n        currentLineSegment.SetPosition(currentLineSegment.positionCount - 1, inkPos);\n        inkPositions.Add(inkPos);\n        strokeLength += (inkPos - inkPositions[inkPositions.Count - 2]).magnitude;\n        if (strokeLength > minInkDist)\n        {\n            return;\n        }\n        if (!inkPositions.Contains(inkPos))\n        {\n            inkPositions.Add(inkPos);\n            currentLineSegment.positionCount++;\n            currentLineSegment.SetPosition(currentLineSegment.positionCount - 1, inkPos);\n        }\n        else\n        {\n            inkPositions.Clear();\n            inkPositions.Add(inkPos);\n            currentLineSegment.positionCount = 1;\n            currentLineSegment.SetPosition(0, inkPos);\n            strokeWidth = currentLineSegment.startWidth;\n            strokeLength = 0.0f;\n        }\n    }\n}\n```",
    "code_repairing_4": "Here's the fixed code with the bug removed:\n\n\\begin{code}\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PassthroughBrush : MonoBehaviour\n{\n    public OVRInput.Controller controllerHand = OVRInput.Controller.None;\n    public GameObject lineSegmentPrefab;\n    public GameObject lineContainer;\n    public bool forceActive = true;\n    LineRenderer currentLineSegment = null;\n    List<Vector3> inkPositions = new List<Vector3>();\n    float minInkDist = 0.01f;\n    float strokeWidth = 0.1f;\n    float strokeLength = 0.0f;\n\n    public enum BrushState\n    {\n        Idle,\n        Inking\n    }\n\n    BrushState brushStatus = BrushState.Idle;\n\n    private void OnDisable()\n    {\n        brushStatus = BrushState.Idle;\n    }\n\n// BUG: Instantiate in Update() method\n// MESSAGE: Update() method is called each frame. It's inefficient to use Instantiate() in Update() method.\n//    void LateUpdate()\n//    {\n//\n//        transform.rotation = Quaternion.LookRotation(transform.position - Camera.main.transform.position);\n//\n//        if (!(controllerHand == OVRInput.Controller.LTouch || controllerHand == OVRInput.Controller.RTouch))\n//        {\n//            return;\n//        }\n//\n//        Vector3 tipPosition = transform.position;\n//        switch (brushStatus)\n//        {\n//            case BrushState.Idle:\n//                if (OVRInput.GetUp(OVRInput.Button.One, controllerHand))\n//                {\n//                    UndoInkLine();\n//                }\n//\n//                if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\n//                {\n//                    StartLine(tipPosition);\n//                    brushStatus = BrushState.Inking;\n//                }\n//\n//                break;\n//            case BrushState.Inking:\n//\n//                UpdateLine(tipPosition);\n//                if (OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\n//                {\n//                    brushStatus = BrushState.Idle;\n//                }\n//\n//                break;\n//        }\n//    }\n\n    void StartLine(Vector3 inkPos)\n    {\n        GameObject newLine = Instantiate(lineSegmentPrefab, inkPos, Quaternion.identity);\n        currentLineSegment = newLine.GetComponent<LineRenderer>();\n        currentLineSegment.positionCount = 1;\n        currentLineSegment.SetPosition(0, inkPos);\n        strokeWidth = currentLineSegment.startWidth;\n        strokeLength = 0.0f;\n        inkPositions.Clear();\n        inkPositions.Add(inkPos);\n        newLine.transform.parent = lineContainer.transform;\n    }\n}\n\\end{code}\n\nThe `LateUpdate` method is removed and the `StartLine` method is moved out of it."
}