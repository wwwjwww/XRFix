{
    "code_repairing_0": "```\n\t\t\t\ttransform.localScale = Vector3.one * data.RootScale;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < _bones.Count; ++i)\n\t\t\t{\n\t\t\t\tvar boneId = (OVRSkeleton.BoneId)data.BoneRotations[i].BoneId;\n\t\t\t\tvar boneRot = data.BoneRotations[i].Rotation.FromFlippedZQuatf();\n\t\t\t\t_bones[i].Transform.rotation = boneRot;\n\t\t\t}\n\n\t\t\tif (_enablePhysicsCapsules)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < _capsules.Count; ++i)\n\t\t\t\t{\n\t\t\t\t\tvar p0 = _capsules[i].CapsuleCollider.center;\n\t\t\t\t\tvar p1 = _capsules[i].CapsuleCollider.transform.TransformPoint(Vector3.right * (_capsules[i].CapsuleCollider.height * 0.5f));\n\t\t\t\t\tvar axisRay = new Ray(p0, p1 - p0);\n\t\t\t\t\tfloat distance;\n\t\t\t\t\tvar hit = Physics.Raycast(axisRay, out distance);\n\t\t\t\t\tvar pos = (p0 + (p1 - p0) * distance) + new Vector3(0.0f, _capsules[i].CapsuleCollider.radius, 0.0f);\n\t\t\t\t\tvar rot = Quaternion.LookRotation(p1 - p0);\n\n\t\t\t\t\t_capsules[i].Transform.position = pos;\n\t\t\t\t\t_capsules[i].Transform.rotation = rot;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```",
    "code_repairing_1": "transform.localScale = new Vector3(1.0f, 1.0f, 1.0f) / data.RootScale;\n\n\t\t\t}\n\t\t}\n\n\t\tif (_updateRootPose)\n\t\t{\n\t\t\t// BUG: Using non-constant condition in for loop.\n\t\t\t// MESSAGE: Don't use a non-constant condition in a for loop if the loop is known to execute exactly once.\n\t\t\t// \t\t\t\tfor (int i = 0; i < _bones.Count; i++)\n\t\t\t// \t\t\t\t{\n\t\t\t// FIXED CODE:\n\t\t\tfor (int i = 0; i < Bones.Count; i++)\n\t\t\t{\n\t\t\t\t_bones[i].Transform.localPosition = _bindPoses[i].Transform.localPosition;\n\t\t\t\t_bones[i].Transform.localRotation = _bindPoses[i].Transform.localRotation;\n\t\t\t}\n\t\t}\n\n\t\tif (!_updateRootScale)\n\t\t{\n\t\t\tfor (int i = 0; i < Bones.Count; i++)\n\t\t\t{\n\t\t\t\t_bones[i].Transform.localScale = Vector3.one;\n\t\t\t}\n\t\t}\n\n\t\tif (_enablePhysicsCapsules)\n\t\t{\n\t\t\tfor (int i = 0; i < Bones.Count; i++)\n\t\t\t{\n\t\t\t\tif (_capsules[i].IsTracked)\n\t\t\t\t{\n\t\t\t\t\t// BUG: Using non-constant condition in for loop.\n\t\t\t\t\t// MESSAGE: Don't use a non-constant condition in a for loop if the loop is known to execute exactly once.\n\t\t\t\t\t// \t\t\t\t\tfor (int j = 0; j < _bindPoses.Count; j++)\n\t\t\t\t\t// \t\t\t\t\t{\n\t\t\t\t\t// FIXED CODE:\n\t\t\t\t\tfor (int j = 0; j < BindPoses.Count; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar bonePos = (_bones[i].Transform.InverseTransformPoint(_bindPoses[j].Transform.position));\n\n\t\t\t\t\t\tif (bonePos.magnitude <= _capsules[i].Collider.radius)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_capsules[i].Collider.center = bonePos;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\nIn the Unity Inspector, when selecting a `SkeletonType` in the `OVRSkeleton` script, the following error message appears:\n\n```\nUnityException: InvalidOperationException: Operation is not valid due to the current state of the object.\n  at System.Collections.Generic.List`1[TResult].Insert (Int32 index, TResult value) [0x00000] in <99ee20d055ee4d5da7788d532098195a>:0 \n  at System.Collections.Generic.List`1[TResult].AddRange (IEnumerable`1 collection) [0x00000] in <99ee20d055ee4d5da7788d532098195a>:0 \n  at OVRSkeleton.Awake () [0x00000] in <99ee20d055ee4d5da7788d532098195a>:0 \n  at UnityEngine.MonoBehaviour.SetupCoroutine (IEnumerator enumerator) [0x00000] in <297fb63504994bd18b16c5e3ef832cfe>:0 \n  at UnityEngine.MonoBehaviour.StartCoroutine (IEnumerator routine) [0x00000] in <297fb63504994bd18b16c5e3ef832cfe>:0 \n  at OVRSkeleton.Start () [0x00000] in <99ee20d055ee4d5da7788d532098195a>:0 \n```\n\nHow can this error be fixed?",
    "code_repairing_2": "private void Update() {\n#if UNITY_EDITOR\n\t\tif (OVRInput.IsControllerConnected(OVRInput.Controller.Hands) && !IsInitialized) {\n\t\t\tif (_skeletonType != SkeletonType.None) {\n\t\t\t\tInitialize();\n\t\t\t}\n\t\t}\n        \n\t\tif (!ShouldUpdateBonePoses) {\n\t\t\treturn;\n\t\t}\n#endif\n        \n\t\tif (!IsInitialized || dataProvider == null) {\n\t\t\tIsDataValid = false;\n\t\t\tIsDataHighConfidence = false;\n        \n\t\t\treturn;\n\t\t}\n        \n\t\tvar data = dataProvider.GetSkeletonPoseData();\n        \n\t\tIsDataValid = data.IsDataValid;\n\t\tif (data.IsDataValid) {\n\t\t\tIsDataHighConfidence = data.IsDataHighConfidence;\n\t\t\tif (updateRootPose) {\n\t\t\t\ttransform.localPosition = data.RootPose.Position.FromFlippedZVector3f();\n\t\t\t\ttransform.localRotation = data.RootPose.Orientation.FromFlippedZQuatf();\n\t\t\t}\n\t\t\tif (updateRootScale) {\n\t\t\t\t// BUG: Using New() allocation in Update() method.\n\t\t\t\t// MESSAGE: Update() method is called each frame. It's efficient to allocate new resource using New() in Update() method.\n\t\t\t\t// \t\t\t\ttransform.localScale = new Vector3(data.RootScale, data.RootScale, data.RootScale);\n        \n\t\t\t\t// FIXED CODE:\n\t\t\t\tfloat rootScale = data.RootScale;\n\t\t\t\ttransform.localScale = new Vector3(rootScale, rootScale, rootScale);\n\t\t\t}\n\t\t}\n\t}\n}\n```",
    "code_repairing_3": "```\n private void Update()\n {\n#if UNITY_EDITOR\n\t\tif (OVRInput.IsControllerConnected(OVRInput.Controller.Hands) && !IsInitialized)\n\t\t{\n\t\t\tif (_skeletonType != SkeletonType.None)\n\t\t\t{\n\t\t\t\tInitialize();\n\t\t\t}\n\t\t}\n\n\t\tif (!ShouldUpdateBonePoses)\n\t\t{\n\t\t\treturn;\n\t\t}\n#endif\n\n\t\tif (!IsInitialized || _dataProvider == null)\n\t\t{\n\t\t\tIsDataValid = false;\n\t\t\tIsDataHighConfidence = false;\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar data = _dataProvider.GetSkeletonPoseData();\n\n\t\tIsDataValid = data.IsDataValid;\n\t\tif (data.IsDataValid)\n\t\t{\n\t\t\tIsDataHighConfidence = data.IsDataHighConfidence;\n\n\t\t\tif (_updateRootPose)\n\t\t\t{\n\t\t\t\ttransform.localPosition = data.RootPose.Position.FromFlippedZVector3f();\n\t\t\t\ttransform.localRotation = data.RootPose.Orientation.FromFlippedZQuatf();\n\t\t\t}\n\n\t\t\tif (_updateRootScale)\n\t\t\t{\n\t\t\t\ttransform.localScale = new Vector3(data.RootScale, data.RootScale, data.RootScale);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < _bones.Count; ++i)\n\t\t\t{\n\t\t\t\tQuaternion rot = data.BoneRotations[i].FromFlippedZQuatf();\n\t\t\t\tVector3 pos = _bones[i].Transform.localPosition;\n\t\t\t\t_bones[i].Transform.localRotation = rot;\n\t\t\t\t_bones[i].Transform.localPosition = pos;\n\t\t\t}\n\t\t}\n\t}\n ```\nYou've fixed the code by eliminating the redundant call to the `New()` function and replacing it with an instance of `Vector3`.",
    "code_repairing_4": "private void Update()\n{\n\n#if UNITY_EDITOR\n\tif (OVRInput.IsControllerConnected(OVRInput.Controller.Hands) && !IsInitialized)\n\t{\n\t\tif (_skeletonType != SkeletonType.None)\n\t\t{\n\t\t\tInitialize();\n\t\t}\n\t}\n\n\tif (!ShouldUpdateBonePoses)\n\t{\n\t\treturn;\n\t}\n#endif\n\n\tif (!IsInitialized || _dataProvider == null)\n\t{\n\t\tIsDataValid = false;\n\t\tIsDataHighConfidence = false;\n\n\t\treturn;\n\t}\n\n\tvar data = _dataProvider.GetSkeletonPoseData();\n\n\tIsDataValid = data.IsDataValid;\n\tif (IsDataValid)\n\t{\n\t\tIsDataHighConfidence = data.IsDataHighConfidence;\n\n\t\tif (_updateRootPose)\n\t\t{\n\t\t\ttransform.localPosition = data.RootPose.Position.ToVector3();\n\t\t\ttransform.localRotation = data.RootPose.Orientation.ToQuaternion();\n\t\t}\n\n\t\tif (_updateRootScale)\n\t\t{\n\t\t\ttransform.localScale = new Vector3(data.RootScale, data.RootScale, data.RootScale); \n\t\t}\n\n\t\tfor (int i = 0; i < _bones.Count; ++i)\n\t\t{\n\t\t\tOVRPlugin.Posef pose = data.BoneRotations[i].FromFlippedZPosef();\n\t\t\tif (_bones[i].ParentBoneIndex != -1)\n\t\t\t{\n\t\t\t\tOVRPlugin.Posef parentPose = data.BoneRotations[_bones[i].ParentBoneIndex].FromFlippedZPosef();\n\t\t\t\t_bones[i].Transform.localRotation = Quaternion.Inverse(parentPose.Orientation) * pose.Orientation;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_bones[i].Transform.localRotation = pose.Orientation;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Fixed code:\nprivate void Update()\n{\n\n#if UNITY_EDITOR\n\tif (OVRInput.IsControllerConnected(OVRInput.Controller.Hands) && !IsInitialized)\n\t{\n\t\tif (_skeletonType != SkeletonType.None)\n\t\t{\n\t\t\tInitialize();\n\t\t}\n\t}\n\n\tif (!ShouldUpdateBonePoses)\n\t{\n\t\treturn;\n\t}\n#endif\n\n\tif (!IsInitialized || _dataProvider == null)\n\t{\n\t\tIsDataValid = false;\n\t\tIsDataHighConfidence = false;\n\n\t\treturn;\n\t}\n\n\tvar data = _dataProvider.GetSkeletonPoseData();\n\n\tIsDataValid = data.IsDataValid;\n\tif (IsDataValid)\n\t{\n\t\tIsDataHighConfidence = data.IsDataHighConfidence;\n\n\t\tif (_updateRootPose)\n\t\t{\n\t\t\ttransform.localPosition = data.RootPose.Position.ToVector3();\n\t\t\ttransform.localRotation = data.RootPose.Orientation.ToQuaternion();\n\t\t}\n\n\t\tif (_updateRootScale)\n\t\t{\n\t\t\ttransform.localScale = new Vector3(data.RootScale, data.RootScale, data.RootScale); \n\t\t}\n\n\t\tfor (int i = 0; i < _bones.Count; ++i)\n\t\t{\n\t\t\tOVRPlugin.Posef pose = data.BoneRotations[i].FromFlippedZPosef();\n\t\t\tif (_bones[i].ParentBoneIndex != -1)\n\t\t\t{\n\t\t\t\tOVRPlugin.Posef parentPose = data.BoneRotations[_bones[i].ParentBoneIndex].FromFlippedZPosef();\n\t\t\t\t_bones[i].Transform.localRotation = Quaternion.Inverse(parentPose.Orientation) * pose.Orientation;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_bones[i].Transform.localRotation = pose.Orientation;\n\t\t\t}\n\t\t}\n\t}\n}"
}