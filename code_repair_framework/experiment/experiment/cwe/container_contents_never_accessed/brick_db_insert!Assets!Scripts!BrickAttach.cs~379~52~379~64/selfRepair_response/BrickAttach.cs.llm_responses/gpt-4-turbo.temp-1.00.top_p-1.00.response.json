"{\"id\":\"chatcmpl-BqhYiqBHh1GK8zF7gnppRxCQom8mZ\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\n    // private readonly Dictionary<BrickAttach, bool> _attachBuffer = new Dictionary<BrickAttach, bool>();\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}},{\"finish_reason\":\"stop\",\"index\":1,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\n    // Removed the unused dictionary _attachBuffer\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}},{\"finish_reason\":\"stop\",\"index\":2,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nprivate readonly Collider[] _colliderBuffer = new Collider[20];\\n// Comment: The following dictionary was deemed unnecessary since its contents are never accessed\\n// private readonly Dictionary<BrickAttach, bool> _attachBuffer = new Dictionary<BrickAttach, bool>();\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}},{\"finish_reason\":\"stop\",\"index\":3,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Diagnostics.CodeAnalysis;\\nusing Random = UnityEngine.Random;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing System.Linq;\\nusing System;\\n\\n[SuppressMessage(\\\"ReSharper\\\", \\\"ReturnTypeCanBeEnumerable.Local\\\")]\\npublic class BrickAttach : MonoBehaviour {\\n    private Color32 _color;\\n    public Color32 Color {\\n        get => _color;\\n        set => SetColor(value);\\n    }\\n\\n    public Color32 HoverColor {\\n        get {\\n            int difference = (Convert.ToInt32(_color.r) + Convert.ToInt32(_color.g) + Convert.ToInt32(_color.b)) > 300\\n                ? -20\\n                : 20;\\n            byte r = (byte)(Mathf.Clamp(_color.r + difference, 0, 255));\\n            byte g = (byte)(Mathf.Clamp(_color.g + difference, 0, 255));\\n            byte b = (byte)(Mathf.Clamp(_color.b + difference, 0, 255));\\n            byte a = (byte)(Mathf.Clamp(_color.a, 0, 255));\\n\\n            return new Color32(r, g, b, a);\\n        }\\n    }\\n\\n    private Session session;\\n    private bool _hoveredLeft;\\n    private bool _hoveredRight;\\n    public bool Held { get; private set; }\\n\\n    public int renderQueue;\\n\\n    public GameObject maleConnectorParent;\\n    public GameObject femaleConnectorParent;\\n\\n    public GameObject model;\\n    public GameObject combinedModel;\\n\\n    private BrickUuid _brickUuid;\\n    private GameObject _modularModel;\\n\\n    private BulkGrabFollow[] _attachedBulkGrabFollows;\\n\\n    public string swapPrefab;\\n\\n    public string normalPrefabName;\\n\\n    public List<GameObject> maleConnectors;\\n    public List<GameObject> femaleConnectors;\\n\\n    public List<LegoConnectorScript> maleConnectorScripts;\\n    public List<LegoConnectorScript> femaleConnectorScripts;\\n\\n    private readonly Dictionary<string, LegoConnectorScript> maleConnectorScriptsByName =\\n        new Dictionary<string, LegoConnectorScript>();\\n\\n    public Mesh originalMesh;\\n    public Material originalMaterial;\\n\\n    private UserSettings _userSettings;\\n    private static readonly int ShaderColorProperty = Shader.PropertyToID(\\\"_Color\\\");\\n    private static readonly int ShaderTexOffsetProperty = Shader.PropertyToID(\\\"_TexOffset\\\");\\n    private MaterialPropertyBlock _props;\\n\\n    public Mesh solidMesh;\\n    public Mesh hollowMesh;\\n    public Mesh studMesh;\\n\\n    public PlacedBrickRenderer placedBrickRenderer;\\n\\n    public MeshFilter meshFilter;\\n    public MeshRenderer meshRenderer;\\n\\n    public bool renderHollowMesh;\\n\\n    public string headClientId;\\n    public bool isPlayerHead;\\n\\n    private AvatarManager _avatarManager;\\n\\n    public float texOffset;\\n\\n    private void Awake() {\\n        texOffset = Random.Range(0f, 1f);\\n        _props = new MaterialPropertyBlock();\\n        _brickUuid = GetComponent<BrickUuid>();\\n        _userSettings = UserSettings.GetInstance();\\n        placedBrickRenderer = GetComponent<PlacedBrickRenderer>();\\n        meshFilter = model.GetComponent<MeshFilter>();\\n        meshRenderer = model.GetComponent<MeshRenderer>();\\n\\n        foreach (Transform child in maleConnectorParent.transform) {\\n            maleConnectorScriptsByName.Add(child.gameObject.name, child.gameObject.GetComponent<LegoConnectorScript>());\\n        }\\n\\n        ModularBrickObjects modularBrickObject = ModularBrickObjects.GetInstance();\\n        _modularModel = modularBrickObject.GetModularModel(normalPrefabName);\\n        solidMesh = modularBrickObject.GetSolidMesh(normalPrefabName);\\n        hollowMesh = modularBrickObject.GetHollowMesh(normalPrefabName);\\n        studMesh = modularBrickObject.GetStudMesh(normalPrefabName);\\n\\n        if (Application.isEditor) {\\n            originalMaterial = model.GetComponent<MeshRenderer>().sharedMaterial;\\n            originalMesh = _userSettings.SuperUltraPerformanceMode\\n            ? _modularModel.transform.Find(\\\"FlatBody\\\").GetComponentInChildren<MeshFilter>().sharedMesh\\n            : model.GetComponent<MeshFilter>().sharedMesh;\\n        }\\n\\n        SetSortedMaterial();\\n    }\\n\\n    private void Start() {\\n        OwnedPhysicsBricksStore.GetInstance().AddBrick(gameObject);\\n        _avatarManager = AvatarManager.GetInstance();\\n        session = Session.GetInstance();\\n        headClientId = session.ClientID;\\n\\n        if (!isPlayerHead && headClientId == session.ClientID)\\n            ChunkedRenderer.GetInstance().AddBrickToRenderer(gameObject);\\n    }\\n\\n    private void SetSortedMaterial(Mesh mesh = null)\\n    {\\n        MeshRenderer meshRenderer = model.GetComponent<MeshRenderer>();\\n\\n        meshRenderer.material = BrickRenderQueueSorter.SortedMaterialFromMesh(mesh ? mesh : meshFilter.sharedMesh, meshRenderer.sharedMaterial);\\n        renderQueue = meshRenderer.sharedMaterial.renderQueue;\\n    }\\n\\n    public void SetUuid(string uuid) {\\n        _brickUuid.uuid = uuid;\\n    }\\n\\n    public string GetUuid()\\n    {\\n        return _brickUuid.uuid;\\n    }\\n\\n    public void SetColor(Color32 color)\\n    {\\n        if (!model)\\n        {\\n            Debug.LogError(\\\"There should be a model on this object\\\");\\n            return;\\n        }\\n\\n        _color = color;\\n\\n        UpdateBrickColor();\\n    }\\n\\n    public void SetHovered(bool hovered, bool left)\\n    {\\n        if ((left && (_hoveredLeft == hovered)) || (!left && (_hoveredRight == hovered)))\\n            return;\\n\\n        if (left)\\n            _hoveredLeft = hovered;\\n        else\\n            _hoveredRight = hovered;\\n\\n        UpdateBrickColor();\\n    }\\n\\n    public void SetHeld(bool held)\\n    {\\n        if (Held == held)\\n            return;\\n\\n        Held = held;\\n        UpdateBrickColor();\\n    }\\n\\n    private void UpdateBrickColor() {\\n        if (_props == null) return;\\n\\n        _props.SetColor(ShaderColorProperty, (_hoveredLeft || _hoveredRight || Held) ? HoverColor : _color);\\n        _props.SetFloat(ShaderTexOffsetProperty, texOffset);\\n\\n        MeshRenderer renderer = model.GetComponent<MeshRenderer>();\\n        renderer.SetPropertyBlock(_props);\\n    }\\n\\n    public bool ConnectBricks(Vector3 newPos, Quaternion newRot, Vector3 connectionDirection, Session session = null) {\\n        session = session ?? Session.GetInstance();\\n        transform.position = newPos;\\n        transform.rotation = newRot;\\n\\n        List<GameObject> bricksBelow = OverlappingBricksFromConnectors(femaleConnectors);\\n        List<BrickAttach> bricksBelowAttaches = bricksBelow.Select(b => b.GetComponent<BrickAttach>()).ToList();\\n\\n        List<GameObject> bricksAbove = OverlappingBricksFromConnectors(maleConnectors);\\n        List<BrickAttach> bricksAboveAttaches = bricksAbove.Select(b => b.GetComponent<BrickAttach>()).ToList();\\n\\n        string attachedToHeadClientId = session.ClientID;\\n        foreach(BrickAttach attach in bricksBelowAttaches)\\n            if (attach.headClientId != session.ClientID)\\n                attachedToHeadClientId = attach.headClientId;\\n\\n        foreach(BrickAttach attach in bricksAboveAttaches)\\n            if (attach.headClientId != session.ClientID)\\n                attachedToHeadClientId = attach.headClientId;\\n\\n        for (int i = 0; i < bricksBelowAttaches.Count; i++) {\\n            ConfigureNeighboringBrick(bricksBelowAttaches[i], bricksBelow[i], true);\\n        }\\n\\n        for (int i = 0; i < bricksAboveAttaches.Count(); i++) {\\n            ConfigureNeighboringBrick(bricksAboveAttaches[i], bricksAbove[i], false);\\n        }\\n\\n        BrickSwapper.SwapToFakeBrick(gameObject, attachedToHeadClientId, _avatarManager);\\n\\n        return true;\\n    }\\n\\n    private void ConfigureNeighboringBrick(BrickAttach attach, GameObject brick, bool below) {\\n        if (attach == null) return;\\n        if (attach.GetUuid() == GetUuid()) return;\\n\\n        BrickSwapper.SwapToFakeBrick(brick);\\n    }\\n\\n    private List<GameObject> OverlappingBricksFromConnectors(List<GameObject> connectors) {\\n        return connectors.Select(OverlappingBrickFromConnector).Where(x => x != null).Distinct().ToList();\\n    }\\n\\n    private GameObject OverlappingBrickFromConnector(GameObject connector) {\\n        return connector.GetComponent<LegoConnectorScript>().BrickCollidingWith(null);\\n    }\\n\\n    public void RecalculateEnabledConnectors() {\\n        foreach (LegoConnectorScript script in maleConnectorScripts) {\\n            script.RecalculateEnabled();\\n        }\\n\\n        foreach (LegoConnectorScript script in femaleConnectorScripts) {\\n            script.RecalculateEnabled();\\n        }\\n    }\\n\\n    public void RecalculateRenderedGeometry() {\\n\\n        bool placed = !(placedBrickRenderer != null);\\n        bool performanceMode = _userSettings.SuperUltraPerformanceMode;\\n\\n        string cacheKey = \\\"\\\";\\n        cacheKey += normalPrefabName;\\n\\n        bool allFemalePegsCovered = femaleConnectorScripts.All(s => s.covered);\\n\\n        bool isOnCarpet = IsOnCarpet();\\n\\n        if (performanceMode)\\n        {\\n            cacheKey += \\\"perfmode\\\"; \\n        }\\n        else\\n        {\\n            foreach (LegoConnectorScript s in maleConnectorScripts)\\n            {\\n                cacheKey += ((placed && s.covered) ? \\\"Y\\\" : \\\"N\\\");\\n            }\\n\\n            if((allFemalePegsCovered || isOnCarpet) && placed) cacheKey += \\\"-bottomcovered\\\";\\n        }\\n\\n        MeshFilter combinedMeshFilter = combinedModel.GetComponent<MeshFilter>();\\n\\n        Mesh cachedMesh = BrickMeshCache.GetInstance().Get(cacheKey);\\n        if (cachedMesh != null)\\n        {\\n            combinedMeshFilter.mesh = cachedMesh;\\n            SetSortedMaterial(combinedMeshFilter.sharedMesh);\\n            return;\\n        }\\n\\n        Vector3 originalPos = transform.position;\\n        transform.position = Vector3.zero;\\n\\n        Quaternion originalRot = transform.rotation;\\n        transform.rotation = Quaternion.identity;\\n\\n        List<CombineInstance> combineInstances = new List<CombineInstance>();\\n\\n        _modularModel.transform.position = transform.position;\\n\\n        foreach(MeshFilter meshFilter in _modularModel.GetComponentsInChildren<MeshFilter>())\\n        {\\n            GameObject obj = meshFilter.gameObject;\\n            string parentName = meshFilter.transform.parent.name;\\n\\n            switch (parentName)\\n            {\\n                case \\\"Studs\\\" when (maleConnectorScriptsByName[obj.name].covered || performanceMode):\\n                case \\\"Tubes\\\" when (allFemalePegsCovered || performanceMode):\\n                case \\\"Body\\\" when (allFemalePegsCovered || performanceMode || isOnCarpet):\\n                case \\\"FlatBody\\\" when !performanceMode && !allFemalePegsCovered && !isOnCarpet:\\n                    continue;\\n            }\\n\\n            CombineInstance instance = new CombineInstance();\\n            instance.mesh = obj.GetComponent<MeshFilter>().sharedMesh;\\n            instance.transform = obj.GetComponent<MeshFilter>().transform.localToWorldMatrix;\\n            combineInstances.Add(instance);\\n        }\\n\\n        Mesh newMesh = new Mesh();\\n        combinedMeshFilter.mesh = newMesh;\\n        combinedMeshFilter.mesh.CombineMeshes(combineInstances.ToArray());\\n        combinedMeshFilter.mesh.Optimize();\\n\\n        BrickMeshCache.GetInstance().Put(cacheKey, combinedMeshFilter.sharedMesh);\\n\\n        transform.position = originalPos;\\n        transform.rotation = originalRot;\\n\\n        SetColor(_color);\\n        SetSortedMaterial(combinedMeshFilter.sharedMesh);\\n    }\\n\\n    public void DelayedDestroy()\\n    {\\n        BrickDestroyer.GetInstance().DelayedDestroy(gameObject);\\n    }\\n\\n    public bool IsOnCarpet()\\n    {\\n        return Math.Abs((transform.position.y + femaleConnectorParent.transform.localPosition.y) - (-0.065864f)) < 0.001f;\\n    }\\n\\n    private void OnValidate()\\n    {\\n        if (!Application.isEditor) return;\\n        if (Application.isPlaying) return;\\n\\n        maleConnectors = new List<GameObject>();\\n        maleConnectorScripts = new List<LegoConnectorScript>();\\n        foreach (Transform child in maleConnectorParent.transform)\\n        {\\n            maleConnectors.Add(child.gameObject);\\n            maleConnectorScripts.Add(child.gameObject.GetComponent<LegoConnectorScript>());\\n        }\\n\\n        femaleConnectors = new List<GameObject>();\\n        femaleConnectorScripts = new List<LegoConnectorScript>();\\n        foreach (Transform child in femaleConnectorParent.transform)\\n        {\\n            femaleConnectors.Add(child.gameObject);\\n            femaleConnectorScripts.Add(child.gameObject.GetComponent<LegoConnectorScript>());\\n        }\\n    }\\n\\n    private readonly Collider[] _colliderBuffer = new Collider[20];\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}},{\"finish_reason\":\"stop\",\"index\":4,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nprivate readonly Collider[] _colliderBuffer = new Collider[20];\\n// Removed unused collection based on code analysis suggestion\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}}],\"created\":1751900196,\"model\":\"gpt-4o-2024-08-06\",\"object\":\"chat.completion\",\"service_tier\":\"default\",\"system_fingerprint\":\"fp_07871e2ad8\",\"usage\":{\"completion_tokens\":2683,\"prompt_tokens\":2695,\"total_tokens\":5378,\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":0,\"rejected_prediction_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0}}}"