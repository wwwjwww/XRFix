"{\"id\":\"chatcmpl-BqiOkUCI2K4QtDLi42BLY1CavWrOj\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing UnityEngine.XR.Interaction.Toolkit;\\nusing System.Collections.Generic;\\nusing UnityEngine.Serialization;\\nusing UnityEngine;\\nusing System.Linq;\\nusing System;\\n\\npublic class BrickAttachDetector : MonoBehaviour\\n{\\n    [FormerlySerializedAs(\\\"_isBeingHeld\\\")] public bool isBeingHeld = false;\\n    [FormerlySerializedAs(\\\"_isAttached\\\")] public bool isAttached = false;\\n\\n    public GameObject maleConnectorParent;\\n    public GameObject femaleConnectorParent;\\n\\n    public List<GameObject> _maleConnectors;\\n    public List<GameObject> _femaleConnectors;\\n\\n    public GameObject model;\\n\\n    private Vector3 _collisionExtents;\\n    private Vector3 _colliderOffset;\\n\\n    private Transform _transform;\\n\\n    private HapticsManager _hapticsManager;\\n\\n    private XRGrabInteractable _xrGrabInteractable;\\n    private OwnedPhysicsBricksStore _ownedPhysicsBricksStore;\\n\\n    public bool skipGrabCallbacks;\\n\\n    public bool tile;\\n    public bool window;\\n\\n    public BoxCollider[] colliders;\\n    private bool _usingBuiltInColliders;\\n\\n    public float heightOverride;\\n\\n    private void Awake()\\n    {\\n        BoxCollider boxCollider = GetComponent<BoxCollider>();\\n        _collisionExtents = Vector3.Scale(boxCollider.size / 2, transform.lossyScale); \\n        _xrGrabInteractable = GetComponent<XRGrabInteractable>();\\n        _ownedPhysicsBricksStore = OwnedPhysicsBricksStore.GetInstance();\\n        _colliderOffset = boxCollider.center;\\n        foreach(BoxCollider c in colliders)\\n            if (c.gameObject == gameObject)\\n                _usingBuiltInColliders = true;\\n    }\\n\\n    private void Start()\\n    {\\n        _transform = transform;\\n        _hapticsManager = HapticsManager.GetInstance();\\n    }\\n\\n    private void OnEnable()\\n    {\\n        GetComponent<XRBaseInteractable>().onSelectEnter.AddListener(BrickGrabbed);\\n        GetComponent<XRBaseInteractable>().onSelectExit.AddListener(BrickReleased);\\n    }\\n\\n    private void OnDisable()\\n    {\\n        GetComponent<XRBaseInteractable>()?.onSelectEnter.RemoveListener(BrickGrabbed);\\n        GetComponent<XRBaseInteractable>().onSelectExit.RemoveListener(BrickReleased);\\n    }\\n\\n    private void BrickGrabbed(XRBaseInteractor interactor)\\n    {\\n        if (skipGrabCallbacks) return;\\n            \\n        foreach (Collider c in colliders)\\n        {\\n            c.isTrigger = true;\\n        }\\n\\n        GetComponent<Rigidbody>().isKinematic = false;\\n\\n        isBeingHeld = true;\\n        isAttached = false;\\n\\n        GetComponent<ShowSnappableBrickPositions>().enabled = true;\\n        _ownedPhysicsBricksStore.AddBrick(gameObject);\\n    }\\n\\n    private void BrickReleased(XRBaseInteractor interactor)\\n    {\\n        if (skipGrabCallbacks) return;\\n        if (!isBeingHeld) return;\\n\\n        isBeingHeld = false;\\n\\n        (bool canConnect, Vector3 newPos, Quaternion newRot, Vector3 connectionDirection) = CheckIfCanConnect();\\n        if (canConnect) {\\n            try {\\n                if (GetComponent<BrickAttach>().ConnectBricks(newPos, newRot, connectionDirection)) {\\n                    bool leftHand = interactor.transform.parent.gameObject.name == \\\"LeftHand\\\";\\n                    _hapticsManager.PlayHaptics(0.5f, 0.5f, 0.1f, !leftHand, leftHand);\\n                }\\n            } catch (Exception e) {\\n                Debug.Log(\\\"SOMETHING EXPLODED!\\\");\\n                Debug.Log(e.Message);\\n                Debug.Log(e.StackTrace);\\n\\n                Session session = SessionManager.GetInstance().session;\\n                Debug.Log(session.CanPlace);\\n                Debug.Log(session.GetSessionType());\\n\\n                EnableGravityIfUnowned();\\n            }\\n        } else {\\n            EnableGravityIfUnowned();\\n        }\\n\\n        XRGrabInteractable ourInteractable = GetComponent<XRGrabInteractable>();\\n\\n        GetComponent<XRGrabInteractable>().interactionManager.ForceHoverExit(interactor, ourInteractable);\\n\\n        foreach (Collider c in colliders) {\\n            c.enabled = true;\\n            c.isTrigger = false;\\n        }\\n\\n        GetComponent<ShowSnappableBrickPositions>().ResetAndDisable();\\n    }\\n\\n    private void EnableGravityIfUnowned()\\n    {\\n        Wait.ForFrames(2, () =>\\n        {\\n            if (!this) return;\\n            if (_xrGrabInteractable.isSelected) return;\\n\\n            Rigidbody rb = GetComponent<Rigidbody>();\\n            rb.isKinematic = false;\\n            rb.useGravity = true;\\n        });\\n    }\\n\\n    private readonly (bool, Vector3, Quaternion, Vector3) _nullResponse = (false, Vector3.zero, Quaternion.identity, Vector3.zero);\\n    \\n    public (bool canConnect, Vector3 pos, Quaternion rot, Vector3 connectionDirection) CheckIfCanConnect()\\n    {\\n        if (!SessionManager.GetInstance().session.CanPlace)\\n            return _nullResponse;\\n\\n        GameObject[] femaleConnectorsWithConnections = GetFemaleConnectorsWithConnections();\\n        GameObject[] maleConnectorsWithConnections = GetMaleConnectorsWithConnections();\\n\\n        GameObject[] validFemaleConnectors = ValidConnections(femaleConnectorsWithConnections);\\n        GameObject[] validMaleConnectors = ValidConnections(maleConnectorsWithConnections);\\n\\n        GameObject[] connectorsToUse = validFemaleConnectors.Length > validMaleConnectors.Length\\n            ? validFemaleConnectors\\n            : validMaleConnectors;\\n\\n        bool connectingDownwards = connectorsToUse == validFemaleConnectors;\\n\\n        if (connectorsToUse.Length > 0)\\n        {\\n            Transform otherBrickTransform = ClosestConnectorFromConnector(connectorsToUse[0]).transform.parent.transform.parent;\\n            GameObject otherBrick = otherBrickTransform.gameObject; \\n            Vector3 otherBrickOriginalRot = otherBrick.transform.rotation.eulerAngles;\\n\\n            if (!IsVectorApproximatelyOne(otherBrickTransform.lossyScale))\\n            {\\n                return _nullResponse;\\n            }\\n\\n            Vector3 brickCurrentPos = _transform.position;\\n            Quaternion brickCurrentRot = _transform.rotation;\\n\\n            _transform.parent = otherBrick.transform;\\n            Vector3 oldEulerAngles = otherBrick.transform.rotation.eulerAngles;\\n\\n            GameObject otherBrickConnector = ClosestConnectorFromConnector(connectorsToUse[0]);\\n            Transform otherConnectorTransform = otherBrickConnector.transform;\\n\\n            otherBrick.transform.eulerAngles += new Vector3(-oldEulerAngles.x - otherConnectorTransform.localEulerAngles.x, 0, -oldEulerAngles.z - otherConnectorTransform.localEulerAngles.z);\\n\\n            Quaternion rot = GetNewRot(otherBrickConnector);\\n            Vector3 pos = GetNewPosWithRot(rot, otherBrick, connectorsToUse, connectingDownwards);\\n\\n            _transform.position = pos;\\n            _transform.rotation = rot;\\n\\n            otherBrick.transform.eulerAngles = otherBrickOriginalRot;\\n\\n            Quaternion adjustedRot = _transform.rotation;\\n            Vector3 adjustedPos = _transform.position;\\n\\n            bool collidesWithBricks = CollidesWithBricks(adjustedRot, adjustedPos);\\n\\n            _transform.position = brickCurrentPos;\\n            _transform.rotation = brickCurrentRot;\\n\\n            _transform.parent = null;\\n\\n            if (collidesWithBricks)\\n            {\\n                return _nullResponse;\\n            }\\n\\n            adjustedRot *= Quaternion.Euler(0, 180f, 0);\\n\\n            return (true, adjustedPos, adjustedRot, connectingDownwards ? Vector3.down : Vector3.up);\\n        }\\n\\n        return _nullResponse;\\n    }\\n\\n    private void OnDrawGizmos()\\n    {\\n        foreach (BoxCollider c in colliders)\\n        {\\n            Gizmos.DrawWireCube(_transform.position - (_transform.position - _transform.TransformPoint(c.center)),\\n                Vector3.Scale(c.size, c.transform.lossyScale));\\n        }\\n    }\\n\\n    // The testObjects list has been removed as it was not used in the code.\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}},{\"finish_reason\":\"stop\",\"index\":1,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing UnityEngine.XR.Interaction.Toolkit;\\nusing System.Collections.Generic;\\nusing UnityEngine.Serialization;\\nusing UnityEngine;\\nusing System.Linq;\\nusing System;\\n\\npublic class BrickAttachDetector : MonoBehaviour\\n{\\n    [FormerlySerializedAs(\\\"_isBeingHeld\\\")] public bool isBeingHeld = false;\\n    [FormerlySerializedAs(\\\"_isAttached\\\")] public bool isAttached = false;\\n\\n    public GameObject maleConnectorParent;\\n    public GameObject femaleConnectorParent;\\n\\n    public List<GameObject> _maleConnectors;\\n    public List<GameObject> _femaleConnectors;\\n\\n    public GameObject model;\\n\\n    private Vector3 _collisionExtents;\\n    private Vector3 _colliderOffset;\\n\\n    private Transform _transform;\\n\\n    private HapticsManager _hapticsManager;\\n\\n    private XRGrabInteractable _xrGrabInteractable;\\n    private OwnedPhysicsBricksStore _ownedPhysicsBricksStore;\\n\\n    public bool skipGrabCallbacks;\\n\\n    public bool tile;\\n    public bool window;\\n\\n    public BoxCollider[] colliders;\\n    private bool _usingBuiltInColliders;\\n\\n    public float heightOverride;\\n\\n    private void Awake()\\n    {\\n        BoxCollider boxCollider = GetComponent<BoxCollider>();\\n        _collisionExtents = Vector3.Scale(boxCollider.size / 2, transform.lossyScale); \\n        _xrGrabInteractable = GetComponent<XRGrabInteractable>();\\n        _ownedPhysicsBricksStore = OwnedPhysicsBricksStore.GetInstance();\\n        _colliderOffset = boxCollider.center;\\n        foreach(BoxCollider c in colliders)\\n            if (c.gameObject == gameObject)\\n                _usingBuiltInColliders = true;\\n    }\\n\\n    private void Start()\\n    {\\n        _transform = transform;\\n        _hapticsManager = HapticsManager.GetInstance();\\n    }\\n\\n    private void OnEnable()\\n    {\\n        GetComponent<XRBaseInteractable>().onSelectEnter.AddListener(BrickGrabbed);\\n        GetComponent<XRBaseInteractable>().onSelectExit.AddListener(BrickReleased);\\n    }\\n\\n    private void OnDisable()\\n    {\\n        GetComponent<XRBaseInteractable>()?.onSelectEnter.RemoveListener(BrickGrabbed);\\n        GetComponent<XRBaseInteractable>().onSelectExit.RemoveListener(BrickReleased);\\n    }\\n\\n    private void BrickGrabbed(XRBaseInteractor interactor)\\n    {\\n        if (skipGrabCallbacks) return;\\n            \\n        foreach (Collider c in colliders)\\n        {\\n            c.isTrigger = true;\\n        }\\n\\n        GetComponent<Rigidbody>().isKinematic = false;\\n\\n        isBeingHeld = true;\\n        isAttached = false;\\n\\n        GetComponent<ShowSnappableBrickPositions>().enabled = true;\\n        _ownedPhysicsBricksStore.AddBrick(gameObject);\\n    }\\n\\n    private void BrickReleased(XRBaseInteractor interactor)\\n    {\\n        if (skipGrabCallbacks) return;\\n        if (!isBeingHeld) return;\\n\\n        isBeingHeld = false;\\n\\n        (bool canConnect, Vector3 newPos, Quaternion newRot, Vector3 connectionDirection) = CheckIfCanConnect();\\n        if (canConnect) {\\n            try {\\n                if (GetComponent<BrickAttach>().ConnectBricks(newPos, newRot, connectionDirection)) {\\n                    bool leftHand = interactor.transform.parent.gameObject.name == \\\"LeftHand\\\";\\n                    _hapticsManager.PlayHaptics(0.5f, 0.5f, 0.1f, !leftHand, leftHand);\\n                }\\n            } catch (Exception e) {\\n                Debug.Log(\\\"SOMETHING EXPLODED!\\\");\\n                Debug.Log(e.Message);\\n                Debug.Log(e.StackTrace);\\n\\n\\n                Session session = SessionManager.GetInstance().session;\\n                Debug.Log(session.CanPlace);\\n                Debug.Log(session.GetSessionType());\\n\\n                EnableGravityIfUnowned();\\n            }\\n        } else {\\n            \\n            EnableGravityIfUnowned();\\n        }\\n\\n        XRGrabInteractable ourInteractable = GetComponent<XRGrabInteractable>();\\n\\n        GetComponent<XRGrabInteractable>().interactionManager.ForceHoverExit(interactor, ourInteractable);\\n\\n        foreach (Collider c in colliders) {\\n            c.enabled = true;\\n            c.isTrigger = false;\\n        }\\n\\n        GetComponent<ShowSnappableBrickPositions>().ResetAndDisable();\\n    }\\n\\n    private void EnableGravityIfUnowned()\\n    {\\n        Wait.ForFrames(2, () =>\\n        {\\n            if (!this) return;\\n            if (_xrGrabInteractable.isSelected) return;\\n\\n            Rigidbody rb = GetComponent<Rigidbody>();\\n            rb.isKinematic = false;\\n            rb.useGravity = true;\\n        });\\n    }\\n\\n    private readonly (bool, Vector3, Quaternion, Vector3) _nullResponse = (false, Vector3.zero, Quaternion.identity, Vector3.zero);\\n    \\n    public (bool canConnect, Vector3 pos, Quaternion rot, Vector3 connectionDirection) CheckIfCanConnect()\\n    {\\n        if (!SessionManager.GetInstance().session.CanPlace)\\n            return _nullResponse;\\n\\n        GameObject[] femaleConnectorsWithConnections = GetFemaleConnectorsWithConnections();\\n        GameObject[] maleConnectorsWithConnections = GetMaleConnectorsWithConnections();\\n\\n        GameObject[] validFemaleConnectors = ValidConnections(femaleConnectorsWithConnections);\\n        GameObject[] validMaleConnectors = ValidConnections(maleConnectorsWithConnections);\\n\\n        GameObject[] connectorsToUse = validFemaleConnectors.Length > validMaleConnectors.Length\\n            ? validFemaleConnectors\\n            : validMaleConnectors;\\n\\n        bool connectingDownwards = connectorsToUse == validFemaleConnectors;\\n\\n        if (connectorsToUse.Length > 0)\\n        {\\n            Transform otherBrickTransform = ClosestConnectorFromConnector(connectorsToUse[0]).transform.parent.transform.parent;\\n            GameObject otherBrick = otherBrickTransform.gameObject; \\n            Vector3 otherBrickOriginalRot = otherBrick.transform.rotation.eulerAngles;\\n\\n            if (!IsVectorApproximatelyOne(otherBrickTransform.lossyScale))\\n            {\\n                \\n                return _nullResponse;\\n            }\\n\\n            \\n            \\n\\n            Vector3 brickCurrentPos = _transform.position;\\n            Quaternion brickCurrentRot = _transform.rotation;\\n\\n            _transform.parent = otherBrick.transform;\\n            Vector3 oldEulerAngles = otherBrick.transform.rotation.eulerAngles;\\n\\n            GameObject otherBrickConnector = ClosestConnectorFromConnector(connectorsToUse[0]);\\n            Transform otherConnectorTransform = otherBrickConnector.transform;\\n\\n            otherBrick.transform.eulerAngles += new Vector3(-oldEulerAngles.x - otherConnectorTransform.localEulerAngles.x, 0, -oldEulerAngles.z - otherConnectorTransform.localEulerAngles.z);\\n\\n            Quaternion rot = GetNewRot(otherBrickConnector);\\n            Vector3 pos = GetNewPosWithRot(rot, otherBrick, connectorsToUse, connectingDownwards);\\n\\n            _transform.position = pos;\\n            _transform.rotation = rot;\\n\\n            otherBrick.transform.eulerAngles = otherBrickOriginalRot;\\n\\n            Quaternion adjustedRot = _transform.rotation;\\n            Vector3 adjustedPos = _transform.position;\\n\\n            bool collidesWithBricks = CollidesWithBricks(adjustedRot, adjustedPos);\\n\\n            _transform.position = brickCurrentPos;\\n            _transform.rotation = brickCurrentRot;\\n\\n            _transform.parent = null;\\n\\n            if (collidesWithBricks)\\n            {\\n                return _nullResponse;\\n            }\\n\\n            \\n            adjustedRot *= Quaternion.Euler(0, 180f, 0);\\n\\n            return (true, adjustedPos, adjustedRot, connectingDownwards ? Vector3.down : Vector3.up);\\n        }\\n\\n        return _nullResponse;\\n    }\\n\\n    private void OnDrawGizmos()\\n    {\\n        foreach (BoxCollider c in colliders)\\n        {\\n            Gizmos.DrawWireCube(_transform.position - (_transform.position - _transform.TransformPoint(c.center)),\\n                Vector3.Scale(c.size, c.transform.lossyScale));\\n        }\\n    }\\n\\n    //Removed the testObjects list because it was never accessed\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}},{\"finish_reason\":\"stop\",\"index\":2,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing UnityEngine.XR.Interaction.Toolkit;\\nusing System.Collections.Generic;\\nusing UnityEngine.Serialization;\\nusing UnityEngine;\\nusing System.Linq;\\nusing System;\\n\\npublic class BrickAttachDetector : MonoBehaviour\\n{\\n    [FormerlySerializedAs(\\\"_isBeingHeld\\\")] public bool isBeingHeld = false;\\n    [FormerlySerializedAs(\\\"_isAttached\\\")] public bool isAttached = false;\\n\\n    public GameObject maleConnectorParent;\\n    public GameObject femaleConnectorParent;\\n\\n    public List<GameObject> _maleConnectors;\\n    public List<GameObject> _femaleConnectors;\\n\\n    public GameObject model;\\n\\n    private Vector3 _collisionExtents;\\n    private Vector3 _colliderOffset;\\n\\n    private Transform _transform;\\n\\n    private HapticsManager _hapticsManager;\\n\\n    private XRGrabInteractable _xrGrabInteractable;\\n    private OwnedPhysicsBricksStore _ownedPhysicsBricksStore;\\n\\n    public bool skipGrabCallbacks;\\n\\n    public bool tile;\\n    public bool window;\\n\\n    public BoxCollider[] colliders;\\n    private bool _usingBuiltInColliders;\\n\\n    public float heightOverride;\\n\\n    private void Awake()\\n    {\\n        \\n        \\n        BoxCollider boxCollider = GetComponent<BoxCollider>();\\n        _collisionExtents = Vector3.Scale(boxCollider.size / 2, transform.lossyScale); \\n        _xrGrabInteractable = GetComponent<XRGrabInteractable>();\\n        _ownedPhysicsBricksStore = OwnedPhysicsBricksStore.GetInstance();\\n        _colliderOffset = boxCollider.center;\\n        foreach(BoxCollider c in colliders)\\n            if (c.gameObject == gameObject)\\n                _usingBuiltInColliders = true;\\n    }\\n\\n    private void Start()\\n    {\\n        _transform = transform;\\n        _hapticsManager = HapticsManager.GetInstance();\\n    }\\n\\n    private void OnEnable()\\n    {\\n        GetComponent<XRBaseInteractable>().onSelectEnter.AddListener(BrickGrabbed);\\n        GetComponent<XRBaseInteractable>().onSelectExit.AddListener(BrickReleased);\\n    }\\n\\n    private void OnDisable()\\n    {\\n        GetComponent<XRBaseInteractable>()?.onSelectEnter.RemoveListener(BrickGrabbed);\\n        GetComponent<XRBaseInteractable>().onSelectExit.RemoveListener(BrickReleased);\\n    }\\n\\n    private void BrickGrabbed(XRBaseInteractor interactor)\\n    {\\n        if (skipGrabCallbacks) return;\\n            \\n        foreach (Collider c in colliders)\\n        {\\n            c.isTrigger = true;\\n        }\\n\\n        GetComponent<Rigidbody>().isKinematic = false;\\n\\n        isBeingHeld = true;\\n        isAttached = false;\\n\\n        GetComponent<ShowSnappableBrickPositions>().enabled = true;\\n        _ownedPhysicsBricksStore.AddBrick(gameObject);\\n    }\\n\\n    private void BrickReleased(XRBaseInteractor interactor)\\n    {\\n        if (skipGrabCallbacks) return;\\n        if (!isBeingHeld) return;\\n\\n        isBeingHeld = false;\\n\\n        (bool canConnect, Vector3 newPos, Quaternion newRot, Vector3 connectionDirection) = CheckIfCanConnect();\\n        if (canConnect) {\\n            try {\\n                if (GetComponent<BrickAttach>().ConnectBricks(newPos, newRot, connectionDirection)) {\\n                    bool leftHand = interactor.transform.parent.gameObject.name == \\\"LeftHand\\\";\\n                    _hapticsManager.PlayHaptics(0.5f, 0.5f, 0.1f, !leftHand, leftHand);\\n                }\\n            } catch (Exception e) {\\n                Debug.Log(\\\"SOMETHING EXPLODED!\\\");\\n                Debug.Log(e.Message);\\n                Debug.Log(e.StackTrace);\\n\\n\\n                Session session = SessionManager.GetInstance().session;\\n                Debug.Log(session.CanPlace);\\n                Debug.Log(session.GetSessionType());\\n\\n                EnableGravityIfUnowned();\\n            }\\n        } else {\\n            \\n            EnableGravityIfUnowned();\\n        }\\n\\n        XRGrabInteractable ourInteractable = GetComponent<XRGrabInteractable>();\\n\\n        GetComponent<XRGrabInteractable>().interactionManager.ForceHoverExit(interactor, ourInteractable);\\n\\n        foreach (Collider c in colliders) {\\n            c.enabled = true;\\n            c.isTrigger = false;\\n        }\\n\\n        GetComponent<ShowSnappableBrickPositions>().ResetAndDisable();\\n    }\\n\\n    private void EnableGravityIfUnowned()\\n    {\\n        Wait.ForFrames(2, () =>\\n        {\\n            if (!this) return;\\n            if (_xrGrabInteractable.isSelected) return;\\n\\n            Rigidbody rb = GetComponent<Rigidbody>();\\n            rb.isKinematic = false;\\n            rb.useGravity = true;\\n        });\\n    }\\n\\n    private readonly (bool, Vector3, Quaternion, Vector3) _nullResponse = (false, Vector3.zero, Quaternion.identity, Vector3.zero);\\n    \\n    public (bool canConnect, Vector3 pos, Quaternion rot, Vector3 connectionDirection) CheckIfCanConnect()\\n    {\\n        if (!SessionManager.GetInstance().session.CanPlace)\\n            return _nullResponse;\\n\\n        GameObject[] femaleConnectorsWithConnections = GetFemaleConnectorsWithConnections();\\n        GameObject[] maleConnectorsWithConnections = GetMaleConnectorsWithConnections();\\n\\n        GameObject[] validFemaleConnectors = ValidConnections(femaleConnectorsWithConnections);\\n        GameObject[] validMaleConnectors = ValidConnections(maleConnectorsWithConnections);\\n\\n        GameObject[] connectorsToUse = validFemaleConnectors.Length > validMaleConnectors.Length\\n            ? validFemaleConnectors\\n            : validMaleConnectors;\\n\\n        bool connectingDownwards = connectorsToUse == validFemaleConnectors;\\n\\n        if (connectorsToUse.Length > 0)\\n        {\\n            Transform otherBrickTransform = ClosestConnectorFromConnector(connectorsToUse[0]).transform.parent.transform.parent;\\n            GameObject otherBrick = otherBrickTransform.gameObject; \\n            Vector3 otherBrickOriginalRot = otherBrick.transform.rotation.eulerAngles;\\n\\n            if (!IsVectorApproximatelyOne(otherBrickTransform.lossyScale))\\n            {\\n                \\n                return _nullResponse;\\n            }\\n\\n            \\n            \\n\\n            Vector3 brickCurrentPos = _transform.position;\\n            Quaternion brickCurrentRot = _transform.rotation;\\n\\n            _transform.parent = otherBrick.transform;\\n            Vector3 oldEulerAngles = otherBrick.transform.rotation.eulerAngles;\\n\\n            GameObject otherBrickConnector = ClosestConnectorFromConnector(connectorsToUse[0]);\\n            Transform otherConnectorTransform = otherBrickConnector.transform;\\n\\n            otherBrick.transform.eulerAngles += new Vector3(-oldEulerAngles.x - otherConnectorTransform.localEulerAngles.x, 0, -oldEulerAngles.z - otherConnectorTransform.localEulerAngles.z);\\n\\n            Quaternion rot = GetNewRot(otherBrickConnector);\\n            Vector3 pos = GetNewPosWithRot(rot, otherBrick, connectorsToUse, connectingDownwards);\\n\\n            _transform.position = pos;\\n            _transform.rotation = rot;\\n\\n            otherBrick.transform.eulerAngles = otherBrickOriginalRot;\\n\\n            Quaternion adjustedRot = _transform.rotation;\\n            Vector3 adjustedPos = _transform.position;\\n\\n            bool collidesWithBricks = CollidesWithBricks(adjustedRot, adjustedPos);\\n\\n            _transform.position = brickCurrentPos;\\n            _transform.rotation = brickCurrentRot;\\n\\n            _transform.parent = null;\\n\\n            if (collidesWithBricks)\\n            {\\n                return _nullResponse;\\n            }\\n\\n            \\n            adjustedRot *= Quaternion.Euler(0, 180f, 0);\\n\\n            return (true, adjustedPos, adjustedRot, connectingDownwards ? Vector3.down : Vector3.up);\\n        }\\n\\n        return _nullResponse;\\n    }\\n\\n    private void OnDrawGizmos()\\n    {\\n        foreach (BoxCollider c in colliders)\\n        {\\n            Gizmos.DrawWireCube(_transform.position - (_transform.position - _transform.TransformPoint(c.center)),\\n                Vector3.Scale(c.size, c.transform.lossyScale));\\n        }\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}},{\"finish_reason\":\"stop\",\"index\":3,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing UnityEngine.XR.Interaction.Toolkit;\\nusing System.Collections.Generic;\\nusing UnityEngine.Serialization;\\nusing UnityEngine;\\nusing System.Linq;\\nusing System;\\n\\npublic class BrickAttachDetector : MonoBehaviour\\n{\\n    [FormerlySerializedAs(\\\"_isBeingHeld\\\")] public bool isBeingHeld = false;\\n    [FormerlySerializedAs(\\\"_isAttached\\\")] public bool isAttached = false;\\n\\n    public GameObject maleConnectorParent;\\n    public GameObject femaleConnectorParent;\\n\\n    public List<GameObject> _maleConnectors;\\n    public List<GameObject> _femaleConnectors;\\n\\n    public GameObject model;\\n\\n    private Vector3 _collisionExtents;\\n    private Vector3 _colliderOffset;\\n\\n    private Transform _transform;\\n\\n    private HapticsManager _hapticsManager;\\n\\n    private XRGrabInteractable _xrGrabInteractable;\\n    private OwnedPhysicsBricksStore _ownedPhysicsBricksStore;\\n\\n    public bool skipGrabCallbacks;\\n\\n    public bool tile;\\n    public bool window;\\n\\n    public BoxCollider[] colliders;\\n    private bool _usingBuiltInColliders;\\n\\n    public float heightOverride;\\n\\n    private void Awake()\\n    {\\n        BoxCollider boxCollider = GetComponent<BoxCollider>();\\n        _collisionExtents = Vector3.Scale(boxCollider.size / 2, transform.lossyScale);\\n        _xrGrabInteractable = GetComponent<XRGrabInteractable>();\\n        _ownedPhysicsBricksStore = OwnedPhysicsBricksStore.GetInstance();\\n        _colliderOffset = boxCollider.center;\\n        foreach(BoxCollider c in colliders)\\n            if (c.gameObject == gameObject)\\n                _usingBuiltInColliders = true;\\n    }\\n\\n    private void Start()\\n    {\\n        _transform = transform;\\n        _hapticsManager = HapticsManager.GetInstance();\\n    }\\n\\n    private void OnEnable()\\n    {\\n        GetComponent<XRBaseInteractable>().onSelectEnter.AddListener(BrickGrabbed);\\n        GetComponent<XRBaseInteractable>().onSelectExit.AddListener(BrickReleased);\\n    }\\n\\n    private void OnDisable()\\n    {\\n        GetComponent<XRBaseInteractable>()?.onSelectEnter.RemoveListener(BrickGrabbed);\\n        GetComponent<XRBaseInteractable>().onSelectExit.RemoveListener(BrickReleased);\\n    }\\n\\n    private void BrickGrabbed(XRBaseInteractor interactor)\\n    {\\n        if (skipGrabCallbacks) return;\\n        \\n        foreach (Collider c in colliders)\\n        {\\n            c.isTrigger = true;\\n        }\\n\\n        GetComponent<Rigidbody>().isKinematic = false;\\n\\n        isBeingHeld = true;\\n        isAttached = false;\\n\\n        GetComponent<ShowSnappableBrickPositions>().enabled = true;\\n        _ownedPhysicsBricksStore.AddBrick(gameObject);\\n    }\\n\\n    private void BrickReleased(XRBaseInteractor interactor)\\n    {\\n        if (skipGrabCallbacks) return;\\n        if (!isBeingHeld) return;\\n\\n        isBeingHeld = false;\\n\\n        (bool canConnect, Vector3 newPos, Quaternion newRot, Vector3 connectionDirection) = CheckIfCanConnect();\\n        if (canConnect)\\n        {\\n            try\\n            {\\n                if (GetComponent<BrickAttach>().ConnectBricks(newPos, newRot, connectionDirection))\\n                {\\n                    bool leftHand = interactor.transform.parent.gameObject.name == \\\"LeftHand\\\";\\n                    _hapticsManager.PlayHaptics(0.5f, 0.5f, 0.1f, !leftHand, leftHand);\\n                }\\n            }\\n            catch (Exception e)\\n            {\\n                Debug.Log(\\\"SOMETHING EXPLODED!\\\");\\n                Debug.Log(e.Message);\\n                Debug.Log(e.StackTrace);\\n\\n                Session session = SessionManager.GetInstance().session;\\n                Debug.Log(session.CanPlace);\\n                Debug.Log(session.GetSessionType());\\n\\n                EnableGravityIfUnowned();\\n            }\\n        }\\n        else\\n        {\\n            EnableGravityIfUnowned();\\n        }\\n\\n        XRGrabInteractable ourInteractable = GetComponent<XRGrabInteractable>();\\n\\n        GetComponent<XRGrabInteractable>().interactionManager.ForceHoverExit(interactor, ourInteractable);\\n\\n        foreach (Collider c in colliders)\\n        {\\n            c.enabled = true;\\n            c.isTrigger = false;\\n        }\\n\\n        GetComponent<ShowSnappableBrickPositions>().ResetAndDisable();\\n    }\\n\\n    private void EnableGravityIfUnowned()\\n    {\\n        Wait.ForFrames(2, () =>\\n        {\\n            if (!this) return;\\n            if (_xrGrabInteractable.isSelected) return;\\n\\n            Rigidbody rb = GetComponent<Rigidbody>();\\n            rb.isKinematic = false;\\n            rb.useGravity = true;\\n        });\\n    }\\n\\n    private readonly (bool, Vector3, Quaternion, Vector3) _nullResponse = (false, Vector3.zero, Quaternion.identity, Vector3.zero);\\n\\n    public (bool canConnect, Vector3 pos, Quaternion rot, Vector3 connectionDirection) CheckIfCanConnect()\\n    {\\n        if (!SessionManager.GetInstance().session.CanPlace)\\n            return _nullResponse;\\n\\n        GameObject[] femaleConnectorsWithConnections = GetFemaleConnectorsWithConnections();\\n        GameObject[] maleConnectorsWithConnections = GetMaleConnectorsWithConnections();\\n\\n        GameObject[] validFemaleConnectors = ValidConnections(femaleConnectorsWithConnections);\\n        GameObject[] validMaleConnectors = ValidConnections(maleConnectorsWithConnections);\\n\\n        GameObject[] connectorsToUse = validFemaleConnectors.Length > validMaleConnectors.Length\\n            ? validFemaleConnectors\\n            : validMaleConnectors;\\n\\n        bool connectingDownwards = connectorsToUse == validFemaleConnectors;\\n\\n        if (connectorsToUse.Length > 0)\\n        {\\n            Transform otherBrickTransform = ClosestConnectorFromConnector(connectorsToUse[0]).transform.parent.transform.parent;\\n            GameObject otherBrick = otherBrickTransform.gameObject;\\n            Vector3 otherBrickOriginalRot = otherBrick.transform.rotation.eulerAngles;\\n\\n            if (!IsVectorApproximatelyOne(otherBrickTransform.lossyScale))\\n            {\\n                return _nullResponse;\\n            }\\n\\n            Vector3 brickCurrentPos = _transform.position;\\n            Quaternion brickCurrentRot = _transform.rotation;\\n\\n            _transform.parent = otherBrick.transform;\\n            Vector3 oldEulerAngles = otherBrick.transform.rotation.eulerAngles;\\n\\n            GameObject otherBrickConnector = ClosestConnectorFromConnector(connectorsToUse[0]);\\n            Transform otherConnectorTransform = otherBrickConnector.transform;\\n\\n            otherBrick.transform.eulerAngles += new Vector3(-oldEulerAngles.x - otherConnectorTransform.localEulerAngles.x, 0, -oldEulerAngles.z - otherConnectorTransform.localEulerAngles.z);\\n\\n            Quaternion rot = GetNewRot(otherBrickConnector);\\n            Vector3 pos = GetNewPosWithRot(rot, otherBrick, connectorsToUse, connectingDownwards);\\n\\n            _transform.position = pos;\\n            _transform.rotation = rot;\\n\\n            otherBrick.transform.eulerAngles = otherBrickOriginalRot;\\n\\n            Quaternion adjustedRot = _transform.rotation;\\n            Vector3 adjustedPos = _transform.position;\\n\\n            bool collidesWithBricks = CollidesWithBricks(adjustedRot, adjustedPos);\\n\\n            _transform.position = brickCurrentPos;\\n            _transform.rotation = brickCurrentRot;\\n\\n            _transform.parent = null;\\n\\n            if (collidesWithBricks)\\n            {\\n                return _nullResponse;\\n            }\\n\\n            adjustedRot *= Quaternion.Euler(0, 180f, 0);\\n\\n            return (true, adjustedPos, adjustedRot, connectingDownwards ? Vector3.down : Vector3.up);\\n        }\\n\\n        return _nullResponse;\\n    }\\n\\n    private void OnDrawGizmos()\\n    {\\n        foreach (BoxCollider c in colliders)\\n        {\\n            Gizmos.DrawWireCube(_transform.position - (_transform.position - _transform.TransformPoint(c.center)),\\n                Vector3.Scale(c.size, c.transform.lossyScale));\\n        }\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}},{\"finish_reason\":\"stop\",\"index\":4,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing UnityEngine.XR.Interaction.Toolkit;\\nusing System.Collections.Generic;\\nusing UnityEngine.Serialization;\\nusing UnityEngine;\\nusing System.Linq;\\nusing System;\\n\\npublic class BrickAttachDetector : MonoBehaviour\\n{\\n    [FormerlySerializedAs(\\\"_isBeingHeld\\\")] public bool isBeingHeld = false;\\n    [FormerlySerializedAs(\\\"_isAttached\\\")] public bool isAttached = false;\\n\\n    public GameObject maleConnectorParent;\\n    public GameObject femaleConnectorParent;\\n\\n    public List<GameObject> _maleConnectors;\\n    public List<GameObject> _femaleConnectors;\\n\\n    public GameObject model;\\n\\n    private Vector3 _collisionExtents;\\n    private Vector3 _colliderOffset;\\n\\n    private Transform _transform;\\n\\n    private HapticsManager _hapticsManager;\\n\\n    private XRGrabInteractable _xrGrabInteractable;\\n    private OwnedPhysicsBricksStore _ownedPhysicsBricksStore;\\n\\n    public bool skipGrabCallbacks;\\n\\n    public bool tile;\\n    public bool window;\\n\\n    public BoxCollider[] colliders;\\n    private bool _usingBuiltInColliders;\\n\\n    public float heightOverride;\\n\\n    private void Awake()\\n    {\\n        \\n        \\n        BoxCollider boxCollider = GetComponent<BoxCollider>();\\n        _collisionExtents = Vector3.Scale(boxCollider.size / 2, transform.lossyScale); \\n        _xrGrabInteractable = GetComponent<XRGrabInteractable>();\\n        _ownedPhysicsBricksStore = OwnedPhysicsBricksStore.GetInstance();\\n        _colliderOffset = boxCollider.center;\\n        foreach(BoxCollider c in colliders)\\n            if (c.gameObject == gameObject)\\n                _usingBuiltInColliders = true;\\n    }\\n\\n    private void Start()\\n    {\\n        _transform = transform;\\n        _hapticsManager = HapticsManager.GetInstance();\\n    }\\n\\n    private void OnEnable()\\n    {\\n        GetComponent<XRBaseInteractable>().onSelectEnter.AddListener(BrickGrabbed);\\n        GetComponent<XRBaseInteractable>().onSelectExit.AddListener(BrickReleased);\\n    }\\n\\n    private void OnDisable()\\n    {\\n        GetComponent<XRBaseInteractable>()?.onSelectEnter.RemoveListener(BrickGrabbed);\\n        GetComponent<XRBaseInteractable>().onSelectExit.RemoveListener(BrickReleased);\\n    }\\n\\n    private void BrickGrabbed(XRBaseInteractor interactor)\\n    {\\n        if (skipGrabCallbacks) return;\\n            \\n        foreach (Collider c in colliders)\\n        {\\n            c.isTrigger = true;\\n        }\\n\\n        GetComponent<Rigidbody>().isKinematic = false;\\n\\n        isBeingHeld = true;\\n        isAttached = false;\\n\\n        GetComponent<ShowSnappableBrickPositions>().enabled = true;\\n        _ownedPhysicsBricksStore.AddBrick(gameObject);\\n    }\\n\\n    private void BrickReleased(XRBaseInteractor interactor)\\n    {\\n        if (skipGrabCallbacks) return;\\n        if (!isBeingHeld) return;\\n\\n        isBeingHeld = false;\\n\\n        (bool canConnect, Vector3 newPos, Quaternion newRot, Vector3 connectionDirection) = CheckIfCanConnect();\\n        if (canConnect) {\\n            try {\\n                if (GetComponent<BrickAttach>().ConnectBricks(newPos, newRot, connectionDirection)) {\\n                    bool leftHand = interactor.transform.parent.gameObject.name == \\\"LeftHand\\\";\\n                    _hapticsManager.PlayHaptics(0.5f, 0.5f, 0.1f, !leftHand, leftHand);\\n                }\\n            } catch (Exception e) {\\n                Debug.Log(\\\"SOMETHING EXPLODED!\\\");\\n                Debug.Log(e.Message);\\n                Debug.Log(e.StackTrace);\\n\\n\\n                Session session = SessionManager.GetInstance().session;\\n                Debug.Log(session.CanPlace);\\n                Debug.Log(session.GetSessionType());\\n\\n                EnableGravityIfUnowned();\\n            }\\n        } else {\\n            \\n            EnableGravityIfUnowned();\\n        }\\n\\n        XRGrabInteractable ourInteractable = GetComponent<XRGrabInteractable>();\\n\\n        GetComponent<XRGrabInteractable>().interactionManager.ForceHoverExit(interactor, ourInteractable);\\n\\n        foreach (Collider c in colliders) {\\n            c.enabled = true;\\n            c.isTrigger = false;\\n        }\\n\\n        GetComponent<ShowSnappableBrickPositions>().ResetAndDisable();\\n    }\\n\\n    private void EnableGravityIfUnowned()\\n    {\\n        Wait.ForFrames(2, () =>\\n        {\\n            if (!this) return;\\n            if (_xrGrabInteractable.isSelected) return;\\n\\n            Rigidbody rb = GetComponent<Rigidbody>();\\n            rb.isKinematic = false;\\n            rb.useGravity = true;\\n        });\\n    }\\n\\n    private readonly (bool, Vector3, Quaternion, Vector3) _nullResponse = (false, Vector3.zero, Quaternion.identity, Vector3.zero);\\n    \\n    public (bool canConnect, Vector3 pos, Quaternion rot, Vector3 connectionDirection) CheckIfCanConnect()\\n    {\\n        if (!SessionManager.GetInstance().session.CanPlace)\\n            return _nullResponse;\\n\\n        GameObject[] femaleConnectorsWithConnections = GetFemaleConnectorsWithConnections();\\n        GameObject[] maleConnectorsWithConnections = GetMaleConnectorsWithConnections();\\n\\n        GameObject[] validFemaleConnectors = ValidConnections(femaleConnectorsWithConnections);\\n        GameObject[] validMaleConnectors = ValidConnections(maleConnectorsWithConnections);\\n\\n        GameObject[] connectorsToUse = validFemaleConnectors.Length > validMaleConnectors.Length\\n            ? validFemaleConnectors\\n            : validMaleConnectors;\\n\\n        bool connectingDownwards = connectorsToUse == validFemaleConnectors;\\n\\n        if (connectorsToUse.Length > 0)\\n        {\\n            Transform otherBrickTransform = ClosestConnectorFromConnector(connectorsToUse[0]).transform.parent.transform.parent;\\n            GameObject otherBrick = otherBrickTransform.gameObject; \\n            Vector3 otherBrickOriginalRot = otherBrick.transform.rotation.eulerAngles;\\n\\n            if (!IsVectorApproximatelyOne(otherBrickTransform.lossyScale))\\n            {\\n                \\n                return _nullResponse;\\n            }\\n\\n            \\n            \\n\\n            Vector3 brickCurrentPos = _transform.position;\\n            Quaternion brickCurrentRot = _transform.rotation;\\n\\n            _transform.parent = otherBrick.transform;\\n            Vector3 oldEulerAngles = otherBrick.transform.rotation.eulerAngles;\\n\\n            GameObject otherBrickConnector = ClosestConnectorFromConnector(connectorsToUse[0]);\\n            Transform otherConnectorTransform = otherBrickConnector.transform;\\n\\n            otherBrick.transform.eulerAngles += new Vector3(-oldEulerAngles.x - otherConnectorTransform.localEulerAngles.x, 0, -oldEulerAngles.z - otherConnectorTransform.localEulerAngles.z);\\n\\n            Quaternion rot = GetNewRot(otherBrickConnector);\\n            Vector3 pos = GetNewPosWithRot(rot, otherBrick, connectorsToUse, connectingDownwards);\\n\\n            _transform.position = pos;\\n            _transform.rotation = rot;\\n\\n            otherBrick.transform.eulerAngles = otherBrickOriginalRot;\\n\\n            Quaternion adjustedRot = _transform.rotation;\\n            Vector3 adjustedPos = _transform.position;\\n\\n            bool collidesWithBricks = CollidesWithBricks(adjustedRot, adjustedPos);\\n\\n            _transform.position = brickCurrentPos;\\n            _transform.rotation = brickCurrentRot;\\n\\n            _transform.parent = null;\\n\\n            if (collidesWithBricks)\\n            {\\n                return _nullResponse;\\n            }\\n\\n            \\n            adjustedRot *= Quaternion.Euler(0, 180f, 0);\\n\\n            return (true, adjustedPos, adjustedRot, connectingDownwards ? Vector3.down : Vector3.up);\\n        }\\n\\n        return _nullResponse;\\n    }\\n\\n    private void OnDrawGizmos()\\n    {\\n        foreach (BoxCollider c in colliders)\\n        {\\n            Gizmos.DrawWireCube(_transform.position - (_transform.position - _transform.TransformPoint(c.center)),\\n                Vector3.Scale(c.size, c.transform.lossyScale));\\n        }\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}}],\"created\":1751903422,\"model\":\"gpt-4o-2024-08-06\",\"object\":\"chat.completion\",\"service_tier\":\"default\",\"system_fingerprint\":\"fp_07871e2ad8\",\"usage\":{\"completion_tokens\":8035,\"prompt_tokens\":1723,\"total_tokens\":9758,\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":0,\"rejected_prediction_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0}}}"