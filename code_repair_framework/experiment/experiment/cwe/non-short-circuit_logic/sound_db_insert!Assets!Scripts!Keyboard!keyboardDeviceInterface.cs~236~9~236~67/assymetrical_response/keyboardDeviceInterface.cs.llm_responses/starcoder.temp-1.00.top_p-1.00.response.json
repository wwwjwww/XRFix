{
    "code_repairing_0": "```\n\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class keyboardDeviceInterface : deviceInterface {\n    public timelineComponentInterface _timeline;\n    public midiComponentInterface _midiIn, _midiOut;\n    public GameObject whiteKeyPrefab, blackKeyPrefab;\n    public omniJack output, freqoutput, ampoutput;\n    public button muteButton, midiInButton, midiOutButton, sequenceButton;\n\n    public midiOutOfRange midiLow, midiHigh;\n\n    public speaker _speaker;\n    int keyCount = 25;\n    key[] keys;\n\n    adsrInterface _adsrInterface;\n    basicSwitch octaveToggle;\n\n    keyFrequencySignalGenerator freqSignal;\n    adsrSignalGenerator adsrSignal;\n    int curKey;\n\n    keyState[] keyStates = new keyState[25];\n\n    public override void Awake() {\n        base.Awake();\n\n        curKey = -1;\n\n        _adsrInterface = GetComponentInChildren<adsrInterface>();\n        octaveToggle = GetComponentInChildren<basicSwitch>();\n\n        freqSignal = GetComponent<keyFrequencySignalGenerator>();\n        adsrSignal = GetComponent<adsrSignalGenerator>();\n\n        freqoutput.homesignal = freqSignal;\n        ampoutput.homesignal = adsrSignal;\n\n        keys = new key[keyCount];\n        adsrSignal.durations = _adsrInterface.durations;\n        adsrSignal.volumes = _adsrInterface.volumes;\n        SpawnKeys();\n\n        for (int i = 0; i < 25; i++) keyStates[i] = new keyState(false);\n    }\n\n    void SpawnKeys() {\n        float separation =.05f;\n        int whiteCount = 0;\n        for (int i = 0; i < keyCount; i++) {\n            GameObject g;\n            if (i % 12 == 1 || i % 12 == 3 || i % 12 == 6 || i % 12 == 8 || i % 12 == 10) {\n                g = Instantiate(blackKeyPrefab, transform, false) as GameObject;\n                g.transform.localPosition = new Vector3(-separation * whiteCount + separation / 2 +.15f,.03f, -.025f);\n            } else {\n                g = Instantiate(whiteKeyPrefab, transform, false) as GameObject;\n                g.transform.localPosition = new Vector3(-separation * whiteCount +.15f, -.007f,.005f);\n                whiteCount++;\n            }\n            keys[i] = g.GetComponent<key>();\n            keys[i].keyValue = i;\n            keys[i].isKeyboard = true;\n            keys[i].sticky = false;\n        }\n    }\n\n    bool muted = false;\n    public void toggleMute(bool on) {\n        muted = on;\n        _speaker.volume = muted? 0 : 1;\n    }\n\n    public override void onTimelineEvent(int track, bool on) {\n        asynchKeyHit(on, track, keyInput.seq);\n    }\n\n    bool midiLowDesired = false;\n    bool midiHighDesired = false;\n\n    public override void OnMidiNote(int channel, bool on, int pitch) {\n        int ID = pitch - 48;\n        if (ID < 0) {\n            if (on) midiLowDesired = true;\n        } else if (ID > 24) {\n            if (on) midiHighDesired = true;\n        } else {\n            asynchKeyHit(on, ID, keyInput.midi);\n        }\n    }\n\n    public void asynchKeyHit(bool on, int ID, keyInput k) {\n        if (k == keyInput.midi) keyStates[ID].midiState = on;\n        else if (k == keyInput.seq) keyStates[ID].seqState = on;\n        else if (k == keyInput.touch) keyStates[ID].touchState = on;\n\n        if (keyStates[ID].nonSeqStateChange()) {\n            keyStates[ID].currentNonSeqState = keyStates[ID].getNonSeqState();\n            _timeline.onTimelineEvent(ID, keyStates[ID].currentNonSeqState);\n        }\n\n        if (keyStates[ID].stateChange()) {\n            on = keyStates[ID].currentState = keyStates[ID].getState();\n            keys[ID].phantomHit(on);\n            keyHitEvent(on, ID);\n        }\n    }\n\n    void keyHitEvent(bool on, int ID) {\n        if (on) {\n            if (curKey!= ID) {\n                int prev = curKey;\n                curKey = ID;\n\n                if (prev!= -1) {\n                    adsrSignal.hit(false);\n                    if (_midiOut!= null) _midiOut.OutputNote(false, prev);\n                }\n\n                if (_midiOut!= null) _midiOut.OutputNote(on, ID);\n                freqSignal.UpdateKey(curKey);\n                adsrSignal.hit(true);\n            }\n        } else {\n            if (curKey == ID) {\n                _midiOut.OutputNote(false, ID);\n                adsrSignal.hit(false);\n                curKey = -1;\n            }\n        }\n    }\n\n    void toggleMIDIin(bool on) {\n        _midiIn.gameObject.SetActive(on);\n    }\n\n    void toggleMIDIout(bool on) {\n        _midiOut.gameObject.SetActive(on);\n    }\n\n    void toggleSequencer(bool on) {\n        _timeline.gameObject.SetActive(on);\n    }\n\n    public override void hit(bool on, int ID = -1) {\n        if (ID == -1) {\n            toggleMute(on);\n        } else if (ID == -2) {\n            toggleMIDIin(on);\n        } else if (ID == -3) {\n            toggleMIDIout(on);\n        } else if (ID == -4) {\n            toggleSequencer(on);\n        } else {\n            asynchKeyHit(on, ID, keyInput.touch);\n        }\n    }\n\n    void Update() {\n        if (octaveToggle.switchVal) freqSignal.octave = 1;\n        else freqSignal.octave = 0;\n\n        if (midiLowDesired) {\n            midiLowDesired = false;\n            midiLow.gameObject.SetActive(true);\n            midiLow.Activate();\n        }\n\n        if (midiHighDesired) {\n            midiHighDesired = false;\n            midiHigh.gameObject.SetActive(true);\n            midiHigh.Activate();\n        }\n    }\n\n    public override InstrumentData GetData() {\n        KeyboardData data = new KeyboardData();\n        data.deviceType = menuItem.deviceType.Keyboard;\n        GetTransformData(data);\n        data.muted = muted;\n        data.octaveSwitch = octaveToggle.switchVal;\n        data.ADSRdata = new Vector2[3];\n        for (int i = 0; i < 3; i++) {\n            data.ADSRdata[i] = _adsrInterface.xyHandles[i].percent;\n        }\n\n        data.jackOutID = output.transform.GetInstanceID();\n        data.freqOutID = freqoutput.transform.GetInstanceID();\n        data.ampOutID = ampoutput.transform.GetInstanceID();\n\n        data.midiInConnection = _midiIn.connectedDevice;\n        data.midiOutConnection = _midiOut.connectedDevice;\n        data.sequencerEnabled = _timeline.gameObject.activeSelf;\n\n        data.timelinePresent = true;\n        data.timelineData = _timeline.GetTimelineData();\n        data.timelineHeight = _timeline.heightHandle.transform.localPosition.y;\n        List<timelineEvent.eventData> tempevents = new List<timelineEvent.eventData>();\n        for (int i = 0; i < _timeline._tlEvents.Count; i++) {\n            if (_timeline._tlEvents[i]!= null) tempevents.Add(_timeline._tlEvents[i].getEventInfo());\n        }\n        data.timelineEvents = tempevents.ToArray();\n\n        return data;\n    }\n\n    public override void Load(InstrumentData d) {\n        KeyboardData data = d as KeyboardData;\n        base.Load(data);\n\n        output.ID = data.jackOutID;\n        freqoutput.ID = data.freqOutID;\n        ampoutput.ID = data.ampOutID;\n\n        for (int i = 0; i < 3; i++) _adsrInterface.xyHandles[i].setPercent(data.ADSRdata[i]);\n        _adsrInterface.setDefaults = false;\n\n        muteButton.startToggled = data.muted;\n        octaveToggle.setSwitch(data.octaveSwitch);\n    }\n}",
    "code_repairing_1": "```\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class keyboardDeviceInterface : deviceInterface {\n    public timelineComponentInterface _timeline;\n    public midiComponentInterface _midiIn, _midiOut;\n    public GameObject whiteKeyPrefab, blackKeyPrefab;\n    public omniJack output, freqoutput, ampoutput;\n    public button muteButton, midiInButton, midiOutButton, sequenceButton;\n\n    public midiOutOfRange midiLow, midiHigh;\n\n    public speaker _speaker;\n    int keyCount = 25;\n    key[] keys;\n\n    adsrInterface _adsrInterface;\n    basicSwitch octaveToggle;\n\n    keyFrequencySignalGenerator freqSignal;\n    adsrSignalGenerator adsrSignal;\n    int curKey;\n\n    keyState[] keyStates = new keyState[25];\n\n    public override void Awake() {\n        base.Awake();\n\n        curKey = -1;\n\n        _adsrInterface = GetComponentInChildren<adsrInterface>();\n        octaveToggle = GetComponentInChildren<basicSwitch>();\n\n        freqSignal = GetComponent<keyFrequencySignalGenerator>();\n        adsrSignal = GetComponent<adsrSignalGenerator>();\n\n        freqoutput.homesignal = freqSignal;\n        ampoutput.homesignal = adsrSignal;\n\n        keys = new key[keyCount];\n        adsrSignal.durations = _adsrInterface.durations;\n        adsrSignal.volumes = _adsrInterface.volumes;\n        SpawnKeys();\n\n        for (int i = 0; i < 25; i++) keyStates[i] = new keyState(false);\n    }\n\n    void SpawnKeys() {\n        float separation =.05f;\n        int whiteCount = 0;\n        for (int i = 0; i < keyCount; i++) {\n            GameObject g;\n            if (i % 12 == 1 || i % 12 == 3 || i % 12 == 6 || i % 12 == 8 || i % 12 == 10) {\n                g = Instantiate(blackKeyPrefab, transform, false) as GameObject;\n                g.transform.localPosition = new Vector3(-separation * whiteCount + separation / 2 +.15f,.03f, -.025f);\n            } else {\n                g = Instantiate(whiteKeyPrefab, transform, false) as GameObject;\n                g.transform.localPosition = new Vector3(-separation * whiteCount +.15f, -.007f,.005f);\n                whiteCount++;\n            }\n            keys[i] = g.GetComponent<key>();\n            keys[i].keyValue = i;\n            keys[i].isKeyboard = true;\n            keys[i].sticky = false;\n        }\n    }\n\n    bool muted = false;\n    public void toggleMute(bool on) {\n        muted = on;\n        _speaker.volume = muted? 0 : 1;\n    }\n\n    public override void onTimelineEvent(int track, bool on) {\n        asynchKeyHit(on, track, keyInput.seq);\n    }\n\n    bool midiLowDesired = false;\n    bool midiHighDesired = false;\n\n    public override void OnMidiNote(int channel, bool on, int pitch) {\n        int ID = pitch - 48;\n        if (ID < 0) {\n            if (on) midiLowDesired = true;\n        } else if (ID > 24) {\n            if (on) midiHighDesired = true;\n        } else {\n            asynchKeyHit(on, ID, keyInput.midi);\n        }\n    }\n\n    public void asynchKeyHit(bool on, int ID, keyInput k) {\n        if (k == keyInput.midi) keyStates[ID].midiState = on;\n        else if (k == keyInput.seq) keyStates[ID].seqState = on;\n        else if (k == keyInput.touch) keyStates[ID].touchState = on;\n\n        if (keyStates[ID].nonSeqStateChange()) {\n            keyStates[ID].currentNonSeqState = keyStates[ID].getNonSeqState();\n            _timeline.onTimelineEvent(ID, keyStates[ID].currentNonSeqState);\n        }\n\n        if (keyStates[ID].stateChange()) {\n            on = keyStates[ID].currentState = keyStates[ID].getState();\n            keys[ID].phantomHit(on);\n            keyHitEvent(on, ID);\n        }\n    }\n\n    void keyHitEvent(bool on, int ID) {\n        if (on) {\n            if (curKey!= ID) {\n                int prev = curKey;\n                curKey = ID;\n\n                if (prev!= -1) {\n                    adsrSignal.hit(false);\n                    if (_midiOut!= null) _midiOut.OutputNote(false, prev);\n                }\n\n                if (_midiOut!= null) _midiOut.OutputNote(on, ID);\n                freqSignal.UpdateKey(curKey);\n                adsrSignal.hit(true);\n            }\n        } else {\n            if (curKey == ID) {\n                _midiOut.OutputNote(false, ID);\n                adsrSignal.hit(false);\n                curKey = -1;\n            }\n        }\n    }\n\n    void toggleMIDIin(bool on) {\n        _midiIn.gameObject.SetActive(on);\n    }\n\n    void toggleMIDIout(bool on) {\n        _midiOut.gameObject.SetActive(on);\n    }\n\n    void toggleSequencer(bool on) {\n        _timeline.gameObject.SetActive(on);\n    }\n\n    public override void hit(bool on, int ID = -1) {\n        if (ID == -1) {\n            toggleMute(on);\n        } else if (ID == -2) {\n            toggleMIDIin(on);\n        } else if (ID == -3) {\n            toggleMIDIout(on);\n        } else if (ID == -4) {\n            toggleSequencer(on);\n        } else {\n            asynchKeyHit(on, ID, keyInput.touch);\n        }\n    }\n\n    void Update() {\n        if (octaveToggle.switchVal) freqSignal.octave = 1;\n        else freqSignal.octave = 0;\n\n        if (midiLowDesired) {\n            midiLowDesired = false;\n            midiLow.gameObject.SetActive(true);\n            midiLow.Activate();\n        }\n\n        if (midiHighDesired) {\n            midiHighDesired = false;\n            midiHigh.gameObject.SetActive(true);\n            midiHigh.Activate();\n        }\n    }\n\n    public override InstrumentData GetData() {\n        KeyboardData data = new KeyboardData();\n        data.deviceType = menuItem.deviceType.Keyboard;\n        GetTransformData(data);\n        data.muted = muted;\n        data.octaveSwitch = octaveToggle.switchVal;\n        data.ADSRdata = new Vector2[3];\n        for (int i = 0; i < 3; i++) {\n            data.ADSRdata[i] = _adsrInterface.xyHandles[i].percent;\n        }\n\n        data.jackOutID = output.transform.GetInstanceID();\n        data.freqOutID = freqoutput.transform.GetInstanceID();\n        data.ampOutID = ampoutput.transform.GetInstanceID();\n\n        data.midiInConnection = _midiIn.connectedDevice;\n        data.midiOutConnection = _midiOut.connectedDevice;\n        data.sequencerEnabled = _timeline.gameObject.activeSelf;\n\n        data.timelinePresent = true;\n        data.timelineData = _timeline.GetTimelineData();\n        data.timelineHeight = _timeline.heightHandle.transform.localPosition.y;\n        List<timelineEvent.eventData> tempevents = new List<timelineEvent.eventData>();\n        for (int i = 0; i < _timeline._tlEvents.Count; i++) {\n            if (_timeline._tlEvents[i]!= null) tempevents.Add(_timeline._tlEvents[i].getEventInfo());\n        }\n        data.timelineEvents = tempevents.ToArray();\n\n        return data;\n    }\n\n    public override void Load(InstrumentData d) {\n        KeyboardData data = d as KeyboardData;\n        base.Load(data);\n\n        output.ID = data.jackOutID;\n        freqoutput.ID = data.freqOutID;\n        ampoutput.ID = data.ampOutID;\n\n        for (int i = 0; i < 3; i++) _adsrInterface.xyHandles[i].setPercent(data.ADSRdata[i]);\n        _adsrInterface.setDefaults = false;\n\n        muteButton.startToggled = data.muted;\n        octaveToggle.setSwitch(data.octaveSwitch);\n    }\n}",
    "code_repairing_2": "Here is the fixed code for this program:\n\n``` \nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class keyboardDeviceInterface : deviceInterface {\n  public timelineComponentInterface _timeline;\n  public midiComponentInterface _midiIn, _midiOut;\n  public GameObject whiteKeyPrefab, blackKeyPrefab;\n  public omniJack output, freqoutput, ampoutput;\n  public button muteButton, midiInButton, midiOutButton, sequenceButton;\n\n  public midiOutOfRange midiLow, midiHigh;\n\n  public speaker _speaker;\n  int keyCount = 25;\n  key[] keys;\n\n  adsrInterface _adsrInterface;\n  basicSwitch octaveToggle;\n\n  keyFrequencySignalGenerator freqSignal;\n  adsrSignalGenerator adsrSignal;\n  int curKey;\n\n  keyState[] keyStates = new keyState[25];\n\n  public override void Awake() {\n    base.Awake();\n\n    curKey = -1;\n\n    _adsrInterface = GetComponentInChildren<adsrInterface>();\n    octaveToggle = GetComponentInChildren<basicSwitch>();\n\n    freqSignal = GetComponent<keyFrequencySignalGenerator>();\n    adsrSignal = GetComponent<adsrSignalGenerator>();\n\n    freqoutput.homesignal = freqSignal;\n    ampoutput.homesignal = adsrSignal;\n\n    keys = new key[keyCount];\n    adsrSignal.durations = _adsrInterface.durations;\n    adsrSignal.volumes = _adsrInterface.volumes;\n    SpawnKeys();\n\n    for (int i = 0; i < 25; i++) keyStates[i] = new keyState(false);\n  }\n\n  void SpawnKeys() {\n    float separation =.05f;\n    int whiteCount = 0;\n    for (int i = 0; i < keyCount; i++) {\n      GameObject g;\n      if (i % 12 == 1 || i % 12 == 3 || i % 12 == 6 || i % 12 == 8 || i % 12 == 10) {\n        g = Instantiate(blackKeyPrefab, transform, false) as GameObject;\n        g.transform.localPosition = new Vector3(-separation * whiteCount + separation / 2 +.15f,.03f, -.025f);\n      } else {\n        g = Instantiate(whiteKeyPrefab, transform, false) as GameObject;\n        g.transform.localPosition = new Vector3(-separation * whiteCount +.15f, -.007f,.005f);\n        whiteCount++;\n      }\n      keys[i] = g.GetComponent<key>();\n      keys[i].keyValue = i;\n      keys[i].isKeyboard = true;\n      keys[i].sticky = false;\n    }\n  }\n\n  bool muted = false;\n  public void toggleMute(bool on) {\n    muted = on;\n    _speaker.volume = muted? 0 : 1;\n  }\n\n  public override void onTimelineEvent(int track, bool on) {\n    asynchKeyHit(on, track, keyInput.seq);\n  }\n\n  bool midiLowDesired = false;\n  bool midiHighDesired = false;\n\n  public override void OnMidiNote(int channel, bool on, int pitch) {\n    int ID = pitch - 48;\n    if (ID < 0) {\n      if (on) midiLowDesired = true;\n    } else if (ID > 24) {\n      if (on) midiHighDesired = true;\n    } else {\n      asynchKeyHit(on, ID, keyInput.midi);\n    }\n  }\n\n  public void asynchKeyHit(bool on, int ID, keyInput k) {\n    if (k == keyInput.midi) keyStates[ID].midiState = on;\n    else if (k == keyInput.seq) keyStates[ID].seqState = on;\n    else if (k == keyInput.touch) keyStates[ID].touchState = on;\n\n    if (keyStates[ID].nonSeqStateChange()) {\n      keyStates[ID].currentNonSeqState = keyStates[ID].getNonSeqState();\n      _timeline.onTimelineEvent(ID, keyStates[ID].currentNonSeqState);\n    }\n\n    if (keyStates[ID].stateChange()) {\n      on = keyStates[ID].currentState = keyStates[ID].getState();\n      keys[ID].phantomHit(on);\n      keyHitEvent(on, ID);\n    }\n  }\n\n  void keyHitEvent(bool on, int ID) {\n    if (on) {\n      if (curKey!= ID) {\n        int prev = curKey;\n        curKey = ID;\n\n        if (prev!= -1) {\n          adsrSignal.hit(false);\n          if (_midiOut!= null) _midiOut.OutputNote(false, prev);\n        }\n\n        if (_midiOut!= null) _midiOut.OutputNote(on, ID);\n        freqSignal.UpdateKey(curKey);\n        adsrSignal.hit(true);\n      }\n    } else {\n      if (curKey == ID) {\n        _midiOut.OutputNote(false, ID);\n        adsrSignal.hit(false);\n        curKey = -1;\n      }\n    }\n  }\n\n  void toggleMIDIin(bool on) {\n    _midiIn.gameObject.SetActive(on);\n  }\n\n  void toggleMIDIout(bool on) {\n    _midiOut.gameObject.SetActive(on);\n  }\n\n  void toggleSequencer(bool on) {\n    _timeline.gameObject.SetActive(on);\n  }\n\n  public override void hit(bool on, int ID = -1) {\n    if (ID == -1) {\n      toggleMute(on);\n    } else if (ID == -2) {\n      toggleMIDIin(on);\n    } else if (ID == -3) {\n      toggleMIDIout(on);\n    } else if (ID == -4) {\n      toggleSequencer(on);\n    } else {\n      asynchKeyHit(on, ID, keyInput.touch);\n    }\n  }\n\n  void Update() {\n    if (octaveToggle.switchVal) freqSignal.octave = 1;\n    else freqSignal.octave = 0;\n\n    if (midiLowDesired) {\n      midiLowDesired = false;\n      midiLow.gameObject.SetActive(true);\n      midiLow.Activate();\n    }\n\n    if (midiHighDesired) {\n      midiHighDesired = false;\n      midiHigh.gameObject.SetActive(true);\n      midiHigh.Activate();\n    }\n  }\n\n  public override InstrumentData GetData() {\n    KeyboardData data = new KeyboardData();\n    data.deviceType = menuItem.deviceType.Keyboard;\n    GetTransformData(data);\n    data.muted = muted;\n    data.octaveSwitch = octaveToggle.switchVal;\n    data.ADSRdata = new Vector2[3];\n    for (int i = 0; i < 3; i++) {\n      data.ADSRdata[i] = _adsrInterface.xyHandles[i].percent;\n    }\n\n    data.jackOutID = output.transform.GetInstanceID();\n    data.freqOutID = freqoutput.transform.GetInstanceID();\n    data.ampOutID = ampoutput.transform.GetInstanceID();\n\n    data.midiInConnection = _midiIn.connectedDevice;\n    data.midiOutConnection = _midiOut.connectedDevice;\n    data.sequencerEnabled = _timeline.gameObject.activeSelf;\n\n    data.timelinePresent = true;\n    data.timelineData = _timeline.GetTimelineData();\n    data.timelineHeight = _timeline.heightHandle.transform.localPosition.y;\n    List<timelineEvent.eventData> tempevents = new List<timelineEvent.eventData>();\n    for (int i = 0; i < _timeline._tlEvents.Count; i++) {\n      if (_timeline._tlEvents[i]!= null) tempevents.Add(_timeline._tlEvents[i].getEventInfo());\n    }\n    data.timelineEvents = tempevents.ToArray();\n\n    return data;\n  }\n\n  public override void Load(InstrumentData d) {\n    KeyboardData data = d as KeyboardData;\n    base.Load(data);\n\n    output.ID = data.jackOutID;\n    freqoutput.ID = data.freqOutID;\n    ampoutput.ID = data.ampOutID;\n\n    for (int i = 0; i < 3; i++) _adsrInterface.xyHandles[i].setPercent(data.ADSRdata[i]);\n    _adsrInterface.setDefaults = false;\n\n    muteButton.startToggled = data.muted;\n    octaveToggle.setSwitch",
    "code_repairing_3": "```csharp\n\nusing UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class keyboardDeviceInterface : deviceInterface {\npublic timelineComponentInterface _timeline;\npublic midiComponentInterface _midiIn, _midiOut;\npublic GameObject whiteKeyPrefab, blackKeyPrefab;\npublic omniJack output, freqoutput, ampoutput;\npublic button muteButton, midiInButton, midiOutButton, sequenceButton;\n\npublic midiOutOfRange midiLow, midiHigh;\n\npublic speaker _speaker;\nint keyCount = 25;\nkey[] keys;\n\nadsrInterface _adsrInterface;\nbasicSwitch octaveToggle;\n\nkeyFrequencySignalGenerator freqSignal;\nadsrSignalGenerator adsrSignal;\nint curKey;\n\nkeyState[] keyStates = new keyState[25];\n\npublic override void Awake() {\nbase.Awake();\n\ncurKey = -1;\n\n_adsrInterface = GetComponentInChildren<adsrInterface>();\noctaveToggle = GetComponentInChildren<basicSwitch>();\n\nfreqSignal = GetComponent<keyFrequencySignalGenerator>();\nadsrSignal = GetComponent<adsrSignalGenerator>();\n\nfreqoutput.homesignal = freqSignal;\nampoutput.homesignal = adsrSignal;\n\nkeys = new key[keyCount];\nadsrSignal.durations = _adsrInterface.durations;\nadsrSignal.volumes = _adsrInterface.volumes;\nSpawnKeys();\n\nfor (int i = 0; i < 25; i++) keyStates[i] = new keyState(false);\n}\n\nvoid SpawnKeys() {\nfloat separation =.05f;\nint whiteCount = 0;\nfor (int i = 0; i < keyCount; i++) {\nGameObject g;\nif (i % 12 == 1 || i % 12 == 3 || i % 12 == 6 || i % 12 == 8 || i % 12 == 10) {\ng = Instantiate(blackKeyPrefab, transform, false) as GameObject;\ng.transform.localPosition = new Vector3(-separation * whiteCount + separation / 2 +.15f,.03f, -.025f);\n} else {\ng = Instantiate(whiteKeyPrefab, transform, false) as GameObject;\ng.transform.localPosition = new Vector3(-separation * whiteCount +.15f, -.007f,.005f);\nwhiteCount++;\n}\nkeys[i] = g.GetComponent<key>();\nkeys[i].keyValue = i;\nkeys[i].isKeyboard = true;\nkeys[i].sticky = false;\n}\n}\n\nbool muted = false;\npublic void toggleMute(bool on) {\nmuted = on;\n_speaker.volume = muted? 0 : 1;\n}\n\npublic override void onTimelineEvent(int track, bool on) {\nasynchKeyHit(on, track, keyInput.seq);\n}\n\nbool midiLowDesired = false;\nbool midiHighDesired = false;\n\npublic override void OnMidiNote(int channel, bool on, int pitch) {\nint ID = pitch - 48;\nif (ID < 0) {\nif (on) midiLowDesired = true;\n} else if (ID > 24) {\nif (on) midiHighDesired = true;\n} else {\nasynchKeyHit(on, ID, keyInput.midi);\n}\n}\n\npublic void asynchKeyHit(bool on, int ID, keyInput k) {\nif (k == keyInput.midi) keyStates[ID].midiState = on;\nelse if (k == keyInput.seq) keyStates[ID].seqState = on;\nelse if (k == keyInput.touch) keyStates[ID].touchState = on;\n\nif (keyStates[ID].nonSeqStateChange()) {\nkeyStates[ID].currentNonSeqState = keyStates[ID].getNonSeqState();\n_timeline.onTimelineEvent(ID, keyStates[ID].currentNonSeqState);\n}\n\nif (keyStates[ID].stateChange()) {\non = keyStates[ID].currentState = keyStates[ID].getState();\nkeys[ID].phantomHit(on);\nkeyHitEvent(on, ID);\n}\n}\n\nvoid keyHitEvent(bool on, int ID) {\nif (on) {\nif (curKey!= ID) {\nint prev = curKey;\ncurKey = ID;\n\nif (prev!= -1) {\nadsrSignal.hit(false);\nif (_midiOut!= null) _midiOut.OutputNote(false, prev);\n}\n\nif (_midiOut!= null) _midiOut.OutputNote(on, ID);\nfreqSignal.UpdateKey(curKey);\nadsrSignal.hit(true);\n}\n} else {\nif (curKey == ID) {\n_midiOut.OutputNote(false, ID);\nadsrSignal.hit(false);\ncurKey = -1;\n}\n}\n}\n\nvoid toggleMIDIin(bool on) {\n_midiIn.gameObject.SetActive(on);\n}\n\nvoid toggleMIDIout(bool on) {\n_midiOut.gameObject.SetActive(on);\n}\n\nvoid toggleSequencer(bool on) {\n_timeline.gameObject.SetActive(on);\n}\n\npublic override void hit(bool on, int ID = -1) {\nif (ID == -1) {\ntoggleMute(on);\n} else if (ID == -2) {\ntoggleMIDIin(on);\n} else if (ID == -3) {\ntoggleMIDIout(on);\n} else if (ID == -4) {\ntoggleSequencer(on);\n} else {\nasynchKeyHit(on, ID, keyInput.touch);\n}\n}\n\nvoid Update() {\nif (octaveToggle.switchVal) freqSignal.octave = 1;\nelse freqSignal.octave = 0;\n\nif (midiLowDesired) {\nmidiLowDesired = false;\nmidiLow.gameObject.SetActive(true);\nmidiLow.Activate();\n}\n\nif (midiHighDesired) {\nmidiHighDesired = false;\nmidiHigh.gameObject.SetActive(true);\nmidiHigh.Activate();\n}\n}\n\npublic override InstrumentData GetData() {\nKeyboardData data = new KeyboardData();\ndata.deviceType = menuItem.deviceType.Keyboard;\nGetTransformData(data);\ndata.muted = muted;\ndata.octaveSwitch = octaveToggle.switchVal;\ndata.ADSRdata = new Vector2[3];\nfor (int i = 0; i < 3; i++) {\ndata.ADSRdata[i] = _adsrInterface.xyHandles[i].percent;\n}\n\ndata.jackOutID = output.transform.GetInstanceID();\ndata.freqOutID = freqoutput.transform.GetInstanceID();\ndata.ampOutID = ampoutput.transform.GetInstanceID();\n\ndata.midiInConnection = _midiIn.connectedDevice;\ndata.midiOutConnection = _midiOut.connectedDevice;\ndata.sequencerEnabled = _timeline.gameObject.activeSelf;\n\ndata.timelinePresent = true;\ndata.timelineData = _timeline.GetTimelineData();\ndata.timelineHeight = _timeline.heightHandle.transform.localPosition.y;\nList<timelineEvent.eventData> tempevents = new List<timelineEvent.eventData>();\nfor (int i = 0; i < _timeline._tlEvents.Count; i++) {\nif (_timeline._tlEvents[i]!= null) tempevents.Add(_timeline._tlEvents[i].getEventInfo());\n}\ndata.timelineEvents = tempevents.ToArray();\n\nreturn data;\n}\n\npublic override void Load(InstrumentData d) {\nKeyboardData data = d as KeyboardData;\nbase.Load(data);\n\noutput.ID = data.jackOutID;\nfreqoutput.ID = data.freqOutID;\nampoutput.ID = data.ampOutID;\n\nfor (int i = 0; i < 3; i++) _adsrInterface.xyHandles[i].setPercent(data.ADSRdata[i]);\n_adsr",
    "code_repairing_4": "En un reactor nuclear, la fuente de energ\u00eda principal es el combustible nuclear, que se rompe en dos is\u00f3topos, que despu\u00e9s se absorben en las c\u00e9lulas. Esto genera una gran cantidad de calor, que se utiliza para calentar una serie de materiales que se encargan de absorber y enfriar la energ\u00eda, haci\u00e9ndola perpetua"
}