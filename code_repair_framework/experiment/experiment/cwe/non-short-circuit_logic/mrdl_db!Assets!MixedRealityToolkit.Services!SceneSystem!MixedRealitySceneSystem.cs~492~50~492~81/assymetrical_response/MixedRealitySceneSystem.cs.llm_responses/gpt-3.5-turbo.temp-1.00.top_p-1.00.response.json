{
    "id": "chatcmpl-9wAt1D8PHE3uwK7g0UigQ9JankhCP",
    "object": "chat.completion",
    "created": 1723651899,
    "model": "gpt-35-turbo",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded);\n"
            },
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "index": 1,
            "message": {
                "role": "assistant",
                "content": "scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded);\n                }\n\n                \n                if (!scenesLoadedAndActivated)\n                {\n                    await Task.Yield();\n                }\n            }\n\n            \n            InvokeContentLoadedAction(validNames, sceneType);\n\n            \n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n        }\n\n        \n        private async Task UnloadScenesInternal(IEnumerable<string> scenesToUnload, SceneType sceneType, float progressOffset = 0, float progressTarget = 1, bool sceneOpInProgressWhenFinished = false)\n        {\n            SetSceneOpProgress(true, progressOffset, sceneType);\n\n            List<int> validIndexes = new List<int>();\n\n            foreach (string sceneName in scenesToUnload)\n            {\n                \n                Scene scene;\n                int sceneIndex;\n                if (!RuntimeSceneUtils.FindScene(sceneName, out scene, out sceneIndex))\n                {\n                    Debug.LogError(\"Can't unload invalid scene \" + sceneName);\n                }\n                else\n                {\n                    validIndexes.Add(sceneIndex);\n                }\n            }\n\n            int totalSceneOps = validIndexes.Count;\n            if (totalSceneOps < 1)\n            {\n                Debug.LogWarning(\"No valid scenes found to unload.\");\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n            \n            InvokeWillUnloadActions(scenesToUnload, sceneType);\n\n            foreach (int sceneIndex in validIndexes)\n            {\n                Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                if (!scene.isLoaded)\n                    continue;\n\n                AsyncOperation sceneOp = SceneManager.UnloadSceneAsync(sceneIndex);\n                await Task.Yield();\n\n                while (!sceneOp.isDone)\n                {\n                    if (!Application.isPlaying)\n                    {\n                        \n                        break;\n                    }\n\n                    await Task.Yield();\n                }\n\n                \n                yield return null;\n            }\n\n            \n            InvokeContentUnloadedAction(scenesToUnload, sceneType);\n\n            \n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n        }\n\n        \n        private void InvokeWillLightingActions(string lightingSceneName)\n        {\n            OnWillLoadLighting?.Invoke(new string[] { lightingSceneName });\n            OnWillUnloadLighting?.Invoke(new string[] { lightingSceneName });\n        }\n\n        \n        private void InvokeLightingLoadedAction(string lightingSceneName)\n        {\n            OnLightingLoaded?.Invoke(new string[] { lightingSceneName });\n            OnLightingUnloaded?.Invoke(new string[] { lightingSceneName });\n        }\n\n        \n        private void InvokeWillLoadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    OnWillLoadScene?.Invoke(sceneNames);\n                    break;\n                case SceneType.Content:\n                    OnWillLoadContent?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    foreach (string sceneName in sceneNames)\n                    {\n                        InvokeWillLightingActions(sceneName);\n                    }\n                    break;\n            }\n        }\n\n        \n        private void InvokeContentLoadedAction(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    OnSceneLoaded?.Invoke(sceneNames);\n                    break;\n                case SceneType.Content:\n                    OnContentLoaded?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    foreach (string sceneName in sceneNames)\n                    {\n                        InvokeLightingLoadedAction(sceneName);\n                    }\n                    break;\n            }\n        }\n\n        \n        private void InvokeWillUnloadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            if (sceneType == SceneType.Lighting)\n            {\n                foreach (string sceneName in sceneNames)\n                {\n                    InvokeWillLightingActions(sceneName);\n                }\n            }\n\n            OnWillUnloadScene?.Invoke(sceneNames);\n            OnWillUnloadContent?.Invoke(sceneNames);\n        }\n\n        \n        private void InvokeContentUnloadedAction(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Lighting:\n                    foreach (string sceneName in sceneNames)\n                    {\n                        InvokeLightingLoadedAction(sceneName);\n                    }\n                    break;\n                default:\n                    OnContentUnloaded?.Invoke(sceneNames);\n                    OnSceneUnloaded?.Invoke(sceneNames);\n                    break;\n            }\n        }\n\n        \n        private void SetSceneOpProgress(bool inProgress, float progress, SceneType sceneType)\n        {\n            SceneOperationInProgress = inProgress;\n            LightingOperationInProgress = inProgress && sceneType == SceneType.Lighting;\n            SceneOperationProgress = progress;\n            LightingOperationProgress = progress;\n        }\n\n        \n        private bool CanSceneOpProceed(SceneType sceneType)\n        {\n            return !SceneOperationInProgress || (SceneOperationInProgress && sceneType == SceneType.Lighting);\n        }\n\n        \n        private bool GetLoadedContentScenes(out IEnumerable<string> contentScenes)\n        {\n            contentScenes = from scene in SceneManager.sceneCount > 0 ? Enumerable.Range(0, SceneManager.sceneCount).Select(SceneManager.GetSceneAt) : Enumerable.Empty<Scene>()\n                            where profile.IsContentScene(scene.name)\n                            select scene.name;\n\n            return contentScenes.Any();\n        }\n\n        \n        private async Task<bool> CanProceedWithSceneActivation(SceneActivationToken activationToken)\n        {\n            activationToken?.SetReadyToProceed(false);\n\n            bool canProceed = false;\n            if (activationToken == null)\n            {\n                canProceed = true;\n            }\n            else\n            {\n                while (!canProceed)\n                {\n                    canProceed = activationToken.AllowSceneActivation;\n\n                    if (!canProceed)\n                    {\n                        await Task.Yield();\n                    }\n                    else\n                    {\n                        activationToken.SetReadyToProceed(true);\n                    }\n                }\n            }\n\n            return canProceed;\n        }\n    }\n}"
            },
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "index": 2,
            "message": {
                "role": "assistant",
                "content": "scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded);"
            },
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "index": 3,
            "message": {
                "role": "assistant",
                "content": "scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded);\n\n                }\n\n                await Task.Yield();\n            }\n\n            \n            InvokeLoadedActions(validNames, sceneType);\n\n            \n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n        }\n\n        \n        private async Task UnloadScenesInternal(\n            IEnumerable<string> scenesToUnload,\n            SceneType sceneType,\n            float progressOffset = 0,\n            float progressTarget = 1,\n            bool sceneOpInProgressWhenFinished = false)\n        {\n            \n            SetSceneOpProgress(true, progressOffset, sceneType);\n\n            \n            List<string> validNames = new List<string>();\n            List<int> validIndexes = new List<int>();\n\n            foreach (string sceneName in scenesToUnload)\n            {\n                \n                Scene scene;\n                int sceneIndex;\n                if (!RuntimeSceneUtils.FindScene(sceneName, out scene, out sceneIndex))\n                {\n                    Debug.LogError(\"Can't unload invalid scene \" + sceneName);\n                }\n                else\n                {\n                    validIndexes.Add(sceneIndex);\n                    validNames.Add(sceneName);\n                }\n            }\n\n            int totalSceneOps = validIndexes.Count;\n            if (totalSceneOps < 1)\n            {\n                Debug.LogWarning(\"No valid scenes found to unload.\");\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n            \n            InvokeWillUnloadActions(validNames, sceneType);\n\n            \n            if (validIndexes.Count > 0)\n            {\n                List<AsyncOperation> unloadSceneOps = new List<AsyncOperation>();\n                foreach (int sceneIndex in validIndexes)\n                {\n                    Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                    if (!scene.isLoaded)\n                    {\n                        continue;\n                    }\n\n                    AsyncOperation sceneOp = SceneManager.UnloadSceneAsync(sceneIndex);\n                    unloadSceneOps.Add(sceneOp);\n                }\n\n                \n                bool completedAllSceneOps = false;\n\n                while (!completedAllSceneOps)\n                {\n                    if (!Application.isPlaying)\n                    {\n                        return;\n                    }\n\n                    completedAllSceneOps = true;\n                    foreach (AsyncOperation unloadSceneOp in unloadSceneOps)\n                    {\n                        if (!unloadSceneOp.isDone)\n                        {\n                            completedAllSceneOps = false;\n                            break;\n                        }\n                    }\n\n                    \n                    float sceneOpProgress = (float)(unloadSceneOps.Count - unloadSceneOps.Count(op => op.isDone)) / unloadSceneOps.Count;\n                    SetSceneOpProgress(true, Mathf.Lerp(progressOffset, progressTarget, sceneOpProgress), sceneType);\n\n                    await Task.Yield();\n                }\n            }\n\n            \n            InvokeUnloadedActions(validNames, sceneType);\n\n            \n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n        }\n\n        \n        private void InvokeWillLoadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnWillLoadContent?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnWillLoadLighting?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n                default:\n                    OnWillLoadScene?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private void InvokeLoadedActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnContentLoaded?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnLightingLoaded?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n                default:\n                    OnSceneLoaded?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private void InvokeWillUnloadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnWillUnloadContent?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnWillUnloadLighting?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n                default:\n                    OnWillUnloadScene?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private void InvokeUnloadedActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    OnContentUnloaded?.Invoke(sceneNames);\n                    break;\n                case SceneType.Lighting:\n                    OnLightingUnloaded?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n                default:\n                    OnSceneUnloaded?.Invoke(sceneNames.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private bool CanSceneOpProceed(SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    return !SceneOperationInProgress;\n                case SceneType.Lighting:\n                    return !LightingOperationInProgress;\n                default:\n                    return false;\n            }\n        }\n\n        \n        private void SetSceneOpProgress(bool inProgress, float progress, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Content:\n                    SceneOperationInProgress = inProgress;\n                    SceneOperationProgress = progress;\n                    break;\n                case SceneType.Lighting:\n                    LightingOperationInProgress = inProgress;\n                    LightingOperationProgress = progress;\n                    break;\n            }\n        }\n\n        \n        private bool GetLoadedContentScenes(out IEnumerable<string> loadedContentScenes)\n        {\n            List<string> loadedScenes = new List<string>();\n            List<SceneInfo> contentScenes = profile.ContentScenes;\n\n            foreach (SceneInfo scene in contentScenes)\n            {\n                if (IsContentLoaded(scene.Name))\n                {\n                    loadedScenes.Add(scene.Name);\n                }\n            }\n\n            loadedContentScenes = loadedScenes;\n            return loadedScenes.Count > 0;\n        }\n    }\n}\n\"\"\""
            },
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "index": 4,
            "message": {
                "role": "assistant",
                "content": " scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded);"
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 2866,
        "completion_tokens": 2410,
        "total_tokens": 5276
    },
    "system_fingerprint": "fp_e49e4201a9"
}