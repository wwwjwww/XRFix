{
    "id": "chatcmpl-9yzlNqReJHxK7tUeSB6eabB8X1Mqq",
    "object": "chat.completion",
    "created": 1724324125,
    "model": "gpt-35-turbo",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```csharp\n                        scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded);\n```"
            },
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "index": 1,
            "message": {
                "role": "assistant",
                "content": "                scenesLoadedAndActivated &= scene.IsValid() && scene.isLoaded;\n                await Task.Yield();\n            }\n\n            \n            InvokeContentLoadedActions(validNames, sceneType);\n\n            \n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n\n            \n            activationToken?.SetReadyToProceed(false);\n        }\n\n        \n        private async Task UnloadScenesInternal(IEnumerable<string> scenesToUnload, SceneType sceneType, float progressOffset = 0, float progressTarget = 1, bool sceneOpInProgressWhenFinished = false)\n        {\n            SetSceneOpProgress(true, progressOffset, sceneType);\n\n            \n            List<Scene> scenesList = new List<Scene>();\n            foreach (string sceneName in scenesToUnload)\n            {\n                Scene scene = SceneManager.GetSceneByName(sceneName);\n                if (!scene.IsValid())\n                {   \n                    continue;\n                }\n\n                scenesList.Add(scene);\n            }\n\n            int totalSceneOps = scenesList.Count;\n            if (totalSceneOps < 1)\n            {\n                Debug.LogWarning(\"No valid scenes found to unload.\");\n                \n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n            \n            InvokeWillUnloadActions(scenesToUnload, sceneType);\n\n            \n            List<AsyncOperation> unloadSceneOps = new List<AsyncOperation>();\n            foreach (Scene scene in scenesList)\n            {\n                AsyncOperation sceneOp = SceneManager.UnloadSceneAsync(scene);\n                unloadSceneOps.Add(sceneOp);\n            }\n\n            \n            while (unloadSceneOps.Any(op => !op.isDone))\n            {\n                if (!Application.isPlaying)\n                {   \n                    return;\n                }\n\n                \n                float sceneOpProgress = Mathf.Clamp01(unloadSceneOps.Count(op => op.isDone) / (float)totalSceneOps);\n                SetSceneOpProgress(true, Mathf.Lerp(progressOffset, progressTarget, sceneOpProgress), sceneType);\n                await Task.Yield();\n            }\n\n            \n            InvokeContentUnloadedActions(scenesToUnload, sceneType);\n\n            \n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n        }\n\n        \n        private void InvokeWillLoadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    \n                    if (OnWillLoadScene != null && OnWillLoadScene.GetInvocationList().Length > 0)\n                    {\n                        foreach (string sceneName in sceneNames)\n                        {\n                            OnWillLoadScene?.Invoke(sceneName);\n                        }\n                    }\n                    break;\n                case SceneType.Content:\n                    \n                    if (OnWillLoadContent != null && OnWillLoadContent.GetInvocationList().Length > 0)\n                    {\n                        OnWillLoadContent?.Invoke(sceneNames);\n                    }\n                    break;\n                case SceneType.Lighting:\n                    \n                    if (OnWillLoadLighting != null && OnWillLoadLighting.GetInvocationList().Length > 0)\n                    {\n                        foreach (string sceneName in sceneNames)\n                        {\n                            OnWillLoadLighting?.Invoke(sceneName);\n                        }\n                    }\n                    break;\n            }\n        }\n\n        \n        private void InvokeContentLoadedActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    \n                    if (OnSceneLoaded != null && OnSceneLoaded.GetInvocationList().Length > 0)\n                    {\n                        foreach (string sceneName in sceneNames)\n                        {\n                            OnSceneLoaded?.Invoke(sceneName);\n                        }\n                    }\n                    break;\n                case SceneType.Content:\n                    \n                    if (OnContentLoaded != null && OnContentLoaded.GetInvocationList().Length > 0)\n                    {\n                        OnContentLoaded?.Invoke(sceneNames);\n                    }\n                    break;\n                case SceneType.Lighting:\n                    \n                    if (OnLightingLoaded != null && OnLightingLoaded.GetInvocationList().Length > 0)\n                    {\n                        foreach (string sceneName in sceneNames)\n                        {\n                            OnLightingLoaded?.Invoke(sceneName);\n                        }\n                    }\n                    break;\n            }\n        }\n\n        \n        private void InvokeWillUnloadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    \n                    if (OnWillUnloadScene != null && OnWillUnloadScene.GetInvocationList().Length > 0)\n                    {\n                        foreach (string sceneName in sceneNames)\n                        {\n                            OnWillUnloadScene?.Invoke(sceneName);\n                        }\n                    }\n                    break;\n                case SceneType.Content:\n                    \n                    if (OnWillUnloadContent != null && OnWillUnloadContent.GetInvocationList().Length > 0)\n                    {\n                        OnWillUnloadContent?.Invoke(sceneNames);\n                    }\n                    break;\n                case SceneType.Lighting:\n                    \n                    if (OnWillUnloadLighting != null && OnWillUnloadLighting.GetInvocationList().Length > 0)\n                    {\n                        foreach (string sceneName in sceneNames)\n                        {\n                            OnWillUnloadLighting?.Invoke(sceneName);\n                        }\n                    }\n                    break;\n            }\n        }\n\n        \n        private void InvokeContentUnloadedActions(IEnumerable<string> sceneNames, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    \n                    if (OnSceneUnloaded != null && OnSceneUnloaded.GetInvocationList().Length > 0)\n                    {\n                        foreach (string sceneName in sceneNames)\n                        {\n                            OnSceneUnloaded?.Invoke(sceneName);\n                        }\n                    }\n                    break;\n                case SceneType.Content:\n                    \n                    if (OnContentUnloaded != null && OnContentUnloaded.GetInvocationList().Length > 0)\n                    {\n                        OnContentUnloaded?.Invoke(sceneNames);\n                    }\n                    break;\n                case SceneType.Lighting:\n                    \n                    if (OnLightingUnloaded != null && OnLightingUnloaded.GetInvocationList().Length > 0)\n                    {\n                        foreach (string sceneName in sceneNames)\n                        {\n                            OnLightingUnloaded?.Invoke(sceneName);\n                        }\n                    }\n                    break;\n            }\n        }\n\n        \n        private bool CanSceneOpProceed(SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    return !SceneOperationInProgress && !managerSceneOpInProgress;\n                case SceneType.Content:\n                    return !SceneOperationInProgress;\n                case SceneType.Lighting:\n                    return !LightingOperationInProgress;\n            }\n            return false;\n        }\n\n        \n        private void SetSceneOpProgress(bool isInProgress, float progress, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    managerSceneOpInProgress = isInProgress;\n                    managerSceneOpProgress = progress;\n                    break;\n                case SceneType.Content:\n                    SceneOperationInProgress = isInProgress;\n                    SceneOperationProgress = progress;\n                    break;\n                case SceneType.Lighting:\n                    LightingOperationInProgress = isInProgress;\n                    LightingOperationProgress = progress;\n                    break;\n            }\n        }\n\n        \n        private bool GetLoadedContentScenes(out IEnumerable<string> loadedContentScenes)\n        {\n            List<string> loadedScenes = new List<string>();\n\n            for (int i = 0; i < SceneManager.sceneCount; i++)\n            {\n                Scene scene = SceneManager.GetSceneAt(i);\n                if (profile.ContentSceneCandidates.Any(c => c == scene.name))\n                {\n                    loadedScenes.Add(scene.name);\n                }\n            }\n\n            loadedContentScenes = loadedScenes;\n            return loadedScenes.Any();\n        }\n\n        \n        private static class RuntimeSceneUtils\n        {\n            public static bool FindScene(string sceneName, out Scene scene, out int sceneIndex)\n            {\n                scene = default;\n\n                for (int i = 0; i < SceneManager.sceneCount; i++)\n                {\n                    Scene currentScene = SceneManager.GetSceneAt(i);\n                    if (currentScene.name == sceneName)\n                    {\n                        scene = currentScene;\n                        sceneIndex = i;\n                        return true;\n                    }\n                }\n\n                sceneIndex = -1;\n                return false;\n            }\n        }\n    }\n}\n\"\"\"\n"
            },
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "index": 2,
            "message": {
                "role": "assistant",
                "content": "    scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded);\n                }\n\n                \n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n\n                \n                InvokeLoadedActions(activationToken, validNames, sceneType);\n\n                \n                yield return Completed.SaveAsync();\n            }\n        }\n\n        \n        private async Task UnloadScenesInternal(\n            IEnumerable<string> scenesToUnload,\n            SceneType sceneType,\n            float progressOffset = 0,\n            float progressTarget = 1,\n            bool sceneOpInProgressWhenFinished = false)\n        {\n            SetSceneOpProgress(true, progressOffset, sceneType);\n\n            \n            List<string> validNames = new List<string>();\n            List<int> validIndexes = new List<int>();\n\n            foreach (string sceneName in scenesToUnload)\n            {\n                \n                Scene scene;\n                int sceneIndex;\n                if (!RuntimeSceneUtils.FindScene(sceneName, out scene, out sceneIndex))\n                {\n                    Debug.LogError(\"Can't unload invalid scene \" + sceneName);\n                }\n                else\n                {\n                    validIndexes.Add(sceneIndex);\n                    validNames.Add(sceneName);\n                }\n            }\n\n            if (validIndexes.Count < 1)\n            {\n                Debug.LogWarning(\"No valid scenes found to unload.\");\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n            InvokeWillUnloadActions(validNames, sceneType);\n\n            \n            List<AsyncOperation> unloadSceneOps = new List<AsyncOperation>();\n            foreach (int sceneIndex in validIndexes)\n            {\n                Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                if (!scene.isLoaded)\n                    continue;\n\n                AsyncOperation sceneOp = SceneManager.UnloadSceneAsync(sceneIndex);\n                unloadSceneOps.Add(sceneOp);\n            }\n\n            \n            bool completedAllSceneOps = false;\n\n            while (!completedAllSceneOps)\n            {\n                if (!Application.isPlaying)\n                {   \n                    return;\n                }\n\n                completedAllSceneOps = true;\n                foreach (AsyncOperation sceneOp in unloadSceneOps)\n                {\n                    if (!sceneOp.isDone)\n                    {\n                        completedAllSceneOps = false;\n                    }\n                }\n\n                \n                SetSceneOpProgress(true, progressTarget, sceneType);\n\n                await Task.Yield();\n            }\n\n            \n            InvokeUnloadedActions(validNames, sceneType);\n\n            \n            SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n        }\n\n        \n        private void SetSceneOpProgress(bool inProgress, float progress, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    managerSceneOpInProgress = inProgress;\n                    managerSceneOpProgress = progress;\n                    break;\n                case SceneType.Content:\n                    SceneOperationInProgress = inProgress;\n                    SceneOperationProgress = progress;\n                    break;\n                case SceneType.Lighting:\n                    LightingOperationInProgress = inProgress;\n                    LightingOperationProgress = progress;\n                    break;\n                default:\n                    return;\n            }\n        }\n\n        \n        private bool CanSceneOpProceed(SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    return !managerSceneOpInProgress;\n                case SceneType.Content:\n                    return !SceneOperationInProgress;\n                case SceneType.Lighting:\n                    return !LightingOperationInProgress;\n                default:\n                    return false;\n            }\n        }\n\n        \n        private bool GetLoadedContentScenes(out IEnumerable<string> loadedScenes)\n        {\n            IEnumerable<string> contentScenes = ContentSceneNames;\n            List<string> loadedSceneNames = new List<string>();\n\n            foreach (string sceneName in contentScenes)\n            {\n                if (IsContentLoaded(sceneName))\n                {\n                    loadedSceneNames.Add(sceneName);\n                }\n            }\n\n            loadedScenes = loadedSceneNames;\n\n            return loadedSceneNames.Count > 0;\n        }\n\n        \n        private void InvokeWillLoadActions(IEnumerable<string> scenes, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    OnWillLoadScene?.Invoke(scenes);\n                    break;\n                case SceneType.Content:\n                    OnWillLoadContent?.Invoke(scenes);\n                    break;\n                case SceneType.Lighting:\n                    OnWillLoadLighting?.Invoke(scenes.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private void InvokeLoadedActions(SceneActivationToken activationToken, IEnumerable<string> scenes, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    OnSceneLoaded?.Invoke(scenes.FirstOrDefault());\n                    break;\n                case SceneType.Content:\n                    OnContentLoaded?.Invoke(scenes);\n                    break;\n                case SceneType.Lighting:\n                    OnLightingLoaded?.Invoke(scenes.FirstOrDefault());\n                    activationToken?.SetReadyToProceed(true);\n                    break;\n            }\n        }\n\n        \n        private void InvokeWillUnloadActions(IEnumerable<string> scenes, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    OnWillUnloadScene?.Invoke(scenes);\n                    break;\n                case SceneType.Content:\n                    OnWillUnloadContent?.Invoke(scenes);\n                    break;\n                case SceneType.Lighting:\n                    OnWillUnloadLighting?.Invoke(scenes.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private void InvokeUnloadedActions(IEnumerable<string> scenes, SceneType sceneType)\n        {\n            switch (sceneType)\n            {\n                case SceneType.Manager:\n                    OnSceneUnloaded?.Invoke(scenes);\n                    break;\n                case SceneType.Content:\n                    OnContentUnloaded?.Invoke(scenes);\n                    break;\n                case SceneType.Lighting:\n                    OnLightingUnloaded?.Invoke(scenes.FirstOrDefault());\n                    break;\n            }\n        }\n\n        \n        private async void WaitToProceed(float waitTime)\n        {\n            WaitingToProceed = true;\n\n            await Task.Delay((int)(waitTime * 1000));\n\n            WaitingToProceed = false;\n        }\n    }\n}\n\"\"\""
            },
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "index": 3,
            "message": {
                "role": "assistant",
                "content": "        scenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded);\n\n                }\n\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n\n                InvokeContentLoadedAction(validNames, sceneType);\n            }\n\n            \n            SetSceneOpProgress(false, progressTarget, sceneType);\n        }\n\n        \n        private async Task UnloadScenesInternal(IEnumerable<string> scenesToUnload, SceneType sceneType, float progressOffset = 0, float progressTarget = 1, bool sceneOpInProgressWhenFinished = false)\n        {\n            \n            SetSceneOpProgress(true, progressOffset, sceneType);\n\n            IEnumerable<int> sceneIndexes;\n            if (!RuntimeSceneUtils.FindScenes(scenesToUnload, out sceneIndexes))\n            {\n                Debug.LogWarning(\"No valid scenes found to unload.\");\n                SetSceneOpProgress(sceneOpInProgressWhenFinished, progressTarget, sceneType);\n                return;\n            }\n\n            \n            List<string> validScenes = new List<string>();\n            foreach (string sceneName in scenesToUnload)\n            {\n                Scene scene = SceneManager.GetSceneByName(sceneName);\n                if (scene.IsValid())\n                {\n                    validScenes.Add(sceneName);\n                }\n            }\n\n            InvokeWillUnloadActions(validScenes, sceneType);\n\n            \n            if (sceneIndexes.Any())\n            {\n                List<AsyncOperation> unloadSceneOps = new List<AsyncOperation>();\n\n                foreach (int sceneIndex in sceneIndexes)\n                {\n                    Scene scene = SceneManager.GetSceneByBuildIndex(sceneIndex);\n                    if (!scene.IsValid() || !scene.isLoaded)\n                        continue;\n\n                    AsyncOperation sceneOp = SceneManager.UnloadSceneAsync(sceneIndex);\n                    unloadSceneOps.Add(sceneOp);\n                }\n\n                \n                bool completedAllSceneOps = false;\n\n                while (!completedAllSceneOps)\n                {\n                    if (!Application.isPlaying)\n                    {   \n                        return;\n                    }\n\n                    completedAllSceneOps = true;\n                    for (int i = 0; i < unloadSceneOps.Count; i++)\n                    {\n                        if (!unloadSceneOps[i].isDone)\n                        {\n                            completedAllSceneOps = false;\n                        }\n                    }\n\n                    SetSceneOpProgress(true, progressTarget, sceneType);\n                    await Task.Yield();\n                }\n            }\n\n            InvokeContentUnloadedAction(validScenes, sceneType);\n\n            \n            SetSceneOpProgress(false, progressTarget, sceneType);\n        }\n\n        \n\n#endregion\n\n        \nprivate void InvokeWillLoadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n{\n    switch (sceneType)\n    {\n        case SceneType.Content:\n            OnWillLoadContent?.Invoke(sceneNames);\n            break;\n        case SceneType.Lighting:\n            OnWillLoadLighting?.Invoke(sceneNames.FirstOrDefault());\n            break;\n        case SceneType.Manager:\n            OnWillLoadScene?.Invoke(sceneNames.FirstOrDefault());\n            break;\n        default:\n            throw new ArgumentOutOfRangeException(nameof(sceneType), sceneType, null);\n    }\n}\n\n        \nprivate void InvokeContentLoadedAction(IEnumerable<string> sceneNames, SceneType sceneType)\n{\n    switch (sceneType)\n    {\n        case SceneType.Content:\n            OnContentLoaded?.Invoke(sceneNames);\n            break;\n        case SceneType.Lighting:\n            OnLightingLoaded?.Invoke(sceneNames.FirstOrDefault());\n            break;\n        case SceneType.Manager:\n            OnSceneLoaded?.Invoke(sceneNames.FirstOrDefault());\n            break;\n        default:\n            throw new ArgumentOutOfRangeException(nameof(sceneType), sceneType, null);\n    }\n}\n\n        \nprivate void InvokeWillUnloadActions(IEnumerable<string> sceneNames, SceneType sceneType)\n{\n    switch (sceneType)\n    {\n        case SceneType.Content:\n            OnWillUnloadContent?.Invoke(sceneNames);\n            break;\n        case SceneType.Lighting:\n            OnWillUnloadLighting?.Invoke(sceneNames.FirstOrDefault());\n            break;\n        case SceneType.Manager:\n            OnWillUnloadScene?.Invoke(sceneNames.FirstOrDefault());\n            break;\n        default:\n            throw new ArgumentOutOfRangeException(nameof(sceneType), sceneType, null);\n    }\n}\n\n        \nprivate void InvokeContentUnloadedAction(IEnumerable<string> sceneNames, SceneType sceneType)\n{\n    switch (sceneType)\n    {\n        case SceneType.Content:\n            OnContentUnloaded?.Invoke(sceneNames);\n            break;\n        case SceneType.Lighting:\n            OnLightingUnloaded?.Invoke(sceneNames.FirstOrDefault());\n            break;\n        case SceneType.Manager:\n            OnSceneUnloaded?.Invoke(sceneNames.FirstOrDefault());\n            break;\n        default:\n            throw new ArgumentOutOfRangeException(nameof(sceneType), sceneType, null);\n    }\n}\n\n        \nprivate void SetSceneOpProgress(bool inProgress, float progress, SceneType sceneType)\n{\n    switch (sceneType)\n    {\n        case SceneType.Content:\n            SceneOperationInProgress = inProgress;\n            SceneOperationProgress = progress;\n            break;\n        case SceneType.Lighting:\n            LightingOperationInProgress = inProgress;\n            LightingOperationProgress = progress;\n            break;\n        default:\n            throw new ArgumentOutOfRangeException(nameof(sceneType), sceneType, null);\n    }\n}\n\n    }\n}"
            },
            "logprobs": null,
            "finish_reason": "stop"
        },
        {
            "index": 4,
            "message": {
                "role": "assistant",
                "content": "```csharp\nscenesLoadedAndActivated &= (scene.IsValid() && scene.isLoaded);\n```"
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 2852,
        "completion_tokens": 3917,
        "total_tokens": 6769
    },
    "system_fingerprint": "fp_e49e4201a9"
}