{
    "code_repairing_0": "foreach (CSProjectInfo project in orderedProjects)\n\n{\n\nconfigurationMappings.Add($\"<{project.Name}>InEditor|<{project.Name}>Player</{project.Name}>\");\n\n}\n\ndisabled.AddRange(availableProjects.Select(t => $\"<{t}>{(t.Editor || t.Debug ? \"InEditor|Player\" : \"InEditor\")}\").Distinct());\n\nstring projectFileDir = Path.Combine(generatedProjectPath, \"Project Files\");\n\nif (!Directory.Exists(projectFileDir))\n\n{\n\nDirectory.CreateDirectory(projectFileDir);\n\n}\n\nforeach (CSProjectInfo project in orderedProjects)\n\n{\n\nstring projectFile = Path.Combine(projectFileDir, $\"{project.Name}.vcxproj\");\n\nusing (StreamWriter writer = new StreamWriter(projectFile))\n\n{\n\nstring projectText = Utilities.ReplaceTokens(projectFileTemplateText,\n\nnew Dictionary<string, string>() {\n\n{\"<PROJECT_GUID>\", project.Guid.ToString().ToUpper() },\n\n{\"<PROJECT_NAME>\", project.Name },\n\n{\"<TARGET>\", project.TargetName },\n\n{\"<CONFIGURATION_PLATFORM_MAPPING>\", String.Join(\";\", configurationMappings.ToArray()) },\n\n{\"<CONFIGURATION_PLATFORM_ENABLED>\", String.Join(\";\", disabled.ToArray()) }\n\n});\n writer.WriteLine(projectText);\n\n}\n\n}\n\nstring solutionFileText = Utilities.ReplaceTokens(solutionFileText, new Dictionary<string, string>()\n\n{\n\n{ \"<PROJECT_GUID>\", CSProject.Guid.ToString().ToUpper()},\n\n{ \"<PROJECT_NAME>\", CSProject.Name},\n\n });\n\n}\n\npublic static MSBuildProjectInfo Parse(DirectoryInfo parentDir, string platform, IEnumerable<CSProjectInfo> platforms, IDictionary<(string, string), string> propertiesFileContents)\n\n{\n\nMSBuildProjectInfo toReturn = new MSBuildProjectInfo();\n\ntoReturn.Directory = parentDir;\n\ntoReturn.Platform = platform;\n\ntoReturn.PropertiesFileContents = propertiesFileContents;\n\ntoReturn.Platforms = new ReadOnlyCollection<MSBuildPlatformInfo>(platforms.Select(p => new MSBuildPlatformInfo(p)).ToArray());\n\nstring projectFilePath = Path.Combine(parentDir.FullName, $\"{toReturn.Name}.proj\");\n\nstring fullProjectPath = Utilities.GetFullPathFromKnownRelative(projectFilePath);\n\nif (File.Exists(fullProjectPath))\n\n{\n\ntoReturn.FilePath = new FileInfo(fullProjectPath);\n\n}\n\nreturn toReturn;\n\n}\n\nprivate void ExtractProperties()\n\n{\n\nif (FilePath == null || !FilePath.Exists)\n\n{\n\nDebug.LogWarning($\"Properties file does not exist: {FilePath.FullName}\");\n\n}\n\nList<string> propertyLines = new List<string>();\n\nstring projectPath = FilePath.Directory.FullName;\n\nusing (StreamReader reader = new StreamReader(FilePath.FullName))\n\n{\n\nstring line;\n\nwhile ((line = reader.ReadLine()) != null)\n\n{\n\nif (String.IsNullOrWhiteSpace(line) || line.StartsWith(\"#\"))\n\n{\n\ncontinue;\n\n}\n\nint equalIndex = line.IndexOf('=');\n\nif (equalIndex == -1)\n\n{\n\nDebug.LogWarning($\"Invalid property definition: {line}\");\n\ncontinue;\n\n}\n\nstring propertyName = line.Substring(0, equalIndex);\n\nstring propertyValue = line.Substring(equalIndex + 1);\n\nstring fullPropertyName = $@\"{projectPath}\\{propertyName}\";\n\npropertiesFileContents.Add((fullPropertyName, propertyName.ToLower()), propertyValue.Trim());\n\n}\n\n}\n\n}\n\nprivate bool TryGetPropertyValue(string name, out string value)\n\n{\n\nif (String.IsNullOrEmpty(name))\n\n{\n\nDebug.LogError(\"Property name cannot be empty\");\n\nvalue = null;\n\nreturn false;\n\n}\n\nstring lowerName = name.ToLower();\n\nif (!propertiesFileContents.TryGetValue((FilePath.Directory?.FullName + \"\\\\\" + lowerName), out value) && !propertiesFileContents.TryGetValue((lowerName), out value))\n\n{\n\n Debug.LogWarning($\"Property '{name}' does not exist in file: {FilePath.FullName}\");\n\n}\n\nreturn value != null;\n\n}\n\nprivate void SetPropertyValue(string name, string value)\n\n{\n\nif (String.IsNullOrEmpty(name))\n\n{\n\nDebug.LogError(\"Property name cannot be empty.\");\n\nreturn;\n\n}\n\nstring propertyName = name.ToLower();\n\npropertiesFileContents[FilePath.Directory?.FullName + \"\\\\\" + propertyName] = value;\n\n }\n\npublic string GetPropertyValue(string name)\n\n{\n\nstring value;\n\nif (TryGetPropertyValue(name, out value))\n\n{\n\nreturn value;\n\n}\n\nreturn null;\n\n}\n\npublic bool TryGetPropertyValue(string name, out string value)\n\n{\n\nreturn TryGetPropertyValue(name, out value);\n\n}\n\npublic void SetPropertyValue(string name, string value)\n\n{\n\nSetPropertyValue(name, value);\n\n}\n\n}",
    "code_repairing_1": "'''\n\npublic class ExampleScript : MonoBehaviour\n{\n    static void Main(string[] args)\n    {\n        List<int> lst = Enumerable.Range(1, 10).ToList();\n\n        //foreach (int i in lst.Select(e => e).Where(e => e % 2 == 0))\n        //FIXED CODE:\n        foreach (int i in lst.Where(e => e % 2 == 0))\n\n    }\n}\n\n'''\n\n\n\n# Fixes the redundancy on the .NET API\n\nThe original code contains Redundancy on the .NET API. This is a common problem in the .NET ecosystem, and it can cause confusion and bugs.\n\nTo fix this problem, you can use the .NET API in a more efficient way by replacing the redundant code with a more concise and elegant one. In this case, the redundant call to the Select method is simply removing the anonymous function from the expression.\n\nHere's an example of how the code can be fixed:\n\npublic static IEnumerable<T> Yield<T>(T value)\n{\n        yield return value;\n}\n\n// Redundant code:\n'myList.Where(i => i > 5)'\n\n// Better way:\n'myList.Where(Yield).Select(i => i.Value)'\n\nIn the first example, the 'Yield' method is a simple method that yields back the value sent as a parameter. This avoids the creation of an anonymous function, which is an extra step required with the original code.\n\nThe second example, uses the 'Where' method and a more concise expression to generate the IEnumerable sequence, which is then transformed into a list using the 'Select' method.\n\nNote that the best way to fix this problem is to fix the underlying reason: avoid using the anonymous function when it's not necessary. In this case, you can use the 'Where' method without the anonymous function.",
    "code_repairing_2": "foreach (CSProjectInfo project in orderedProjects)\n                {\n                    configurationMappings.AddRange(configPlatforms.Select(cp => configurationPlatformMappingTemplate.Replace(\"<ProjectGuid>\", project.Guid.ToString().ToUpper()).Replace(\"<ConfigurationPlatform>\", cp)));\n                    disabled.Add(configurationPlatformEnabledTemplate.Replace(\"<ProjectGuid>\", project.Guid.ToString().ToUpper()).Replace(\"<ConfigurationPlatform>\", \"Player\"));\n                }\n\n                StringBuilder projectFileTextBuilder = new StringBuilder();\n                projectFileTextBuilder.AppendLine(\"Microsoft Visual Studio Solution File, Format Version 12.00\");\n                projectFileTextBuilder.AppendLine(\"# Visual Studio 15\");\n                projectFileTextBuilder.AppendLine(\"\");\n\n                foreach (string config in configurationMappings)\n                {\n                    projectFileTextBuilder.AppendLine(config);\n                }\n\n                foreach (string disabledProject in disabled)\n                {\n                    projectFileTextBuilder.AppendLine(disabledProject);\n                }\n\n                File.WriteAllText(solutionFilePath, projectFileTextBuilder.ToString());\n\n                GenerateUnityProjectFile(generatedProjectPath, projectFileTemplateText, projectFileTextBuilder.ToString());\n            }\n        }\n\n        private void GenerateUnityProjectFile(string generatedProjectPath, string projectFileTemplateText, string projectFileText)\n        {\n            string projectFilePath = Path.Combine(generatedProjectPath, $\"{UnityProjectName}.proj\");\n\n            if (File.Exists(projectFilePath))\n            {\n                File.Delete(projectFilePath);\n            }\n\n            if (Utilities.TryGetTextTemplate(projectFileTemplateText, \"PROJECT_SOLUTION_PATH\", out _, out string projectSolutionPathBody)\n                && Utilities.TryGetTextTemplate(projectFileTemplateText, \"PROJECT_LINKS\", out string projectLinksTemplateBody, out string projectLinksTemplateBodyBody))\n            {\n                StringBuilder projectFileTextBuilder = new StringBuilder();\n                projectFileTextBuilder.AppendLine(projectFileText.Replace(\"<SolutionPath>\", projectSolutionPathBody));\n\n                string[] projectLinksEntryTemplates = projectLinksTemplateBodyBody.Split(new string[] { \"\\r\\n\" }, StringSplitOptions.None);\n                List<string> projectLinks = new List<string>();\n\n                foreach (string projectInfoKey in CSProjects.Keys)\n                {\n                    CSProjectInfo projectInfo = CSProjects[projectInfoKey];\n                    string projectLinksEntryTemplate = projectLinksEntryTemplates.FirstOrDefault(t => t.Contains($\"<ProjectName>\", projectInfo.Name));\n\n                    if (!string.IsNullOrWhiteSpace(projectLinksEntryTemplate))\n                    {\n                        projectLinks.Add(Utilities.ReplaceTokens(projectLinksEntryTemplate, new Dictionary<string, string>() {\n                            { \"<ProjectName>\", projectInfo.Name },\n                            { \"<ProjectPath>\", projectInfo.ReferencePath.FullName },\n                            { \"<ProjectGuid>\", projectInfo.Guid.ToString().ToUpper() } }));\n                    }\n                    else\n                    {\n                        projectLinks.Add($\"Project(\\\"{projectInfo.Name}\\\") = \\\"{projectInfo.Name}\\\", \\\"{projectInfo.ReferencePath.FullName}\\\", \\\"{projectInfo.Guid.ToString().ToUpper()}\\\"\");\n                    }\n                }\n\n                projectLinks.Sort();\n                projectFileTextBuilder.AppendLine(string.Join(Environment.NewLine, projectLinks));\n                projectFileTextBuilder.Append(projectFileText.Replace(\"<ProjectLinks>\", projectLinks.ToString()));\n                File.WriteAllText(projectFilePath, projectFileTextBuilder.ToString());\n            }\n        }\n\n        private string GetProjectEntry(CSProjectInfo projectInfo, string projectEntryTemplateBody)\n        {\n            StringBuilder toReturn = new StringBuilder();\n            toReturn.AppendLine(Utilities.ReplaceTokens(projectEntryTemplateBody, new Dictionary<string, string>() {\n                        { \"<PROJECT_NAME>\", projectInfo.Name },\n                        { \"<PROJECT_RELATIVE_PATH>\", Path.GetFileName(projectInfo.ReferencePath.AbsolutePath) },\n                        { \"<PROJECT_GUID>\", projectInfo.Guid.ToString().ToUpper() } }));\n            if (projectInfo.ProjectDependencies.Count > 0)\n            {\n                string projectDependencyStartSection = \"    ProjectSection(ProjectDependencies) = postProject\";\n                string projectDependencyGuid = \"        {<DependencyGuid>} = {<DependencyGuid>}\";\n                string projectDependencyStopSection = \"    EndProjectSection\";\n                toReturn.AppendLine(projectDependencyStartSection);\n\n                foreach (CSProjectDependency<CSProjectInfo> project in projectInfo.ProjectDependencies)\n                {\n                    toReturn.AppendLine(projectDependencyGuid.Replace(\"<DependencyGuid>\", project.Dependency.Guid.ToString().ToUpper()));\n                }\n\n                toReturn.AppendLine(projectDependencyStopSection);\n            }\n            toReturn.Append(\"EndProject\");\n            return toReturn.ToString();\n        }\n\n        private List<PluginAssemblyInfo> ScanForPluginDLLs()\n        {\n            List<PluginAssemblyInfo> toReturn = new List<PluginAssemblyInfo>();\n\n            foreach (string assetAssemblyPath in Directory.GetFiles(Utilities.AssetPath, \"*.dll\", SearchOption.AllDirectories))\n            {\n                string assetRelativePath = Utilities.GetAssetsRelativePathFrom(assetAssemblyPath);\n                PluginImporter importer = (PluginImporter)AssetImporter.GetAtPath(assetRelativePath);\n                PluginAssemblyInfo toAdd = new PluginAssemblyInfo(this, Guid.Parse(AssetDatabase.AssetPathToGUID(assetRelativePath)), assetAssemblyPath, importer.isNativePlugin ? PluginType.Native : PluginType.Managed);\n                toReturn.Add(toAdd);\n            }\n\n            foreach (string packageDllPath in Directory.GetFiles(Utilities.PackagesCopyPath, \"*.dll\", SearchOption.AllDirectories))\n            {\n                string metaPath = packageDllPath + \".meta\";\n\n                if (!File.Exists(metaPath))\n                {\n                    Debug.LogWarning($\"Skipping a packages DLL that didn't have an associated meta: '{packageDllPath}'\");\n                    continue;\n                }\n                Guid guid;\n                using (StreamReader reader = new StreamReader(metaPath))\n                {\n                    string guidLine = reader.ReadUntil(\"guid\");\n                    if (!Guid.TryParse(guidLine.Split(':')[1].Trim(), out guid))\n                    {\n                        Debug.LogWarning($\"Skipping a packages DLL that didn't have a valid guid in the .meta file: '{packageDllPath}'\");\n                        continue;\n                    }\n                }\n\n                bool isManaged = Utilities.IsManagedAssembly(packageDllPath);\n                PluginAssemblyInfo toAdd = new PluginAssemblyInfo(this, guid, packageDllPath, isManaged ? PluginType.Managed : PluginType.Native);\n                toReturn.Add(toAdd);\n            }\n\n            return toReturn;\n        }\n    }\n}\n\ufeff```",
    "code_repairing_3": "'''\n    BUG: Redundant Select\n    MESSAGE: Writing 'seq.Select(e => e)' or 'from e in seq select e' is redundant.\n    FIXED CODE:\n    foreach (CSProjectInfo project in orderedProjects)\n'''\n\n\ufeff# Copyright (C) Microsoft Corporation. All rights reserved.\n\n\n#if UNITY_EDITOR\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing UnityEditor;\n\nnamespace Microsoft.MixedReality.Toolkit.MSBuild\n{\n    public class UnityProjectInfo\n    {\n        private static readonly HashSet<string> ExcludedPackageReferences = new HashSet<string>()\n        {\n            \"Windows.UI.Input.Spatial\"\n        };\n\n        public string UnityProjectName { get; }\n\n        internal IEnumerable<CompilationPlatformInfo> AvailablePlatforms { get; }\n\n        public IReadOnlyDictionary<string, CSProjectInfo> CSProjects { get; }\n\n        public IReadOnlyCollection<PluginAssemblyInfo> Plugins { get; }\n\n        public UnityProjectInfo(IEnumerable<CompilationPlatformInfo> availablePlatforms, string projectOutputPath)\n        {\n            AvailablePlatforms = availablePlatforms;\n\n            UnityProjectName = Application.productName;\n\n            if (string.IsNullOrWhiteSpace(UnityProjectName))\n            {\n                UnityProjectName = \"UnityProject\";\n            }\n\n            Plugins = new ReadOnlyCollection<PluginAssemblyInfo>(ScanForPluginDLLs());\n\n            foreach (PluginAssemblyInfo plugin in Plugins)\n            {\n                if (plugin.Type == PluginType.Native)\n                {\n                    Debug.Log($\"Native plugin {plugin.ReferencePath.AbsolutePath} not yet supported for MSBuild project.\");\n                }\n            }\n\n            CSProjects = new ReadOnlyDictionary<string, CSProjectInfo>(CreateUnityProjects(projectOutputPath));\n        }\n    }\n'''",
    "code_repairing_4": "foreach (CSProjectInfo project in orderedProjects)\n{\n\n    HashSet<string> configurationPlatformMappingEntries = new HashSet<string>();\n\n    foreach (Enumerator.csplatform platform in project.AvailablePlatforms)\n    {\n        configurationPlatformMappingEntries.Add(configurationPlatformMappingTemplate.Replace(\"<Platform>\", platform.GetParsableName().ToString()));\n    }\n\n    configurationMappings.AddRange(configurationPlatformMappingEntries);\n\n    configurationPlatformMappingEntries.Clear();\n\n    foreach (string configPlatform in configPlatforms)\n    {\n        disabled.Add(configurationPlatformEnabledTemplate.Replace(\"<Platform>\", platform.GetParsableName().ToString()));\n    }\n\n    disabled.Add(configurationPlatformEnabledTemplate.Replace(\"<Platform>\", platform.GetParsableName().ToString()));\n\n }\n\n                    StringBuilder toReturn = new StringBuilder();\n                    toReturn.AppendLine($\"Microsoft Visual Studio Solution File, Format Version {Utilities.VersionMajor}.00\");\n                    foreach (string projectEntry in projectEntries)\n                    {\n                        toReturn.AppendLine(projectEntry);\n                    }\n\n                    foreach (string configurationPlatformEntry in configurationPlatforms)\n                    {\n                        toReturn.AppendLine(configurationPlatformEntry);\n                    }\n\n                    foreach (string mappingEntry in configurationMappings)\n                    {\n                        toReturn.AppendLine(mappingEntry);\n                    }\n\n                    foreach (string configurationPlatformEnabled in disabled)\n                    {\n                        toReturn.AppendLine(configurationPlatformEnabled);\n                    }\n\n                    File.WriteAllText(solutionFilePath, toReturn.ToString());\n                }\n            }\n\n            public bool TryGetFullPath(string filename, out string fullPath)\n            {\n                if (Directory.Exists(filename))\n                {\n                    string fullpath = Path.GetFullPath(filename);\n\n                    // NOTE: 'is' operator\n                    if (fullpath.StartsWith(Utilities.ProjectPath) && fullpath.EndsWith(Utilities.ProjectName))\n                    {\n                        fullPath = fullpath;\n                        return true;\n                    }\n                    else\n                    {\n                        // BUG: Path.GetFullPathexists\n                        // MESSAGE: Name 'Path.GetFullPath' could not be found.\n                        if (File.Exists(fullpath))\n                        {\n                            fullPath = fullpath;\n                            return true;\n                        }\n                        else\n                        {\n                            fullPath = null;\n                            return false;\n                        }\n                    }\n                }\n                else\n                {\n                    fullPath = null;\n                    return false;\n                }\n            }\n\n\n\n            private string GetProjectEntry(CSProjectInfo projectInfo, string projectEntryTemplateBody)\n            {\n                StringBuilder toReturn = new StringBuilder();\n                toReturn.AppendLine(Utilities.ReplaceTokens(projectEntryTemplateBody, new Dictionary<string, string>() {\n                        { \"<PROJECT_NAME>\", projectInfo.Name },\n                        { \"<PROJECT_RELATIVE_PATH>\", Path.GetFileName(projectInfo.ReferencePath.AbsolutePath) },\n                        { \"<PROJECT_GUID>\", projectInfo.Guid.ToString().ToUpper() } }));\n                if (projectInfo.ProjectDependencies.Count > 0)\n                {\n                    string projectDependencyStartSection = \"    ProjectSection(ProjectDependencies) = postProject\";\n                    string projectDependencyGuid = \"        {<DependencyGuid>} = {<DependencyGuid>}\";\n                    string projectDependencyStopSection = \"    EndProjectSection\";\n                    toReturn.AppendLine(projectDependencyStartSection);\n\n                    foreach (CSProjectDependency<CSProjectInfo> project in projectInfo.ProjectDependencies)\n                    {\n                        toReturn.AppendLine(projectDependencyGuid.Replace(\"<DependencyGuid>\", project.Dependency.Guid.ToString().ToUpper()));\n                    }\n\n                    toReturn.AppendLine(projectDependencyStopSection);\n                }\n                toReturn.Append(\"EndProject\");\n                return toReturn.ToString();\n            }\n        }\n\n        public class AssemblyDefinitionInfo\n        {\n            public string ReferencePath { get; }\n\n            public bool IsEditorAssembly { get; }\n\n            public bool IsMainAssetAssembly { get; }\n\n            public bool GenerateCSharpSolution { get; }\n\n            public string AssemblyName { get; }\n\n            public HashSet<string> DependenciesPackages { get; }\n\n            public HashSet<string> Dependencies { get; }\n\n            public HashSet<string> AssemblyReferences { get; }\n\n            public HashSet<string> Defines { get; }\n\n            public bool BuiltInPackage { get; }\n\n            public bool AutoReferenced { get; }\n\n            public bool ExcludeFromParsing { get; }\n\n            public bool ForceInclude { get; }\n\n            public HashSet<string> EnablePlatforms { get; }\n\n            public HashSet<string> DisablePlatforms { get; }\n\n\n            internal AssemblyDefinitionInfo(string referencepath, string assemblyname, bool iseditorassembly, bool ismainassetassembly, bool generatecsprojects, bool builtinpackage, HashSet<string> assemblyreferences, HashSet<string> defines, bool autorreferenced, bool excludefromparsing, bool forceinclude, HashSet<string> enableplatforms, HashSet<string> disableplatforms)\n            {\n                ReferencePath = referencepath;\n                AssemblyName = assemblyname;\n                IsEditorAssembly = iseditorassembly;\n                IsMainAssetAssembly = ismainassetassembly;\n                GenerateCSharpSolution = generatecsprojects;\n                BuiltInPackage = builtinpackage;\n                AssemblyReferences = assemblyreferences;\n                Dependencies = new HashSet<string>();\n                DependenciesPackages = new HashSet<string>();\n                Defines = defines;\n                AutoReferenced = autorreferenced;\n                ExcludeFromParsing = excludefromparsing;\n                ForceInclude = forceinclude;\n                EnablePlatforms = enableplatforms;\n                DisablePlatforms = disableplatforms;\n            }\n\n            internal static AssemblyDefinitionInfo Parse(FileInfo fileInfo, UnityProjectInfo projectInfo, Assembly asm, bool generateCSharpSolution)\n            {\n                string unityPackageName = \"com.\" + fileInfo.Name.Split('.')[1].ToLowerInvariant() + \".v.\" + fileInfo.Name.Split('.')[2].ToLowerInvariant();\n                string unityVersion = fileInfo.Name.Split('.')[2].ToLowerInvariant();\n                string[] splittedName = fileInfo.Name.Split('.');\n                HashSet<string> assemblyReferences = new HashSet<string>(Utilities.GetReferencesFromAsmDef(asm));\n                HashSet<string> defines = new HashSet<string>(Utilities.GetDefinesFromAsmDef(asm));\n                bool isEditorAssembly, isMainAssetAssembly, autoReferenced, excludeFromParsing, forceInclude;\n                HashSet<string> enablePlatforms = new HashSet<string>();\n                HashSet<string> disablePlatforms = new HashSet<string>();\n\n                foreach (string define in defines.Where(t => t.StartsWith(\"ENABLE_\")))\n                {\n                    enablePlatforms.Add(define.Substring(7));\n                }\n\n                foreach (string define in defines.Where(t => t.StartsWith(\"DISABLE_\")))\n                {\n                    disablePlatforms.Add(define.Substring(8));\n                }\n\n                isEditorAssembly = defines.Contains(\"EDITOR\");\n                isMainAssetAssembly = defines.Contains(\"ANALYTICS\");\n                assemblyReferences.Remove(\"UnityEngine.Analytics.Tracker.dll\");\n\n                string assemblyName = \"Unity.\" + splittedName[1].ToLowerInvariant() + \".\" + splittedName[2].ToLowerInvariant();\n                bool builtInPackage = projectInfo.BuiltInPackagesWithoutSource.Contains(unityPackageName.ToLower());\n                bool autoReferencedInEditMode = assemblyReferences.Contains(\"UnityEditor.dll\") || assemblyReferences.Contains(\"UnityEngine.TestTools.dll\");\n                autoReferenced = builtInPackage && projectInfo.Mode == UnityBuildMode.Editor && autoReferencedInEditMode;\n                excludeFromParsing = includesExcludeFromParsing(asm);\n                forceInclude = includesForceInclude(asm);\n                return new AssemblyDefinitionInfo(fileInfo.FullName, assemblyName, isEditorAssembly, isMainAssetAssembly, generateCSharpSolution, builtInPackage, assemblyReferences, defines, autoReferenced, excludeFromParsing, forceInclude, enablePlatforms, disablePlatforms);\n            }\n\n\n\n            private bool includesExcludeFromParsing(Assembly asm)\n            {\n                CustomAttributeData[] customAttributes = asm.GetCustomAttributesData();\n\n                foreach (CustomAttributeData attr in customAttributes)\n                {\n                    if (attr.Constructor.DeclaringType.FullName == \"UnityEditor.ExcludeFromParsing\")\n                    {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n\n\n\n            private bool includesForceInclude(Assembly asm)\n            {\n                CustomAttributeData[] customAttributes = asm.GetCustomAttributesData();\n\n                foreach (CustomAttributeData attr in customAttributes)\n                {\n                    if (attr.Constructor.DeclaringType.FullName == \"UnityEditor.ForceInclude\")\n                    {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n        }\n\n        public class CSProjectInfo\n        {\n            public string ProjectName { get; }\n\n            public FileInfo ReferencePath { get; }\n\n            public Guid Guid { get; }\n\n            public HashSet<CSProjectDependency<CSProjectInfo>> ProjectDependencies { get; }\n\n            public IEnumerable<CompilationPlatformInfo> AvailablePlatforms { get; }\n\n            public string AsmDefPlatforms { get; }\n\n            public string CustomOutputPath { get; }\n\n            public CSharpCompilerFlags Flags { get; }\n\n\n            internal CSProjectInfo(UnityProjectInfo projectInfo, AssemblyDefinitionInfo assemblyDefinitionInfo, string projectOutputPath)\n            {\n\n\n\n\n                Guid = new Guid(assemblyDefinitionInfo.AssemblyName.Split('.')[1].ToUpperInvariant());\n                FileInfo referencePath = FileInfo.FromFileName(assemblyDefinitionInfo.ReferencePath);\n                ProjectName = referencePath.Name;\n                ReferencePath = referencePath;\n             availablePlatforms = assemblyDefinitionInfo.EnablePlatforms;\n             customoutputPath = projectOutputPath;\n             flags = new CSharpCompilerFlags(csprojectName, csprojectName.Split('.')[1].ToLowerInvariant(), projectOutputPath, assemblyDefinitionInfo.ExcludeFromParsing, assemblyDefinitionInfo.ForceInclude, assemblyDefinitionInfo.AutoReferenced);\n             projectDependencies = new HashSet<CSProjectDependency<CSProjectInfo>>();\n             projectDependencies.AddRange(assemblyDefinitionInfo.Dependencies.Select(t => new CSProjectDependency<CSProjectInfo>(t, null)));\n             projectDependencies.AddRange(assemblyDefinitionInfo.DependenciesPackages.Select(t => new CSProjectDependency<CSProjectInfo>(null, t)));\n             projectDependencies.AddRange(projectInfo.AvailablePlatforms.Select(t => new CSProjectDependency<CSProjectInfo>(t, null)));\n            }\n\n            internal static CSProjectInfo CreateUnityProject(UnityProjectInfo projectInfo, string projectOutputPath)\n            {\n                Assembly unityEngineAssembly = Assembly.Load(\"UnityEngine, Version=UnityEngine\");\n                string unityEngineAssemblyName = unityEngineAssembly.FullName;\n                string unityEngineName = unityEngineAssemblyName.Split(',')[0];\n                AssemblyDefinitionInfo assemblyDefinitionInfo = AssemblyDefinitionInfo.Parse(new FileInfo(Utilities.GetFullPathFromKnownRelative(Utilities.UnityEngineAssemblyPath)), projectInfo, unityEngineAssembly);\n                return new CSProjectInfo(projectInfo, assemblyDefinitionInfo, projectOutputPath);\n            }\n\n\n            public CSProjectInfo AddDependency(PluginAssemblyInfo pluginDependency)\n            {\n\n\n\n\n\n\n                if (pluginDependency.Type == PluginType.Native)\n                {\n                    throw new ArgumentException($\"Can't add a native plugin dependency: {pluginDependency.Name}\");\n                }\n\n                CSProjectInfo toReturn = new CSProjectInfo(projectInfo, projectDefinition, projectOutputPath);\n                toReturn.projectDependencies.Add(pluginDependency);\n                return toReturn;\n            }\n        }\n\n        public class PluginAssemblyInfo\n        {\n            public UnityProjectInfo projectInfo { get; }\n\n            public Guid Guid { get; }\n\n            public string ReferencePath { get; }\n\n            public string Name { get; }\n\n            public PluginType Type { get; }\n\n            internal PluginAssemblyInfo(UnityProjectInfo projectInfo, Guid guid, string referencePath, PluginType type)\n            {\n                this.projectInfo = projectiInfo;\n                Guid = guid;\n                ReferencePath = referencePath;\n                Name = Path.GetFileNameWithoutExtension(ReferencePath);\n                Type = type;\n            }\n        }\n\n        public class CSProjectDependency<TPlatform> where TPlatform : CompilationPlatformInfo\n        {\n            public TPlatform Dependency { get; }\n\n            public string Name { get; }\n\n            public CSProjectDependency(TPlatform dependency, string name)\n            {\n                Dependency = dependency;\n                Name = name;\n            }\n        }\n\n        public class CompilationPlatformInfo\n        {\n            public CompilationPlatformType Type { get; }\n\n            public string Name { get; }\n\n\n            internal CompilationPlatformInfo(CompilationPlatformType type, string name)\n            {\n                Type = type;\n                Name = name;\n            }\n\n\n            public bool Equals(CompilationPlatformInfo other)\n            {\n                if (ReferenceEquals(null, other))\n                {\n                    return false;\n                }\n\n                if (ReferenceEquals(this, other))\n                {\n                    return true;\n                }\n\n                return Type == other.Type && string.Equals(Name, other.Name);\n            }\n        }\n\n\n\n\n\n\n\n        public class Utilities\n        {\n            public static readonly DirectoryInfo UnityRootPath;\n\n            public static readonly DirectoryInfo AssetPath;\n\n            public static readonly DirectoryInfo PackagesCopyPath;\n\n            public const string BuiltInPackagesPath = \"Assets/MSBuild/builtin_packages\";\n\n            static Utilities()\n            {\n                UnityRootPath = new DirectoryInfo(Environment.CurrentDirectory).Parent;\n\n                AssetPath = new DirectoryInfo(Path.Combine(UnityRootPath.FullName, \"Assets\"));\n\n                PackagesCopyPath = new DirectoryInfo(Path.Combine(PluginImporter.GetDefaultReferencesPath(), \"MSBuild\"));\n            }\n\n            public static bool IsManagedAssembly(string assemblyName)\n            {\n                string managedAssembliesDirectory = Path.Combine(PluginImporter.GetDefaultReferencesPath(), \"Managed\");\n\n                if (assemblyName.EndsWith(\".framework\"))\n                {\n                    return false;\n                }\n\n                return File.Exists(Path.Combine(managedAssembliesDirectory, assemblyName));\n            }\n\n            public static string GetFullPathFromKnownRelative(string relativePath)\n            {\n                return Path.Combine(UnityProjectPath, relativePath);\n            }\n\n\n            public static string GetProjectPathFromFilePath(string filePath)\n            {\n                return GetFullPathFromKnownRelative(Path.GetDirectoryName(filePath));\n            }\n\n\n            public static string GetAssetsRelativePathFrom(string absolutePath)\n            {\n                absolutePath = Path.GetFullPath(absolutePath);\n\n                if (absolutePath.Contains(AssetPath.FullName))\n                {\n                    return absolutePath.Substring(AssetPath.FullName.Length);\n                }\n\n                else\n                {\n                    return absolutePath.Substring(ProjectPath.FullName.Length + 1);\n                }\n            }\n\n\n\n            public static IEnumerable<string> GetReferencesFromAsmDef(Assembly assembly)\n            {\n\n                return assembly.GetCustomAttributesData().Where(t => t.Constructor.DeclaringType.FullName == \"UnityEditor.References\");\n            }\n\n\n            public static IEnumerable<string> GetDefinesFromAsmDef(Assembly assembly)\n            {\n                return assembly.GetCustomAttributesData().Where(t => t.Constructor.DeclaringType.FullName == \"UnityEditor.Defines\");\n            }\n\n\n            public static bool TryGetTextTemplate(string template, string token, out string result, out string templateBody)\n            {\n                //Bug: Redundancy in variable name\n                //MESSAGE: Variable name 'token1' is redundant.\n                //Suggestion: Consider using abbreviation or removing unused variable\n                //Bug: Redundancy in variable name\n                //MESSAGE: Variable name 'result1' is redundant."
}