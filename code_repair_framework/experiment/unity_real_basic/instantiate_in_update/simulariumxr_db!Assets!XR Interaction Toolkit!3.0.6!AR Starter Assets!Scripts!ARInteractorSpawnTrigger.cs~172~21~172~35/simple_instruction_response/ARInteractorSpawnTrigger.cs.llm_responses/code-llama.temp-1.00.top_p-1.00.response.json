{
    "code_repairing_0": "//Here are the buggy code lines from /Assets/XR Interaction Toolkit/3.0.6/AR Starter Assets/Scripts/ARInteractorSpawnTrigger.cs:\n\n#if AR_FOUNDATION_PRESENT\nusing UnityEngine.EventSystems;\nusing UnityEngine.XR.ARFoundation;\nusing UnityEngine.XR.ARSubsystems;\nusing UnityEngine.XR.Interaction.Toolkit.Inputs.Readers;\nusing UnityEngine.XR.Interaction.Toolkit.Interactors;\nusing UnityEngine.XR.Interaction.Toolkit.Samples.StarterAssets;\n\nnamespace UnityEngine.XR.Interaction.Toolkit.Samples.ARStarterAssets\n{\n\n\n\n    public class ARInteractorSpawnTrigger : MonoBehaviour\n    {\n\n\n\n        public enum SpawnTriggerType\n        {\n\n\n\n\n            SelectAttempt,\n\n\n\n\n            InputAction,\n        }\n\n        [SerializeField]\n        [Tooltip(\"The AR ray interactor that determines where to spawn the object.\")]\n        XRRayInteractor m_ARInteractor;\n\n\n\n\n        public XRRayInteractor arInteractor\n        {\n            get => m_ARInteractor;\n            set => m_ARInteractor = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The behavior to use to spawn objects.\")]\n        ObjectSpawner m_ObjectSpawner;\n\n\n\n\n        public ObjectSpawner objectSpawner\n        {\n            get => m_ObjectSpawner;\n            set => m_ObjectSpawner = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"Whether to require that the AR Interactor hits an AR Plane with a horizontal up alignment in order to spawn anything.\")]\n        bool m_RequireHorizontalUpSurface;\n\n\n\n\n\n        public bool requireHorizontalUpSurface\n        {\n            get => m_RequireHorizontalUpSurface;\n            set => m_RequireHorizontalUpSurface = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The type of trigger to use to spawn an object, either when the Interactor's select action occurs or \" +\n            \"when a button input is performed.\")]\n        SpawnTriggerType m_SpawnTriggerType;\n\n\n\n        public SpawnTriggerType spawnTriggerType\n        {\n            get => m_SpawnTriggerType;\n            set => m_SpawnTriggerType = value;\n        }\n\n        [SerializeField]\n        XRInputButtonReader m_SpawnObjectInput = new XRInputButtonReader(\"Spawn Object\");\n\n\n\n\n        public XRInputButtonReader spawnObjectInput\n        {\n            get => m_SpawnObjectInput;\n            set => XRInputReaderUtility.SetInputProperty(ref m_SpawnObjectInput, value, this);\n        }\n\n        [SerializeField]\n        [Tooltip(\"When enabled, spawn will not be triggered if an object is currently selected.\")]\n        bool m_BlockSpawnWhenInteractorHasSelection = true;\n\n\n\n\n        public bool blockSpawnWhenInteractorHasSelection\n        {\n            get => m_BlockSpawnWhenInteractorHasSelection;\n            set => m_BlockSpawnWhenInteractorHasSelection = value;\n        }\n\n        bool m_AttemptSpawn;\n        bool m_EverHadSelection;\n\n\n\n\n        void OnEnable()\n        {\n            m_SpawnObjectInput.EnableDirectActionIfModeUsed();\n        }\n\n\n\n\n        void OnDisable()\n        {\n            m_SpawnObjectInput.DisableDirectActionIfModeUsed();\n        }\n\n\n\n\n        void Start()\n        {\n            if (m_ObjectSpawner == null)\n\n#if UNITY_2023_1_OR_NEWER\n                m_ObjectSpawner = FindAnyObjectByType<ObjectSpawner>();\n#else\n                m_ObjectSpawner = FindObjectOfType<ObjectSpawner>();\n#endif\n\n            if (m_ARInteractor == null)\n            {\n                Debug.LogError(\"Missing AR Interactor reference, disabling component.\", this);\n                enabled = false;\n            }\n        }\n\n\n\n\n\n\n//        void Update()\n//        {\n//\n//\n//\n//            if (m_AttemptSpawn)\n//            {\n//                m_AttemptSpawn = false;\n//\n//\n//                var isPointerOverUI = EventSystem.current != null && EventSystem.current.IsPointerOverGameObject(-1);\n//                if (!isPointerOverUI && m_ARInteractor.TryGetCurrentARRaycastHit(out var arRaycastHit))\n//                {\n//                    if (!(arRaycastHit.trackable is ARPlane arPlane))\n//                        return;\n//\n//                    if (m_RequireHorizontalUpSurface && arPlane.alignment != PlaneAlignment.HorizontalUp)\n//                        return;\n//\n//                    m_ObjectSpawner.TrySpawnObject(arRaycastHit.pose.position, arPlane.normal);\n//                }\n//\n//                return;\n//            }\n//\n//            var selectState = m_ARInteractor.logicalSelectState;\n//\n//            if (m_BlockSpawnWhenInteractorHasSelection)\n//            {\n//                if (selectState.wasPerformedThisFrame)\n//                    m_EverHadSelection = m_ARInteractor.hasSelection;\n//                else if (selectState.active)\n//                    m_EverHadSelection |= m_ARInteractor.hasSelection;\n//            }\n//\n//            m_AttemptSpawn = false;\n//            switch (m_SpawnTriggerType)\n//            {\n//                case SpawnTriggerType.SelectAttempt:\n//                    if (selectState.wasCompletedThisFrame)\n//                        m_AttemptSpawn = !m_ARInteractor.hasSelection && !m_EverHadSelection;\n//                    break;\n//\n//                case SpawnTriggerType.InputAction:\n//                    if (m_SpawnObjectInput.ReadWasPerformedThisFrame())\n//                        m_AttemptSpawn = !m_ARInteractor.hasSelection && !m_EverHadSelection;\n//                    break;\n//            }\n//        }\n//Here's the definition of function call in another component.\n//Related code from /Assets/XR Interaction Toolkit/3.0.6/Starter Assets/Scripts/ObjectSpawner.cs:\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine.XR.Interaction.Toolkit.Utilities;\n\nnamespace UnityEngine.XR.Interaction.Toolkit.Samples.StarterAssets\n{\n\n\n\n    public class ObjectSpawner : MonoBehaviour\n    {\n        [SerializeField]\n        [Tooltip(\"The camera that objects will face when spawned. If not set, defaults to the main camera.\")]\n        Camera m_CameraToFace;\n\n\n\n\n        public Camera cameraToFace\n        {\n            get\n            {\n                EnsureFacingCamera();\n                return m_CameraToFace;\n            }\n            set => m_CameraToFace = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The list of prefabs available to spawn.\")]\n        List<GameObject> m_ObjectPrefabs = new List<GameObject>();\n\n\n\n\n        public List<GameObject> objectPrefabs\n        {\n            get => m_ObjectPrefabs;\n            set => m_ObjectPrefabs = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"Optional prefab to spawn for each spawned object. Use a prefab with the Destroy Self component to make \" +\n            \"sure the visualization only lives temporarily.\")]\n        GameObject m_SpawnVisualizationPrefab;\n\n\n\n\n\n        public GameObject spawnVisualizationPrefab\n        {\n            get => m_SpawnVisualizationPrefab;\n            set => m_SpawnVisualizationPrefab = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The index of the prefab to spawn. If outside the range of the list, this behavior will select \" +\n            \"a random object each time it spawns.\")]\n        int m_SpawnOptionIndex = -1;\n\n\n\n\n\n        public int spawnOptionIndex\n        {\n            get => m_SpawnOptionIndex;\n            set => m_SpawnOptionIndex = value;\n        }\n\n\n\n\n\n        public bool isSpawnOptionRandomized => m_SpawnOptionIndex < 0 || m_SpawnOptionIndex >= m_ObjectPrefabs.Count;\n\n        [SerializeField]\n        [Tooltip(\"Whether to only spawn an object if the spawn point is within view of the camera.\")]\n        bool m_OnlySpawnInView = true;\n\n\n\n\n        public bool onlySpawnInView\n        {\n            get => m_OnlySpawnInView;\n            set => m_OnlySpawnInView = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The size, in viewport units, of the periphery inside the viewport that will not be considered in view.\")]\n        float m_ViewportPeriphery = 0.15f;\n\n\n\n\n        public float viewportPeriphery\n        {\n            get => m_ViewportPeriphery;\n            set => m_ViewportPeriphery = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"When enabled, the object will be rotated about the y-axis when spawned by Spawn Angle Range, \" +\n            \"in relation to the direction of the spawn point to the camera.\")]\n        bool m_ApplyRandomAngleAtSpawn = true;\n\n\n\n\n\n        public bool applyRandomAngleAtSpawn\n        {\n            get => m_ApplyRandomAngleAtSpawn;\n            set => m_ApplyRandomAngleAtSpawn = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The range in degrees that the object will randomly be rotated about the y axis when spawned, \" +\n            \"in relation to the direction of the spawn point to the camera.\")]\n        float m_SpawnAngleRange = 45f;\n\n\n\n\n\n        public float spawnAngleRange\n        {\n            get => m_SpawnAngleRange;\n            set => m_SpawnAngleRange = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"Whether to spawn each object as a child of this object.\")]\n        bool m_SpawnAsChildren;\n\n\n\n\n        public bool spawnAsChildren\n        {\n            get => m_SpawnAsChildren;\n            set => m_SpawnAsChildren = value;\n        }\n\n\n\n\n\n        public event Action<GameObject> objectSpawned;\n\n\n\n\n        void Awake()\n        {\n            EnsureFacingCamera();\n        }\n\n        void EnsureFacingCamera()\n        {\n            if (m_CameraToFace == null)\n                m_CameraToFace = Camera.main;\n        }\n\n\n\n\n\n\n        public void RandomizeSpawnOption()\n        {\n            m_SpawnOptionIndex = -1;\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//        public bool TrySpawnObject(Vector3 spawnPoint, Vector3 spawnNormal)\n//        {\n//            if (transform.childCount > 0)\n//            {\n//                return false;\n//            }\n//            \n//            if (m_OnlySpawnInView)\n//            {\n//                var inViewMin = m_ViewportPeriphery;\n//                var inViewMax = 1f - m_ViewportPeriphery;\n//                var pointInViewportSpace = cameraToFace.WorldToViewportPoint(spawnPoint);\n//                if (pointInViewportSpace.z < 0f || pointInViewportSpace.x > inViewMax || pointInViewportSpace.x < inViewMin ||\n//                    pointInViewportSpace.y > inViewMax || pointInViewportSpace.y < inViewMin)\n//                {\n//                    return false;\n//                }\n//            }\n//\n//            var objectIndex = isSpawnOptionRandomized ? Random.Range(0, m_ObjectPrefabs.Count) : m_SpawnOptionIndex;\n//            var newObject = Instantiate(m_ObjectPrefabs[objectIndex]);\n//            if (m_SpawnAsChildren)\n//                newObject.transform.parent = transform;\n//\n//            newObject.transform.position = spawnPoint;\n//            EnsureFacingCamera();\n//\n//            var facePosition = m_CameraToFace.transform.position;\n//            var forward = facePosition - spawnPoint;\n//            BurstMathUtility.ProjectOnPlane(forward, spawnNormal, out var projectedForward);\n//            newObject.transform.rotation = Quaternion.LookRotation(projectedForward, spawnNormal);\n//\n//            if (m_ApplyRandomAngleAtSpawn)\n//            {\n//                var randomRotation = Random.Range(-m_SpawnAngleRange, m_SpawnAngleRange);\n//                newObject.transform.Rotate(Vector3.up, randomRotation);\n//            }\n//\n//            if (m_SpawnVisualizationPrefab != null)\n//            {\n//                var visualizationTrans = Instantiate(m_SpawnVisualizationPrefab).transform;\n//                visualizationTrans.position = spawnPoint;\n//                visualizationTrans.rotation = newObject.transform.rotation;\n//            }\n//\n//            objectSpawned?.Invoke(newObject);\n//            return true;\n//        }\n// FIXED CODE\n\nnamespace UnityEngine.XR.Interaction.Toolkit\n{\n\n{\n    // FIXED CODE\n\n\n    [Serializable]\n    public class ARInteractorSpawnTrigger : MonoBehaviour\n    {\n        [SerializeField]\n        protected GameObject m_CurrentPrefab;\n\n        [SerializeField]\n        protected ARPlaneManager m_Manager;\n\n        [SerializeField]\n        ARRaycastManager m_RaycastManager;\n\n        [SerializeField, Tooltip(\"The AR ray interactor that determines where to spawn the object.\")]\n\n        // FIXED CODE FOR ARInteractorSpawnTrigger\n\n        XRRayInteractor m_ARInteractor;\n\n\n        // FIXED CODE\n    }\n}\n\nnamespace UnityEngine.XR.Interaction.Toolkit.Samples.ARQuest\n{\n\n{\n    // FIXED CODE\n\n\n    [Serializable]\n    public class QuestManager : MonoBehaviour\n    {\n        [SerializeField]\n        [Tooltip(\"The AR ray interactor that determines where to spawn the quest trigger.\")]\n\n        // FIXED CODE FOR QuestManager\n\n        XRRayInteractor m_ARInteractor;\n\n\n        // FIXED CODE\n    }\n}\n\nnamespace UnityEngine.XR.Interaction.Toolkit.Samples.ARQuest\n\n{",
    "code_repairing_1": "Here's the fixed code snippet for the `TrySpawnObject` method:\n\n\n\n\n```\n public bool TrySpawnObject(Vector3 spawnPoint, Vector3 spawnNormal)\n        {\n            if (m_OnlySpawnInView)\n            {\n                var inViewMin = m_ViewportPeriphery;\n                var inViewMax = 1f - m_ViewportPeriphery;\n                var pointInViewportSpace = cameraToFace.WorldToViewportPoint(spawnPoint);\n                if (pointInViewportSpace.z < 0f || pointInViewportSpace.x > inViewMax || pointInViewportSpace.x < inViewMin ||\n                    pointInViewportSpace.y > inViewMax || pointInViewportSpace.y < inViewMin)\n                {\n                    return false;\n                }\n            }\n\n            if (m_SpawnAsChildren)\n            {\n                var newObject = Instantiate(m_ObjectPrefabs[m_SpawnOptionIndex], transform);\n                newObject.transform.position = spawnPoint;\n                EnsureFacingCamera();\n\n                var facePosition = m_CameraToFace.transform.position;\n                var forward = facePosition - spawnPoint;\n                BurstMathUtility.ProjectOnPlane(forward, spawnNormal, out var projectedForward);\n                newObject.transform.rotation = Quaternion.LookRotation(projectedForward, spawnNormal);\n\n                if (m_SpawnVisualizationPrefab != null)\n                {\n                    var visualizationTrans = Instantiate(m_SpawnVisualizationPrefab).transform;\n                    visualizationTrans.position = spawnPoint;\n                    visualizationTrans.rotation = newObject.transform.rotation;\n                }\n\n                objectSpawned?.Invoke(newObject);\n                return true;\n            }\n            else\n            {\n                var newObject = Instantiate(m_ObjectPrefabs[m_SpawnOptionIndex]);\n                newObject.transform.position = spawnPoint;\n                EnsureFacingCamera();\n\n                var facePosition = m_CameraToFace.transform.position;\n                var forward = facePosition - spawnPoint;\n                BurstMathUtility.ProjectOnPlane(forward, spawnNormal, out var projectedForward);\n                newObject.transform.rotation = Quaternion.LookRotation(projectedForward, spawnNormal);\n\n                if (m_SpawnVisualizationPrefab != null)\n                {\n                    var visualizationTrans = Instantiate(m_SpawnVisualizationPrefab).transform;\n                    visualizationTrans.position = spawnPoint;\n                    visualizationTrans.rotation = newObject.transform.rotation;\n                }\n\n                objectSpawned?.Invoke(newObject);\n                return true;\n            }\n        }\n```\n \n\nNow, the code should work properly.",
    "code_repairing_2": "```\n\n//Here's the updated code from /Assets/XR Interaction Toolkit/3.0.6/AR Starter Assets/Scripts/ARInteractorSpawnTrigger.cs that resolved the issue:\n\n```\n\nusing UnityEngine;\nusing System;\n\npublic class ARInteractorSpawnTrigger : MonoBehaviour\n{\n    [SerializeField]\n    [Tooltip(\"The AR ray interactor that determines where to spawn the object.\")]\n    XRRayInteractor m_ARInteractor;\n\n    public XRRayInteractor arInteractor\n    {\n        get\n        {\n            if (m_ARInteractor == null)\n            {\n                Debug.LogError(\"Missing AR Interactor reference, disabling component.\", this);\n                enabled = false;\n            }\n            return m_ARInteractor;\n        }\n        set\n        {\n            m_ARInteractor = value\n        }\n    }\n\n    [SerializeField]\n    [Tooltip(\"The behavior to use to spawn objects.\")]\n    ObjectSpawner m_ObjectSpawner;\n\n    public ObjectSpawner objectSpawner\n    {\n        get\n        {\n            if (m_ObjectSpawner == null)\n            {\n                Debug.LogError(\"Missing Object Spawner reference, disabling component.\", this);\n                enabled = false;\n            }\n            return m_ObjectSpawner;\n        }\n        set\n        {\n            m_ObjectSpawner = value;\n        }\n    }\n\n    [SerializeField]\n    [Tooltip(\"Whether to require that the AR Interactor hits an AR Plane with a horizontal up alignment in order to spawn anything.\")]\n    bool m_RequireHorizontalUpSurface;\n\n    public bool requireHorizontalUpSurface\n    {\n        get\n        {\n            return m_RequireHorizontalUpSurface;\n        }\n        set\n        {\n            m_RequireHorizontalUpSurface = value;\n        }\n    }\n\n    [SerializeField]\n    XRInputButtonReader m_SpawnObjectInput = new XRInputButtonReader(\"Spawn Object\");\n\n    public XRInputButtonReader spawnObjectInput\n    {\n        get\n        {\n            return m_SpawnObjectInput;\n        }\n        set\n        {\n            XRInputReader Utity.SetInputProperty(ref m_SpawnObjectInput, value, this);\n        }\n    }\n\n    [SerializeField]\n    [Tooltip(\"When enabled, spawn will not be triggered if an object is currently selected.\")]\n    bool m_BlockSpawnWhenInteractorHasSelection = true;\n\n    public bool blockSpawnWhenInteractorHasSelection\n    {\n        get\n        {\n            return m_BlockSpawnWhenInteractorHasSelection;\n        }\n        set\n        {\n            m_BlockSpawnWhenInteractorHasSelection = value;\n        }\n    }\n\n    bool m_AttemptSpawn;\n    bool m_EverHadSelection;\n\n    void OnEnable()\n    {\n        m_SpawnObjectInput.EnableDirectActionIfModeUsed();\n    }\n\n    void OnDisable()\n    {\n        m_SpawnObjectInput.DisableDirectActionIfModeUsed();\n    }\n\n    void Start()\n    {\n        if (m_ObjectSpawner == null)\n        {\n            #if UNITY_2023_1_OR_NEWER\n             m_ObjectSpawner = FindAnyObjectByType<ObjectSpawner>();\n             #else\n             m_ObjectSpawner = FindObjectOfType<ObjectSpawner>();\n             #endif\n\n        if (m_ARInteractor == null)\n    {\n        Debug.LogError(\"Missing AR Interactor reference, disabling component.\", this);\n        enabled = false;\n    }\n}\n}\n\nvoid Update()\n{\n    if (m_AttemptSpawn)\n    {\n        m_AttemptSpawn = false;\n\n        var isPointerOverUI = EventSystem.current != null && EventSystem.current.IsPointerOverGameObject(-1);\n        if (!isPointerOverUI && m_ARInteractor.TryGetCurrentARRaycastHit(out var arRaycastHit))\n        {\n            if (!(arRaycastHit.trackable is ARPlane arPlane))\n                return;\n\n            if (m_RequireHorizontalUpSurface && arPlane.alignment != PlaneAlignment.HorizontalUp)\n                return;\n\n            m_ObjectSpawner. TrySpawnObject(arRaycastHit.pose.position, arPlane.normal);\n            }\n    }\n\n    var selectState = m_ARInteractor.logicalSelectState;\n\n    if (m_BlockSpawnWhenInteractorHasSelection)\n    {\n        if (selectState.wasPerformedThisFrame)\n            m_EverHadSelection = m_ARInteractor.hasSelection;\n        else if (selectState.active)\n            m_EverHadSelection |= m_ARInteractor.hasSelection;\n    }\n\n    m_AttemptSpawn = false;\n    switch (m_SpawnTriggerType)\n    {\n        m_SpawnObjectInput.ReadWasPerformedThisFrame(),m_AttemptSpawn = !m_ARInteractor.hasSelection && !m_EverHadSelection;\n    }\n}\n\n}\n\n```\nI hope this updated code helps you fix the issue in your project.",
    "code_repairing_3": "```\n using UnityEngine.EventSystems;\nusing UnityEngine.XR.ARFoundation;\nusing UnityEngine.XR.ARSubsystems;\nusing UnityEngine.XR.Inputs.Readers;\nusing UnityEngine.XR.Interactions;\nusing UnityEngine.XR.Interaction.Toolkit/Samples/StarterAssets;\n\nnamespace UnityEngine.XR. Interaction.Toolkit.Samples/ARStarterAssets\n{\n  using System;\n  using System.Collections.Generic;\n  using UnityEngine.XR.Interaction.Toolkit;\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}\n```",
    "code_repairing_4": "There are several issues with the code you provided:\n\n1. The `ARInteractorSpawnTrigger` script is using the `using` statement for the `UnityEngine.XR.ARFoundation` namespace, but it is not actually using any types from this namespace. Therefore, the `using` statement is unnecessary and can be removed.\n2. The `SpawnTriggerType` enum is redundant and can be removed.\n3. The `objectSpawner` property should be replaced with a `SerializeField` attribute on the `m_ObjectSpawner` field, and the getter and setter methods should be removed.\n4. The `arInteractor` property should be replaced with a `SerializeField` attribute on the `m_ARInteractor` field, and the getter and setter methods should be removed.\n5. The `requireHorizontalUpSurface` property should be replaced with a `SerializeField` attribute on the `m_RequireHorizontalUpSurface` field, and the getter and setter methods should be removed.\n6. The `spawnTriggerType` property should be replaced with a `SerializeField` attribute on the `m_SpawnTriggerType` field, and the getter and setter methods should be removed.\n7. The `spawnObjectInput` property should be replaced with a `SerializeField` attribute on the `m_SpawnObjectInput` field, and the getter and setter methods should be removed.\n8. The `blockSpawnWhenInteractorHasSelection` property should be replaced with a `SerializeField` attribute on the `m_BlockSpawnWhenInteractorHasSelection` field, and the getter and setter methods should be removed.\n9. The `Start()` method is using the `FindAnyObjectByType` method from the `UnityEngine.XR.Interaction.Toolkit.Utilities` namespace, but it is not being used anywhere in the code. Therefore, the `using` statement for this namespace is unnecessary and can be removed.\n10. The `Update()` method is using variables that are not defined, such as `m_EverHadSelection` and `m_AttemptSpawn`. Therefore, these variables should be defined and used correctly in the code.\n11. The `TrySpawnObject()` method is using variables that are not defined, such as `spawnPoint` and `spawnNormal`. Therefore, these variables should be defined and used correctly in the code.\n\nHere is an example of how the code could be fixed:\n```\nusing UnityEngine.EventSystems;\nusing UnityEngine.XR.ARFoundation;\nusing UnityEngine.XR.ARSubsystems;\nusing UnityEngine.XR.Interaction.Toolkit.Inputs.Readers;\nusing UnityEngine.XR.Interaction.Toolkit.Interactors;\nusing UnityEngine.XR.Interaction.Toolkit.Samples.StarterAssets;\n\nnamespace UnityEngine.XR.Interaction.Toolkit.Samples.ARStarterAssets\n{\n\n\n\n    public class ARInteractorSpawnTrigger : MonoBehaviour\n    {\n\n\n\n        [SerializeField]\n        [Tooltip(\"The AR ray interactor that determines where to spawn the object.\")]\n        XRRayInteractor m_ARInteractor;\n\n        public XRRayInteractor arInteractor\n        {\n            get => m_ARInteractor;\n            set => m_ARInteractor = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The behavior to use to spawn objects.\")]\n        ObjectSpawner m_ObjectSpawner;\n\n        public ObjectSpawner objectSpawner\n        {\n            get => m_ObjectSpawner;\n            set => m_ObjectSpawner = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"Whether to require that the AR Interactor hits an AR Plane with a horizontal up alignment in order to spawn anything.\")]\n        bool m_RequireHorizontalUpSurface;\n\n        public bool requireHorizontalUpSurface\n        {\n            get => m_RequireHorizontalUpSurface;\n            set => m_RequireHorizontalUpSurface = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"The type of trigger to use to spawn an object, either when the Interactor's select action occurs or \" +\n            \"when a button input is performed.\")]\n        SpawnTriggerType m_SpawnTriggerType;\n\n        public SpawnTriggerType spawnTriggerType\n        {\n            get => m_SpawnTriggerType;\n            set => m_SpawnTriggerType = value;\n        }\n\n        [SerializeField]\n        XRInputButtonReader m_SpawnObjectInput = new XRInputButtonReader(\"Spawn Object\");\n\n        public XRInputButtonReader spawnObjectInput\n        {\n            get => m_SpawnObjectInput;\n            set => XRInputReaderUtility.SetInputProperty(ref m_SpawnObjectInput, value, this);\n        }\n\n        [SerializeField]\n        [Tooltip(\"When enabled, spawn will not be triggered if an object is currently selected.\")]\n        bool m_BlockSpawnWhenInteractorHasSelection = true;\n\n        public bool blockSpawnWhenInteractorHasSelection\n        {\n            get => m_BlockSpawnWhenInteractorHasSelection;\n            set => m_BlockSpawnWhenInteractorHasSelection = value;\n        }\n\n        bool m_AttemptSpawn;\n        bool m_EverHadSelection;\n\n\n\n\n        void OnEnable()\n        {\n            m_SpawnObjectInput.EnableDirectActionIfModeUsed();\n        }\n\n\n\n\n        void OnDisable()\n        {\n            m_SpawnObjectInput.DisableDirectActionIfModeUsed();\n        }\n\n\n\n\n        void Start()\n        {\n            if (m_ObjectSpawner == null)\n#if UNITY_2023_1_OR_NEWER\n                m_ObjectSpawner = FindAnyObjectByType<ObjectSpawner>();\n#else\n                m_ObjectSpawner = FindObjectOfType<ObjectSpawner>();\n#endif\n\n            if (m_ARInteractor == null)\n            {\n                Debug.LogError(\"Missing AR Interactor reference, disabling component.\", this);\n                enabled = false;\n            }\n        }\n\n\n\n\n        void Update()\n        {\n\n\n\n            if (m_AttemptSpawn)\n            {\n                m_AttemptSpawn = false;\n\n\n\n                var isPointerOverUI = EventSystem.current != null && EventSystem.current.IsPointerOverGameObject(-1);\n                if (!isPointerOverUI && m_ARInteractor.TryGetCurrentARRaycastHit(out var arRaycastHit))\n                {\n                    if (!(arRaycastHit.trackable is ARPlane arPlane))\n                        return;\n\n                    if (m_RequireHorizontalUpSurface && arPlane.alignment != PlaneAlignment.HorizontalUp)\n                        return;\n\n                    m_ObjectSpawner.TrySpawnObject(arRaycastHit.pose.position, arPlane.normal);\n                }\n\n                return;\n            }\n\n            var selectState = m_ARInteractor.logicalSelectState;\n\n            if (m_BlockSpawnWhenInteractorHasSelection)\n            {\n                if (selectState.wasPerformedThisFrame)\n                    m_EverHadSelection = m_ARInteractor.hasSelection;\n                else if (selectState.active)\n                    m_EverHadSelection |= m_ARInteractor.hasSelection;\n            }\n\n            m_AttemptSpawn = false;\n            switch (m_SpawnTriggerType)\n            {\n                case SpawnTriggerType.SelectAttempt:\n                    if (selectState.wasCompletedThisFrame)\n                        m_AttemptSpawn = !m_ARInteractor.hasSelection && !m_EverHadSelection;\n                    break;\n\n                case SpawnTriggerType.InputAction:\n                    if (m_SpawnObjectInput.ReadWasPerformedThisFrame())\n                        m_AttemptSpawn = !m_ARInteractor.hasSelection && !m_EverHadSelection;\n                    break;\n            }\n        }\n    }\n}\n```\nYou will need to review the rest of the code to ensure that it is correct and working as intended."
}