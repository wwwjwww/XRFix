"{\"id\":\"chatcmpl-BpvYfOMit3JmWNeq81d7B2usWDb26\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System;\\nusing UnityEngine;\\nusing System.Collections.Generic;\\nusing System.Threading;\\nusing UnityEngine.Rendering;\\nusing Object = UnityEngine.Object;\\nusing UnityEngine.Rendering.Universal;\\n\\n// Fixed instantiate in RefreshCameraRig method instead of Update method.\\nprivate void RefreshCameraObjects(GameObject parentObject, Camera mainCamera,\\n    OVRMixedRealityCaptureConfiguration configuration)\\n{\\n    if (mainCamera.gameObject != previousMainCameraObject)\\n    {\\n        Debug.LogFormat(\\\"[OVRExternalComposition] Camera refreshed. Rebind camera to {0}\\\",\\n            mainCamera.gameObject.name);\\n\\n        OVRCompositionUtil.SafeDestroy(ref backgroundCameraGameObject);\\n        backgroundCamera = null;\\n        OVRCompositionUtil.SafeDestroy(ref foregroundCameraGameObject);\\n        foregroundCamera = null;\\n\\n        RefreshCameraRig(parentObject, mainCamera);\\n\\n        Debug.Assert(backgroundCameraGameObject == null);\\n        if (backgroundCameraGameObjectPool.ContainsKey(mainCamera.gameObject))\\n        {\\n            backgroundCameraGameObject = backgroundCameraGameObjectPool[mainCamera.gameObject];\\n        }\\n        else\\n        {\\n            if (configuration.instantiateMixedRealityCameraGameObject != null)\\n            {\\n                backgroundCameraGameObject =\\n                    configuration.instantiateMixedRealityCameraGameObject(mainCamera.gameObject,\\n                        OVRManager.MrcCameraType.Background);\\n            }\\n            else\\n            {\\n                backgroundCameraGameObject = Object.Instantiate(mainCamera.gameObject);\\n                backgroundCameraGameObjectPool[mainCamera.gameObject] = backgroundCameraGameObject;\\n            }\\n        }\\n\\n        backgroundCameraGameObject.name = \\\"OculusMRC_BackgroundCamera\\\";\\n        backgroundCameraGameObject.transform.parent =\\n            cameraInTrackingSpace ? cameraRig.trackingSpace : parentObject.transform;\\n        if (backgroundCameraGameObject.GetComponent<AudioListener>())\\n        {\\n            Object.Destroy(backgroundCameraGameObject.GetComponent<AudioListener>());\\n        }\\n\\n        if (backgroundCameraGameObject.GetComponent<OVRManager>())\\n        {\\n            Object.Destroy(backgroundCameraGameObject.GetComponent<OVRManager>());\\n        }\\n\\n        backgroundCamera = backgroundCameraGameObject.GetComponent<Camera>();\\n        backgroundCamera.tag = \\\"Untagged\\\";\\n#if USING_MRC_COMPATIBLE_URP_VERSION\\n        var backgroundCamData = backgroundCamera.GetUniversalAdditionalCameraData();\\n        if (backgroundCamData != null)\\n        {\\n            backgroundCamData.allowXRRendering = false;\\n        }\\n#elif USING_URP\\n        Debug.LogError(\\\"Using URP with MRC is only supported with URP version 10.0.0 or higher. Consider using Unity 2020 or higher.\\\");\\n#else\\n        backgroundCamera.stereoTargetEye = StereoTargetEyeMask.None;\\n#endif\\n        backgroundCamera.depth = 99990.0f;\\n        backgroundCamera.rect = new Rect(0.0f, 0.0f, 0.5f, 1.0f);\\n        backgroundCamera.cullingMask = (backgroundCamera.cullingMask & ~configuration.extraHiddenLayers) |\\n                                        configuration.extraVisibleLayers;\\n#if OVR_ANDROID_MRC\\n        backgroundCamera.targetTexture = mrcRenderTextureArray[0];\\n        if (!renderCombinedFrame)\\n        {\\n            backgroundCamera.rect = new Rect(0.0f, 0.0f, 1.0f, 1.0f);\\n        }\\n#endif\\n\\n        Debug.Assert(foregroundCameraGameObject == null);\\n        if (foregroundCameraGameObjectPool.ContainsKey(mainCamera.gameObject))\\n        {\\n            foregroundCameraGameObject = foregroundCameraGameObjectPool[mainCamera.gameObject];\\n        }\\n        else\\n        {\\n            if (configuration.instantiateMixedRealityCameraGameObject != null)\\n            {\\n                foregroundCameraGameObject =\\n                    configuration.instantiateMixedRealityCameraGameObject(mainCamera.gameObject,\\n                        OVRManager.MrcCameraType.Foreground);\\n            }\\n            else\\n            {\\n                foregroundCameraGameObject = Object.Instantiate(mainCamera.gameObject);\\n                foregroundCameraGameObjectPool[mainCamera.gameObject] = foregroundCameraGameObject;\\n            }\\n        }\\n\\n        foregroundCameraGameObject.name = \\\"OculusMRC_ForgroundCamera\\\";\\n        foregroundCameraGameObject.transform.parent =\\n            cameraInTrackingSpace ? cameraRig.trackingSpace : parentObject.transform;\\n        if (foregroundCameraGameObject.GetComponent<AudioListener>())\\n        {\\n            Object.Destroy(foregroundCameraGameObject.GetComponent<AudioListener>());\\n        }\\n\\n        if (foregroundCameraGameObject.GetComponent<OVRManager>())\\n        {\\n            Object.Destroy(foregroundCameraGameObject.GetComponent<OVRManager>());\\n        }\\n\\n        foregroundCamera = foregroundCameraGameObject.GetComponent<Camera>();\\n        foregroundCamera.tag = \\\"Untagged\\\";\\n#if USING_MRC_COMPATIBLE_URP_VERSION\\n        var foregroundCamData = foregroundCamera.GetUniversalAdditionalCameraData();\\n        if (foregroundCamData != null)\\n        {\\n            foregroundCamData.allowXRRendering = false;\\n        }\\n#elif USING_URP\\n        Debug.LogError(\\\"Using URP with MRC is only supported with URP version 10.0.0 or higher. Consider using Unity 2020 or higher.\\\");\\n#else\\n        foregroundCamera.stereoTargetEye = StereoTargetEyeMask.None;\\n#endif\\n        foregroundCamera.depth =\\n            backgroundCamera.depth + 1.0f; // enforce the forground be rendered after the background\\n        foregroundCamera.rect = new Rect(0.5f, 0.0f, 0.5f, 1.0f);\\n        foregroundCamera.clearFlags = CameraClearFlags.Color;\\n#if OVR_ANDROID_MRC\\n        foregroundCamera.backgroundColor = configuration.externalCompositionBackdropColorQuest;\\n#else\\n        foregroundCamera.backgroundColor = configuration.externalCompositionBackdropColorRift;\\n#endif\\n        foregroundCamera.cullingMask = (foregroundCamera.cullingMask & ~configuration.extraHiddenLayers) |\\n                                        configuration.extraVisibleLayers;\\n\\n#if OVR_ANDROID_MRC\\n        if (renderCombinedFrame)\\n        {\\n            foregroundCamera.targetTexture = mrcRenderTextureArray[0];\\n        }\\n        else\\n        {\\n            foregroundCamera.targetTexture = mrcForegroundRenderTextureArray[0];\\n            foregroundCamera.rect = new Rect(0.0f, 0.0f, 1.0f, 1.0f);\\n        }\\n#endif\\n\\n        previousMainCameraObject = mainCamera.gameObject;\\n    }\\n}\\n\\nprivate Dictionary<GameObject, GameObject> backgroundCameraGameObjectPool = new Dictionary<GameObject, GameObject>();\\nprivate Dictionary<GameObject, GameObject> foregroundCameraGameObjectPool = new Dictionary<GameObject, GameObject>();\\n\\npublic override void Update(GameObject gameObject, Camera mainCamera,\\n    OVRMixedRealityCaptureConfiguration configuration, OVRManager.TrackingOrigin trackingOrigin)\\n{\\n#if OVR_ANDROID_MRC\\n    if (skipFrame && OVRPlugin.Media.IsCastingToRemoteClient())\\n    {\\n        isFrameSkipped = !isFrameSkipped;\\n        if (isFrameSkipped)\\n        {\\n            return;\\n        }\\n    }\\n#endif\\n\\n    RefreshCameraObjects(gameObject, mainCamera, configuration);\\n\\n    OVRPlugin.SetHandNodePoseStateLatency(0.0);\\n\\n    OVRPose stageToLocalPose =\\n        OVRPlugin.GetTrackingTransformRelativePose(OVRPlugin.TrackingOrigin.Stage).ToOVRPose();\\n    OVRPose localToStagePose = stageToLocalPose.Inverse();\\n    OVRPose head = localToStagePose * OVRPlugin.GetNodePose(OVRPlugin.Node.Head, OVRPlugin.Step.Render).ToOVRPose();\\n    OVRPose leftC = localToStagePose *\\n                    OVRPlugin.GetNodePose(OVRPlugin.Node.HandLeft, OVRPlugin.Step.Render).ToOVRPose();\\n    OVRPose rightC = localToStagePose *\\n                     OVRPlugin.GetNodePose(OVRPlugin.Node.HandRight, OVRPlugin.Step.Render).ToOVRPose();\\n    OVRPlugin.Media.SetMrcHeadsetControllerPose(head.ToPosef(), leftC.ToPosef(), rightC.ToPosef());\\n\\n#if OVR_ANDROID_MRC\\n    RefreshAudioFilter(mainCamera);\\n\\n    int drawTextureIndex = (frameIndex / 2) % 2;\\n    int castTextureIndex = 1 - drawTextureIndex;\\n\\n    backgroundCamera.enabled = (frameIndex % 2) == 0;\\n    foregroundCamera.enabled = (frameIndex % 2) == 1;\\n\\n    if (frameIndex % 2 == 0)\\n    {\\n        if (lastMrcEncodeFrameSyncId != -1)\\n        {\\n            OVRPlugin.Media.SyncMrcFrame(lastMrcEncodeFrameSyncId);\\n            lastMrcEncodeFrameSyncId = -1;\\n        }\\n\\n        lastMrcEncodeFrameSyncId = CastMrcFrame(castTextureIndex);\\n        SetCameraTargetTexture(drawTextureIndex);\\n    }\\n\\n    ++frameIndex;\\n#endif\\n\\n    backgroundCamera.clearFlags = mainCamera.clearFlags;\\n    backgroundCamera.backgroundColor = mainCamera.backgroundColor;\\n    if (configuration.dynamicCullingMask)\\n    {\\n        backgroundCamera.cullingMask = (mainCamera.cullingMask & ~configuration.extraHiddenLayers) |\\n                                        configuration.extraVisibleLayers;\\n    }\\n\\n    backgroundCamera.nearClipPlane = mainCamera.nearClipPlane;\\n    backgroundCamera.farClipPlane = mainCamera.farClipPlane;\\n\\n    if (configuration.dynamicCullingMask)\\n    {\\n        foregroundCamera.cullingMask = (mainCamera.cullingMask & ~configuration.extraHiddenLayers) |\\n                                        configuration.extraVisibleLayers;\\n    }\\n\\n    foregroundCamera.nearClipPlane = mainCamera.nearClipPlane;\\n    foregroundCamera.farClipPlane = mainCamera.farClipPlane;\\n\\n    if (OVRMixedReality.useFakeExternalCamera || OVRPlugin.GetExternalCameraCount() == 0)\\n    {\\n        OVRPose worldSpacePose = new OVRPose();\\n        OVRPose trackingSpacePose = new OVRPose();\\n        trackingSpacePose.position = trackingOrigin == OVRManager.TrackingOrigin.EyeLevel\\n            ? OVRMixedReality.fakeCameraEyeLevelPosition\\n            : OVRMixedReality.fakeCameraFloorLevelPosition;\\n        trackingSpacePose.orientation = OVRMixedReality.fakeCameraRotation;\\n        worldSpacePose = OVRExtensions.ToWorldSpacePose(trackingSpacePose, mainCamera);\\n\\n        backgroundCamera.fieldOfView = OVRMixedReality.fakeCameraFov;\\n        backgroundCamera.aspect = OVRMixedReality.fakeCameraAspect;\\n        foregroundCamera.fieldOfView = OVRMixedReality.fakeCameraFov;\\n        foregroundCamera.aspect = OVRMixedReality.fakeCameraAspect;\\n\\n        if (cameraInTrackingSpace)\\n        {\\n            backgroundCamera.transform.FromOVRPose(trackingSpacePose, true);\\n            foregroundCamera.transform.FromOVRPose(trackingSpacePose, true);\\n        }\\n        else\\n        {\\n            backgroundCamera.transform.FromOVRPose(worldSpacePose);\\n            foregroundCamera.transform.FromOVRPose(worldSpacePose);\\n        }\\n    }\\n    else\\n    {\\n        OVRPlugin.CameraExtrinsics extrinsics;\\n        OVRPlugin.CameraIntrinsics intrinsics;\\n\\n\\n        if (OVRPlugin.GetMixedRealityCameraInfo(0, out extrinsics, out intrinsics))\\n        {\\n            float fovY = Mathf.Atan(intrinsics.FOVPort.UpTan) * Mathf.Rad2Deg * 2;\\n            float aspect = intrinsics.FOVPort.LeftTan / intrinsics.FOVPort.UpTan;\\n            backgroundCamera.fieldOfView = fovY;\\n            backgroundCamera.aspect = aspect;\\n            foregroundCamera.fieldOfView = fovY;\\n            foregroundCamera.aspect = intrinsics.FOVPort.LeftTan / intrinsics.FOVPort.UpTan;\\n\\n            if (cameraInTrackingSpace)\\n            {\\n                OVRPose trackingSpacePose = ComputeCameraTrackingSpacePose(extrinsics);\\n                backgroundCamera.transform.FromOVRPose(trackingSpacePose, true);\\n                foregroundCamera.transform.FromOVRPose(trackingSpacePose, true);\\n            }\\n            else\\n            {\\n                OVRPose worldSpacePose = ComputeCameraWorldSpacePose(extrinsics, mainCamera);\\n                backgroundCamera.transform.FromOVRPose(worldSpacePose);\\n                foregroundCamera.transform.FromOVRPose(worldSpacePose);\\n            }\\n#if OVR_ANDROID_MRC\\n            cameraPoseTimeArray[drawTextureIndex] = extrinsics.LastChangedTimeSeconds;\\n#endif\\n        }\\n        else\\n        {\\n            Debug.LogError(\\\"Failed to get external camera information\\\");\\n            return;\\n        }\\n    }\\n\\n    Vector3 headToExternalCameraVec = mainCamera.transform.position - foregroundCamera.transform.position;\\n    float clipDistance = Vector3.Dot(headToExternalCameraVec, foregroundCamera.transform.forward);\\n    foregroundCamera.farClipPlane = Mathf.Max(foregroundCamera.nearClipPlane + 0.001f, clipDistance);\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}},{\"finish_reason\":\"stop\",\"index\":1,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System;\\nusing UnityEngine;\\nusing System.Collections.Generic;\\nusing System.Threading;\\nusing UnityEngine.Rendering;\\nusing Object = UnityEngine.Object;\\nusing UnityEngine.Rendering.Universal;\\n\\npublic class OVRExternalComposition : MonoBehaviour\\n{\\n    private GameObject previousMainCameraObject;\\n    private GameObject backgroundCameraGameObject;\\n    private Camera backgroundCamera;\\n    private GameObject foregroundCameraGameObject;\\n    private Camera foregroundCamera;\\n    private bool cameraInTrackingSpace;\\n    private Transform cameraRigTrackingSpace;\\n    private int frameIndex;\\n    private bool isFrameSkipped;\\n    private int lastMrcEncodeFrameSyncId;\\n\\n    private List<GameObject> backgroundCameraPool = new List<GameObject>();\\n    private List<GameObject> foregroundCameraPool = new List<GameObject>();\\n\\n    private void Awake()\\n    {\\n        // Initialize camera object pools\\n        for (int i = 0; i < 2; i++) // Preallocate two camera objects for each\\n        {\\n            var bgCameraObj = new GameObject(\\\"PooledBackgroundCamera\\\");\\n            var fgCameraObj = new GameObject(\\\"PooledForegroundCamera\\\");\\n            bgCameraObj.AddComponent<Camera>();\\n            fgCameraObj.AddComponent<Camera>();\\n            bgCameraObj.SetActive(false);\\n            fgCameraObj.SetActive(false);\\n            backgroundCameraPool.Add(bgCameraObj);\\n            foregroundCameraPool.Add(fgCameraObj);\\n        }\\n    }\\n\\n    private GameObject GetPooledCamera(List<GameObject> pool)\\n    {\\n        foreach (var cameraObj in pool)\\n        {\\n            if (!cameraObj.activeInHierarchy)\\n            {\\n                cameraObj.SetActive(true);\\n                return cameraObj;\\n            }\\n        }\\n\\n        // If no inactive camera object is available, create a new one\\n        var newCameraObj = new GameObject(\\\"PooledCamera\\\");\\n        newCameraObj.AddComponent<Camera>();\\n        newCameraObj.SetActive(true);\\n        pool.Add(newCameraObj);\\n        return newCameraObj;\\n    }\\n\\n    private void RefreshCameraObjects(GameObject parentObject, Camera mainCamera,\\n        OVRMixedRealityCaptureConfiguration configuration)\\n    {\\n        if (mainCamera.gameObject != previousMainCameraObject)\\n        {\\n            Debug.LogFormat(\\\"[OVRExternalComposition] Camera refreshed. Rebind camera to {0}\\\",\\n                mainCamera.gameObject.name);\\n\\n            if (backgroundCameraGameObject != null)\\n            {\\n                backgroundCameraGameObject.SetActive(false);\\n            }\\n\\n            if (foregroundCameraGameObject != null)\\n            {\\n                foregroundCameraGameObject.SetActive(false);\\n            }\\n\\n            RefreshCameraRig(parentObject, mainCamera);\\n\\n            Debug.Assert(backgroundCameraGameObject == null);\\n            backgroundCameraGameObject = GetPooledCamera(backgroundCameraPool);\\n            SetupCamera(backgroundCameraGameObject, \\\"OculusMRC_BackgroundCamera\\\", parentObject, mainCamera, configuration, OVRManager.MrcCameraType.Background);\\n            backgroundCamera = backgroundCameraGameObject.GetComponent<Camera>();\\n\\n            Debug.Assert(foregroundCameraGameObject == null);\\n            foregroundCameraGameObject = GetPooledCamera(foregroundCameraPool);\\n            SetupCamera(foregroundCameraGameObject, \\\"OculusMRC_ForegroundCamera\\\", parentObject, mainCamera, configuration, OVRManager.MrcCameraType.Foreground);\\n            foregroundCamera = foregroundCameraGameObject.GetComponent<Camera>();\\n\\n            previousMainCameraObject = mainCamera.gameObject;\\n        }\\n    }\\n\\n    private void SetupCamera(GameObject cameraObject, string name, GameObject parentObject, Camera mainCamera, OVRMixedRealityCaptureConfiguration configuration, OVRManager.MrcCameraType cameraType)\\n    {\\n        cameraObject.name = name;\\n        cameraObject.transform.parent = cameraInTrackingSpace ? cameraRigTrackingSpace : parentObject.transform;\\n        var audioListener = cameraObject.GetComponent<AudioListener>();\\n        if (audioListener != null)\\n            Object.Destroy(audioListener);\\n\\n        var ovrManager = cameraObject.GetComponent<OVRManager>();\\n        if (ovrManager != null)\\n            Object.Destroy(ovrManager);\\n\\n        var camera = cameraObject.GetComponent<Camera>();\\n        camera.tag = \\\"Untagged\\\";\\n#if USING_MRC_COMPATIBLE_URP_VERSION\\n        var camData = camera.GetUniversalAdditionalCameraData();\\n        if (camData != null)\\n        {\\n            camData.allowXRRendering = false;\\n        }\\n#elif USING_URP\\n        Debug.LogError(\\\"Using URP with MRC is only supported with URP version 10.0.0 or higher. Consider using Unity 2020 or higher.\\\");\\n#else\\n        camera.stereoTargetEye = StereoTargetEyeMask.None;\\n#endif\\n        camera.depth = (cameraType == OVRManager.MrcCameraType.Background) ? 99990.0f : backgroundCamera.depth + 1.0f; // enforce the foreground be rendered after the background\\n        camera.rect = (cameraType == OVRManager.MrcCameraType.Background) ? new Rect(0.0f, 0.0f, 0.5f, 1.0f) : new Rect(0.5f, 0.0f, 0.5f, 1.0f);\\n\\n#if OVR_ANDROID_MRC\\n        if (cameraType == OVRManager.MrcCameraType.Foreground)\\n        {\\n            camera.backgroundColor = configuration.externalCompositionBackdropColorQuest;\\n        }\\n#else\\n        if (cameraType == OVRManager.MrcCameraType.Foreground)\\n        {\\n            camera.backgroundColor = configuration.externalCompositionBackdropColorRift;\\n        }\\n#endif\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}},{\"finish_reason\":\"stop\",\"index\":2,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System;\\nusing UnityEngine;\\nusing System.Collections.Generic;\\nusing System.Threading;\\nusing UnityEngine.Rendering;\\nusing Object = UnityEngine.Object;\\nusing UnityEngine.Rendering.Universal;\\n\\npublic class OVRExternalComposition : MonoBehaviour\\n{\\n    // Object pools for camera GameObjects\\n    private Queue<GameObject> backgroundCameraPool = new Queue<GameObject>();\\n    private Queue<GameObject> foregroundCameraPool = new Queue<GameObject>();\\n\\n    private void InitializeCameraPools(GameObject cameraPrototype, int poolSize)\\n    {\\n        for (int i = 0; i < poolSize; i++)\\n        {\\n            var newBackgroundCamera = Object.Instantiate(cameraPrototype);\\n            newBackgroundCamera.SetActive(false);\\n            backgroundCameraPool.Enqueue(newBackgroundCamera);\\n\\n            var newForegroundCamera = Object.Instantiate(cameraPrototype);\\n            newForegroundCamera.SetActive(false);\\n            foregroundCameraPool.Enqueue(newForegroundCamera);\\n        }\\n    }\\n\\n    private GameObject GetCameraFromPool(Queue<GameObject> pool, GameObject prototype)\\n    {\\n        if (pool.Count > 0)\\n        {\\n            var camera = pool.Dequeue();\\n            camera.SetActive(true);\\n            return camera;\\n        }\\n        else\\n        {\\n            return Object.Instantiate(prototype);\\n        }\\n    }\\n\\n    private void ReturnCameraToPool(Queue<GameObject> pool, GameObject camera)\\n    {\\n        camera.SetActive(false);\\n        pool.Enqueue(camera);\\n    }\\n\\n    private void RefreshCameraObjects(GameObject parentObject, Camera mainCamera,\\n        OVRMixedRealityCaptureConfiguration configuration)\\n    {\\n        if (mainCamera.gameObject != previousMainCameraObject)\\n        {\\n            Debug.LogFormat(\\\"[OVRExternalComposition] Camera refreshed. Rebind camera to {0}\\\",\\n                mainCamera.gameObject.name);\\n\\n            // Return existing game objects to pool before refreshing\\n            if (backgroundCameraGameObject != null)\\n                ReturnCameraToPool(backgroundCameraPool, backgroundCameraGameObject);\\n            backgroundCamera = null;\\n\\n            if (foregroundCameraGameObject != null)\\n                ReturnCameraToPool(foregroundCameraPool, foregroundCameraGameObject);\\n            foregroundCamera = null;\\n\\n            RefreshCameraRig(parentObject, mainCamera);\\n\\n            Debug.Assert(backgroundCameraGameObject == null);\\n            if (configuration.instantiateMixedRealityCameraGameObject != null)\\n            {\\n                backgroundCameraGameObject =\\n                    configuration.instantiateMixedRealityCameraGameObject(mainCamera.gameObject,\\n                        OVRManager.MrcCameraType.Background);\\n            }\\n            else\\n            {\\n                backgroundCameraGameObject = GetCameraFromPool(backgroundCameraPool, mainCamera.gameObject);\\n            }\\n\\n            backgroundCameraGameObject.name = \\\"OculusMRC_BackgroundCamera\\\";\\n            backgroundCameraGameObject.transform.parent =\\n                cameraInTrackingSpace ? cameraRig.trackingSpace : parentObject.transform;\\n            if (backgroundCameraGameObject.GetComponent<AudioListener>())\\n            {\\n                Object.Destroy(backgroundCameraGameObject.GetComponent<AudioListener>());\\n            }\\n\\n            if (backgroundCameraGameObject.GetComponent<OVRManager>())\\n            {\\n                Object.Destroy(backgroundCameraGameObject.GetComponent<OVRManager>());\\n            }\\n\\n            backgroundCamera = backgroundCameraGameObject.GetComponent<Camera>();\\n            backgroundCamera.tag = \\\"Untagged\\\";\\n#if USING_MRC_COMPATIBLE_URP_VERSION\\n            var backgroundCamData = backgroundCamera.GetUniversalAdditionalCameraData();\\n            if (backgroundCamData != null)\\n            {\\n                backgroundCamData.allowXRRendering = false;\\n            }\\n#elif USING_URP\\n            Debug.LogError(\\\"Using URP with MRC is only supported with URP version 10.0.0 or higher. Consider using Unity 2020 or higher.\\\");\\n#else\\n            backgroundCamera.stereoTargetEye = StereoTargetEyeMask.None;\\n#endif\\n            backgroundCamera.depth = 99990.0f;\\n            backgroundCamera.rect = new Rect(0.0f, 0.0f, 0.5f, 1.0f);\\n            backgroundCamera.cullingMask = (backgroundCamera.cullingMask & ~configuration.extraHiddenLayers) |\\n                                           configuration.extraVisibleLayers;\\n#if OVR_ANDROID_MRC\\n            backgroundCamera.targetTexture = mrcRenderTextureArray[0];\\n            if (!renderCombinedFrame)\\n            {\\n                backgroundCamera.rect = new Rect(0.0f, 0.0f, 1.0f, 1.0f);\\n            }\\n#endif\\n\\n            Debug.Assert(foregroundCameraGameObject == null);\\n            if (configuration.instantiateMixedRealityCameraGameObject != null)\\n            {\\n                foregroundCameraGameObject =\\n                    configuration.instantiateMixedRealityCameraGameObject(mainCamera.gameObject,\\n                        OVRManager.MrcCameraType.Foreground);\\n            }\\n            else\\n            {\\n                foregroundCameraGameObject = GetCameraFromPool(foregroundCameraPool, mainCamera.gameObject);\\n            }\\n\\n            foregroundCameraGameObject.name = \\\"OculusMRC_ForegroundCamera\\\";\\n            foregroundCameraGameObject.transform.parent =\\n                cameraInTrackingSpace ? cameraRig.trackingSpace : parentObject.transform;\\n            if (foregroundCameraGameObject.GetComponent<AudioListener>())\\n            {\\n                Object.Destroy(foregroundCameraGameObject.GetComponent<AudioListener>());\\n            }\\n\\n            if (foregroundCameraGameObject.GetComponent<OVRManager>())\\n            {\\n                Object.Destroy(foregroundCameraGameObject.GetComponent<OVRManager>());\\n            }\\n\\n            foregroundCamera = foregroundCameraGameObject.GetComponent<Camera>();\\n            foregroundCamera.tag = \\\"Untagged\\\";\\n#if USING_MRC_COMPATIBLE_URP_VERSION\\n            var foregroundCamData = foregroundCamera.GetUniversalAdditionalCameraData();\\n            if (foregroundCamData != null)\\n            {\\n                foregroundCamData.allowXRRendering = false;\\n            }\\n#elif USING_URP\\n            Debug.LogError(\\\"Using URP with MRC is only supported with URP version 10.0.0 or higher. Consider using Unity 2020 or higher.\\\");\\n#else\\n            foregroundCamera.stereoTargetEye = StereoTargetEyeMask.None;\\n#endif\\n            foregroundCamera.depth =\\n                backgroundCamera.depth + 1.0f; // enforce the foreground be rendered after the background\\n            foregroundCamera.rect = new Rect(0.5f, 0.0f, 0.5f, 1.0f);\\n            foregroundCamera.clearFlags = CameraClearFlags.Color;\\n#if OVR_ANDROID_MRC\\n            foregroundCamera.backgroundColor = configuration.externalCompositionBackdropColorQuest;\\n#else\\n            foregroundCamera.backgroundColor = configuration.externalCompositionBackdropColorRift;\\n#endif\\n            foregroundCamera.cullingMask = (foregroundCamera.cullingMask & ~configuration.extraHiddenLayers) |\\n                                           configuration.extraVisibleLayers;\\n\\n#if OVR_ANDROID_MRC\\n            if (renderCombinedFrame)\\n            {\\n                foregroundCamera.targetTexture = mrcRenderTextureArray[0];\\n            }\\n            else\\n            {\\n                foregroundCamera.targetTexture = mrcForegroundRenderTextureArray[0];\\n                foregroundCamera.rect = new Rect(0.0f, 0.0f, 1.0f, 1.0f);\\n            }\\n#endif\\n\\n            previousMainCameraObject = mainCamera.gameObject;\\n        }\\n    }\\n\\n    // Initialize pools in a method such as Start() or Awake()\\n    private void Start()\\n    {\\n        InitializeCameraPools(mainCameraPrototype, 2); // Assuming mainCameraPrototype is set properly\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}},{\"finish_reason\":\"stop\",\"index\":3,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\n// Fixed Code Snippets:\\n\\n// Create object pool for camera game objects outside Update method\\nprivate GameObject backgroundCameraGameObject;\\nprivate GameObject foregroundCameraGameObject;\\nprivate Camera backgroundCamera;\\nprivate Camera foregroundCamera;\\nprivate GameObject previousMainCameraObject;\\n\\n// Method to initialize camera objects, should be called before Update if needed\\nprivate void InitializeCameraObjects(GameObject parentObject, Camera mainCamera, OVRMixedRealityCaptureConfiguration configuration)\\n{\\n    if (backgroundCameraGameObject == null || foregroundCameraGameObject == null)\\n    {\\n        backgroundCameraGameObject = new GameObject(\\\"OculusMRC_BackgroundCamera\\\");\\n        backgroundCamera = backgroundCameraGameObject.AddComponent<Camera>();\\n\\n        foregroundCameraGameObject = new GameObject(\\\"OculusMRC_ForegroundCamera\\\");\\n        foregroundCamera = foregroundCameraGameObject.AddComponent<Camera>();\\n\\n        backgroundCameraGameObject.transform.parent = cameraInTrackingSpace ? cameraRig.trackingSpace : parentObject.transform;\\n        foregroundCameraGameObject.transform.parent = cameraInTrackingSpace ? cameraRig.trackingSpace : parentObject.transform;\\n    }\\n}\\n\\n// Updated RefreshCameraObjects method with object pool\\nprivate void RefreshCameraObjects(GameObject parentObject, Camera mainCamera, OVRMixedRealityCaptureConfiguration configuration)\\n{\\n    if (mainCamera.gameObject != previousMainCameraObject)\\n    {\\n        Debug.LogFormat(\\\"[OVRExternalComposition] Camera refreshed. Rebind camera to {0}\\\", mainCamera.gameObject.name);\\n\\n        OVRCompositionUtil.SafeDestroy(ref backgroundCameraGameObject);\\n        backgroundCamera = null;\\n        OVRCompositionUtil.SafeDestroy(ref foregroundCameraGameObject);\\n        foregroundCamera = null;\\n\\n        RefreshCameraRig(parentObject, mainCamera);\\n\\n        Debug.Assert(backgroundCameraGameObject == null);\\n\\n        InitializeCameraObjects(parentObject, mainCamera, configuration);\\n\\n        if (configuration.instantiateMixedRealityCameraGameObject != null)\\n        {\\n            GameObject backgroundCameraPrefab = configuration.instantiateMixedRealityCameraGameObject(mainCamera.gameObject, OVRManager.MrcCameraType.Background);\\n            Object.Instantiate(backgroundCameraPrefab, Vector3.zero, Quaternion.identity, backgroundCameraGameObject.transform);\\n        }\\n\\n        if (backgroundCameraGameObject.GetComponent<AudioListener>())\\n        {\\n            Object.Destroy(backgroundCameraGameObject.GetComponent<AudioListener>());\\n        }\\n\\n        if (backgroundCameraGameObject.GetComponent<OVRManager>())\\n        {\\n            Object.Destroy(backgroundCameraGameObject.GetComponent<OVRManager>());\\n        }\\n\\n        backgroundCamera = backgroundCameraGameObject.GetComponent<Camera>();\\n        backgroundCamera.tag = \\\"Untagged\\\";\\n#if USING_MRC_COMPATIBLE_URP_VERSION\\n        var backgroundCamData = backgroundCamera.GetUniversalAdditionalCameraData();\\n        if (backgroundCamData != null)\\n        {\\n            backgroundCamData.allowXRRendering = false;\\n        }\\n#elif USING_URP\\n        Debug.LogError(\\\"Using URP with MRC is only supported with URP version 10.0.0 or higher. Consider using Unity 2020 or higher.\\\");\\n#else\\n        backgroundCamera.stereoTargetEye = StereoTargetEyeMask.None;\\n#endif\\n        backgroundCamera.depth = 99990.0f;\\n        backgroundCamera.rect = new Rect(0.0f, 0.0f, 0.5f, 1.0f);\\n        backgroundCamera.cullingMask = (backgroundCamera.cullingMask & ~configuration.extraHiddenLayers) | configuration.extraVisibleLayers;\\n#if OVR_ANDROID_MRC\\n        backgroundCamera.targetTexture = mrcRenderTextureArray[0];\\n        if (!renderCombinedFrame)\\n        {\\n            backgroundCamera.rect = new Rect(0.0f, 0.0f, 1.0f, 1.0f);\\n        }\\n#endif\\n\\n        Debug.Assert(foregroundCameraGameObject == null);\\n\\n        if (configuration.instantiateMixedRealityCameraGameObject != null)\\n        {\\n            GameObject foregroundCameraPrefab = configuration.instantiateMixedRealityCameraGameObject(mainCamera.gameObject, OVRManager.MrcCameraType.Foreground);\\n            Object.Instantiate(foregroundCameraPrefab, Vector3.zero, Quaternion.identity, foregroundCameraGameObject.transform);\\n        }\\n\\n        if (foregroundCameraGameObject.GetComponent<AudioListener>())\\n        {\\n            Object.Destroy(foregroundCameraGameObject.GetComponent<AudioListener>());\\n        }\\n\\n        if (foregroundCameraGameObject.GetComponent<OVRManager>())\\n        {\\n            Object.Destroy(foregroundCameraGameObject.GetComponent<OVRManager>());\\n        }\\n\\n        foregroundCamera = foregroundCameraGameObject.GetComponent<Camera>();\\n        foregroundCamera.tag = \\\"Untagged\\\";\\n#if USING_MRC_COMPATIBLE_URP_VERSION\\n        var foregroundCamData = foregroundCamera.GetUniversalAdditionalCameraData();\\n        if (foregroundCamData != null)\\n        {\\n            foregroundCamData.allowXRRendering = false;\\n        }\\n#elif USING_URP\\n        Debug.LogError(\\\"Using URP with MRC is only supported with URP version 10.0.0 or higher. Consider using Unity 2020 or higher.\\\");\\n#else\\n        foregroundCamera.stereoTargetEye = StereoTargetEyeMask.None;\\n#endif\\n        foregroundCamera.depth = backgroundCamera.depth + 1.0f;\\n        foregroundCamera.rect = new Rect(0.5f, 0.0f, 0.5f, 1.0f);\\n        foregroundCamera.clearFlags = CameraClearFlags.Color;\\n#if OVR_ANDROID_MRC\\n        foregroundCamera.backgroundColor = configuration.externalCompositionBackdropColorQuest;\\n#else\\n        foregroundCamera.backgroundColor = configuration.externalCompositionBackdropColorRift;\\n#endif\\n        foregroundCamera.cullingMask = (foregroundCamera.cullingMask & ~configuration.extraHiddenLayers) | configuration.extraVisibleLayers;\\n\\n#if OVR_ANDROID_MRC\\n        if (renderCombinedFrame)\\n        {\\n            foregroundCamera.targetTexture = mrcRenderTextureArray[0];\\n        }\\n        else\\n        {\\n            foregroundCamera.targetTexture = mrcForegroundRenderTextureArray[0];\\n            foregroundCamera.rect = new Rect(0.0f, 0.0f, 1.0f, 1.0f);\\n        }\\n#endif\\n\\n        previousMainCameraObject = mainCamera.gameObject;\\n    }\\n}\\n\\n// Call InitializeCameraObjects in Start or Awake or wherever appropriate if you need to initialize before Update\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}},{\"finish_reason\":\"stop\",\"index\":4,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System;\\nusing UnityEngine;\\nusing System.Collections.Generic;\\nusing System.Threading;\\nusing UnityEngine.Rendering;\\nusing Object = UnityEngine.Object;\\nusing UnityEngine.Rendering.Universal;\\n\\npublic class OVRExternalComposition : MonoBehaviour\\n{\\n    // Declare object pools for cameras\\n    private GameObject backgroundCameraObjectPool;\\n    private GameObject foregroundCameraObjectPool;\\n\\n    private GameObject previousMainCameraObject;\\n\\n    private void Awake()\\n    {\\n        // Initialize the object pools in the Awake method\\n        backgroundCameraObjectPool = new GameObject(\\\"Background Camera Object Pool\\\");\\n        foregroundCameraObjectPool = new GameObject(\\\"Foreground Camera Object Pool\\\");\\n\\n        DontDestroyOnLoad(backgroundCameraObjectPool);\\n        DontDestroyOnLoad(foregroundCameraObjectPool);\\n    }\\n\\n    private GameObject GetOrCreateCameraObject(GameObject mainCameraObject, OVRManager.MrcCameraType cameraType)\\n    {\\n        GameObject cameraObject = null;\\n\\n        if (cameraType == OVRManager.MrcCameraType.Background)\\n        {\\n            if (backgroundCameraObjectPool.transform.childCount > 0)\\n            {\\n                cameraObject = backgroundCameraObjectPool.transform.GetChild(0).gameObject;\\n                cameraObject.transform.SetParent(null);\\n                cameraObject.SetActive(true);\\n            }\\n            else\\n            {\\n                cameraObject = Object.Instantiate(mainCameraObject);\\n            }\\n        }\\n        else if (cameraType == OVRManager.MrcCameraType.Foreground)\\n        {\\n            if (foregroundCameraObjectPool.transform.childCount > 0)\\n            {\\n                cameraObject = foregroundCameraObjectPool.transform.GetChild(0).gameObject;\\n                cameraObject.transform.SetParent(null);\\n                cameraObject.SetActive(true);\\n            }\\n            else\\n            {\\n                cameraObject = Object.Instantiate(mainCameraObject);\\n            }\\n        }\\n\\n        return cameraObject;\\n    }\\n\\n    private void ReturnCameraObjectToPool(GameObject cameraObject, OVRManager.MrcCameraType cameraType)\\n    {\\n        cameraObject.SetActive(false);\\n\\n        if (cameraType == OVRManager.MrcCameraType.Background)\\n        {\\n            cameraObject.transform.SetParent(backgroundCameraObjectPool.transform);\\n        }\\n        else if (cameraType == OVRManager.MrcCameraType.Foreground)\\n        {\\n            cameraObject.transform.SetParent(foregroundCameraObjectPool.transform);\\n        }\\n    }\\n\\n    private void RefreshCameraObjects(GameObject parentObject, Camera mainCamera, OVRMixedRealityCaptureConfiguration configuration)\\n    {\\n        if (mainCamera.gameObject != previousMainCameraObject)\\n        {\\n            Debug.LogFormat(\\\"[OVRExternalComposition] Camera refreshed. Rebind camera to {0}\\\", mainCamera.gameObject.name);\\n\\n            if (backgroundCamera != null)\\n            {\\n                ReturnCameraObjectToPool(backgroundCamera.gameObject, OVRManager.MrcCameraType.Background);\\n            }\\n            if (foregroundCamera != null)\\n            {\\n                ReturnCameraObjectToPool(foregroundCamera.gameObject, OVRManager.MrcCameraType.Foreground);\\n            }\\n\\n            backgroundCameraGameObject = GetOrCreateCameraObject(mainCamera.gameObject, OVRManager.MrcCameraType.Background);\\n            foregroundCameraGameObject = GetOrCreateCameraObject(mainCamera.gameObject, OVRManager.MrcCameraType.Foreground);\\n\\n            // Continue your existing logic here for setting up the camera objects...\\n\\n            previousMainCameraObject = mainCamera.gameObject;\\n        }\\n    }\\n\\n    // Add your existing Update logic here...\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}}],\"created\":1751715681,\"model\":\"gpt-4o-2024-08-06\",\"object\":\"chat.completion\",\"service_tier\":\"default\",\"system_fingerprint\":\"fp_07871e2ad8\",\"usage\":{\"completion_tokens\":7211,\"prompt_tokens\":2646,\"total_tokens\":9857,\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":0,\"rejected_prediction_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0}}}"