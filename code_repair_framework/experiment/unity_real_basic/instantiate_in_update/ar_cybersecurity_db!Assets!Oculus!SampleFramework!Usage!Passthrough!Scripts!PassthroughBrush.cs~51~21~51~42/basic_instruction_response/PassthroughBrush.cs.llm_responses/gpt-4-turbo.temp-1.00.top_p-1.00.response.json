"{\"id\":\"chatcmpl-B2U7Fwa9ZHyF5tIrAy11uXaj3ejoc\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class PassthroughBrush : MonoBehaviour\\n{\\n    public OVRInput.Controller controllerHand = OVRInput.Controller.None;\\n    public GameObject lineSegmentPrefab;\\n    public GameObject lineContainer;\\n    public bool forceActive = true;\\n    LineRenderer currentLineSegment = null;\\n    List<Vector3> inkPositions = new List<Vector3>();\\n    float minInkDist = 0.01f;\\n    float strokeWidth = 0.1f;\\n    float strokeLength = 0.0f;\\n\\n    public enum BrushState\\n    {\\n        Idle,\\n        Inking\\n    };\\n\\n    BrushState brushStatus = BrushState.Idle;\\n\\n    private void OnDisable()\\n    {\\n        brushStatus = BrushState.Idle;\\n    }\\n\\n    void Update()\\n    {\\n        HandleBrushBehavior();\\n    }\\n\\n    void HandleBrushBehavior()\\n    {\\n        transform.rotation = Quaternion.LookRotation(transform.position - Camera.main.transform.position);\\n\\n        if (!(controllerHand == OVRInput.Controller.LTouch || controllerHand == OVRInput.Controller.RTouch))\\n        {\\n            return;\\n        }\\n\\n        Vector3 tipPosition = transform.position;\\n        switch (brushStatus)\\n        {\\n            case BrushState.Idle:\\n                if (OVRInput.GetUp(OVRInput.Button.One, controllerHand))\\n                {\\n                    UndoInkLine();\\n                }\\n\\n                if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    StartLine(tipPosition);\\n                    brushStatus = BrushState.Inking;\\n                }\\n\\n                break;\\n            case BrushState.Inking:\\n                UpdateLine(tipPosition);\\n                if (OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    brushStatus = BrushState.Idle;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void StartLine(Vector3 inkPos)\\n    {\\n        GameObject newLine = PoolManager.Instance.GetFromPool(lineSegmentPrefab); // Use an object pooling system\\n        if (newLine != null)\\n        {\\n            newLine.transform.position = inkPos;\\n            newLine.transform.rotation = Quaternion.identity;\\n            newLine.SetActive(true);\\n\\n            currentLineSegment = newLine.GetComponent<LineRenderer>();\\n            currentLineSegment.positionCount = 1;\\n            currentLineSegment.SetPosition(0, inkPos);\\n            strokeWidth = currentLineSegment.startWidth;\\n            strokeLength = 0.0f;\\n            inkPositions.Clear();\\n            inkPositions.Add(inkPos);\\n            newLine.transform.parent = lineContainer.transform;\\n        }\\n    }\\n}\\n\\n// NOTE: Make sure to implement or include a PoolManager script that handles object pooling for better efficiency.\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}},{\"finish_reason\":\"stop\",\"index\":1,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class PassthroughBrush : MonoBehaviour\\n{\\n    public OVRInput.Controller controllerHand = OVRInput.Controller.None;\\n    public GameObject lineSegmentPrefab;\\n    public GameObject lineContainer;\\n    public bool forceActive = true;\\n    LineRenderer currentLineSegment = null;\\n    List<Vector3> inkPositions = new List<Vector3>();\\n    float minInkDist = 0.01f;\\n    float strokeWidth = 0.1f;\\n    float strokeLength = 0.0f;\\n\\n    public enum BrushState\\n    {\\n        Idle,\\n        Inking\\n    };\\n\\n    BrushState brushStatus = BrushState.Idle;\\n\\n    private void OnDisable()\\n    {\\n        brushStatus = BrushState.Idle;\\n    }\\n\\n    void LateUpdate()\\n    {\\n        transform.rotation = Quaternion.LookRotation(transform.position - Camera.main.transform.position);\\n\\n        if (!(controllerHand == OVRInput.Controller.LTouch || controllerHand == OVRInput.Controller.RTouch))\\n        {\\n            return;\\n        }\\n\\n        Vector3 tipPosition = transform.position;\\n        switch (brushStatus)\\n        {\\n            case BrushState.Idle:\\n                if (OVRInput.GetUp(OVRInput.Button.One, controllerHand))\\n                {\\n                    UndoInkLine();\\n                }\\n\\n                if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    brushStatus = BrushState.Inking;\\n                }\\n\\n                break;\\n            case BrushState.Inking:\\n                if (currentLineSegment == null)\\n                {\\n                    StartLine(tipPosition);\\n                }\\n\\n                UpdateLine(tipPosition);\\n                if (OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    brushStatus = BrushState.Idle;\\n                    currentLineSegment = null;\\n                }\\n\\n                break;\\n        }\\n    }\\n\\n    void StartLine(Vector3 inkPos)\\n    {\\n        if (lineSegmentPrefab == null || lineContainer == null) return;\\n\\n        GameObject newLine = Instantiate(lineSegmentPrefab, inkPos, Quaternion.identity, lineContainer.transform);\\n        currentLineSegment = newLine.GetComponent<LineRenderer>();\\n        currentLineSegment.positionCount = 1;\\n        currentLineSegment.SetPosition(0, inkPos);\\n        strokeWidth = currentLineSegment.startWidth;\\n        strokeLength = 0.0f;\\n        inkPositions.Clear();\\n        inkPositions.Add(inkPos);\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}},{\"finish_reason\":\"stop\",\"index\":2,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class PassthroughBrush : MonoBehaviour\\n{\\n    public OVRInput.Controller controllerHand = OVRInput.Controller.None;\\n    public GameObject lineSegmentPrefab;\\n    public GameObject lineContainer;\\n    public bool forceActive = true;\\n    LineRenderer currentLineSegment = null;\\n    List<Vector3> inkPositions = new List<Vector3>();\\n    float minInkDist = 0.01f;\\n    float strokeWidth = 0.1f;\\n    float strokeLength = 0.0f;\\n\\n    public enum BrushState\\n    {\\n        Idle,\\n        Inking\\n    };\\n\\n    BrushState brushStatus = BrushState.Idle;\\n\\n    private void OnDisable()\\n    {\\n        brushStatus = BrushState.Idle;\\n    }\\n\\n    void LateUpdate()\\n    {\\n        transform.rotation = Quaternion.LookRotation(transform.position - Camera.main.transform.position);\\n\\n        if (!(controllerHand == OVRInput.Controller.LTouch || controllerHand == OVRInput.Controller.RTouch))\\n        {\\n            return;\\n        }\\n\\n        Vector3 tipPosition = transform.position;\\n        switch (brushStatus)\\n        {\\n            case BrushState.Idle:\\n                if (OVRInput.GetUp(OVRInput.Button.One, controllerHand))\\n                {\\n                    UndoInkLine();\\n                }\\n\\n                if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    PrepareStartLine(tipPosition);\\n                    brushStatus = BrushState.Inking;\\n                }\\n\\n                break;\\n            case BrushState.Inking:\\n\\n                UpdateLine(tipPosition);\\n                if (OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    brushStatus = BrushState.Idle;\\n                }\\n\\n                break;\\n        }\\n    }\\n\\n    void PrepareStartLine(Vector3 inkPos)\\n    {\\n        StartCoroutine(InstantiateLineCoroutine(inkPos));\\n    }\\n\\n    IEnumerator InstantiateLineCoroutine(Vector3 inkPos)\\n    {\\n        GameObject newLine = Instantiate(lineSegmentPrefab, inkPos, Quaternion.identity);\\n        yield return null; // Allow other Update() cycles to process while this coroutine runs\\n        InitializeLineRenderer(newLine, inkPos);\\n    }\\n\\n    void InitializeLineRenderer(GameObject newLine, Vector3 inkPos)\\n    {\\n        currentLineSegment = newLine.GetComponent<LineRenderer>();\\n        currentLineSegment.positionCount = 1;\\n        currentLineSegment.SetPosition(0, inkPos);\\n        strokeWidth = currentLineSegment.startWidth;\\n        strokeLength = 0.0f;\\n        inkPositions.Clear();\\n        inkPositions.Add(inkPos);\\n        newLine.transform.parent = lineContainer.transform;\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}},{\"finish_reason\":\"stop\",\"index\":3,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class PassthroughBrush : MonoBehaviour\\n{\\n    public OVRInput.Controller controllerHand = OVRInput.Controller.None;\\n    public GameObject lineSegmentPrefab;\\n    public GameObject lineContainer;\\n    public bool forceActive = true;\\n    LineRenderer currentLineSegment = null;\\n    List<Vector3> inkPositions = new List<Vector3>();\\n    float minInkDist = 0.01f;\\n    float strokeWidth = 0.1f;\\n    float strokeLength = 0.0f;\\n\\n    public enum BrushState\\n    {\\n        Idle,\\n        Inking\\n    };\\n\\n    BrushState brushStatus = BrushState.Idle;\\n\\n    private void OnDisable()\\n    {\\n        brushStatus = BrushState.Idle;\\n    }\\n\\n    void LateUpdate()\\n    {\\n        transform.rotation = Quaternion.LookRotation(transform.position - Camera.main.transform.position);\\n\\n        if (!(controllerHand == OVRInput.Controller.LTouch || controllerHand == OVRInput.Controller.RTouch))\\n        {\\n            return;\\n        }\\n\\n        Vector3 tipPosition = transform.position;\\n        switch (brushStatus)\\n        {\\n            case BrushState.Idle:\\n                if (OVRInput.GetUp(OVRInput.Button.One, controllerHand))\\n                {\\n                    UndoInkLine();\\n                }\\n\\n                if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    PrepareStartLine(tipPosition); // Prepare the line without instantiating it here\\n                    brushStatus = BrushState.Inking;\\n                }\\n\\n                break;\\n            case BrushState.Inking:\\n\\n                UpdateLine(tipPosition);\\n                if (OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    brushStatus = BrushState.Idle;\\n                }\\n\\n                break;\\n        }\\n    }\\n\\n    void PrepareStartLine(Vector3 inkPos)\\n    {\\n        StartCoroutine(DelayedStartLine(inkPos)); // Use a coroutine for handling line instantiation\\n    }\\n\\n    IEnumerator DelayedStartLine(Vector3 inkPos)\\n    {\\n        yield return null; // Wait until the next frame to avoid instantiation in Update()\\n\\n        GameObject newLine = Instantiate(lineSegmentPrefab, inkPos, Quaternion.identity);\\n        currentLineSegment = newLine.GetComponent<LineRenderer>();\\n        currentLineSegment.positionCount = 1;\\n        currentLineSegment.SetPosition(0, inkPos);\\n        strokeWidth = currentLineSegment.startWidth;\\n        strokeLength = 0.0f;\\n        inkPositions.Clear();\\n        inkPositions.Add(inkPos);\\n        newLine.transform.parent = lineContainer.transform;\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}},{\"finish_reason\":\"stop\",\"index\":4,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class PassthroughBrush : MonoBehaviour\\n{\\n    public OVRInput.Controller controllerHand = OVRInput.Controller.None;\\n    public GameObject lineSegmentPrefab;\\n    public GameObject lineContainer;\\n    public bool forceActive = true;\\n    LineRenderer currentLineSegment = null;\\n    List<Vector3> inkPositions = new List<Vector3>();\\n    float minInkDist = 0.01f;\\n    float strokeWidth = 0.1f;\\n    float strokeLength = 0.0f;\\n\\n    public enum BrushState\\n    {\\n        Idle,\\n        Inking\\n    };\\n\\n    BrushState brushStatus = BrushState.Idle;\\n\\n    private void OnDisable()\\n    {\\n        brushStatus = BrushState.Idle;\\n    }\\n\\n    private void Update()\\n    {\\n        transform.rotation = Quaternion.LookRotation(transform.position - Camera.main.transform.position);\\n\\n        if (!(controllerHand == OVRInput.Controller.LTouch || controllerHand == OVRInput.Controller.RTouch))\\n        {\\n            return;\\n        }\\n\\n        Vector3 tipPosition = transform.position;\\n        switch (brushStatus)\\n        {\\n            case BrushState.Idle:\\n                if (OVRInput.GetUp(OVRInput.Button.One, controllerHand))\\n                {\\n                    UndoInkLine();\\n                }\\n\\n                if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    StartNewLine(tipPosition); // Refactored to use object pooling or batching\\n                    brushStatus = BrushState.Inking;\\n                }\\n\\n                break;\\n            case BrushState.Inking:\\n                UpdateLine(tipPosition);\\n                if (OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    brushStatus = BrushState.Idle;\\n                }\\n\\n                break;\\n        }\\n    }\\n\\n    void StartNewLine(Vector3 inkPos)\\n    {\\n        GameObject newLine = CreateLineInstance(inkPos); // Uses a controlled instantiation method\\n        currentLineSegment = newLine.GetComponent<LineRenderer>();\\n        currentLineSegment.positionCount = 1;\\n        currentLineSegment.SetPosition(0, inkPos);\\n        strokeWidth = currentLineSegment.startWidth;\\n        strokeLength = 0.0f;\\n        inkPositions.Clear();\\n        inkPositions.Add(inkPos);\\n    }\\n\\n    GameObject CreateLineInstance(Vector3 position)\\n    {\\n        GameObject newLine = Instantiate(lineSegmentPrefab, position, Quaternion.identity);\\n        newLine.transform.parent = lineContainer.transform;\\n        return newLine;\\n    }\\n\\n    private void UndoInkLine()\\n    {\\n        if (lineContainer.transform.childCount > 0)\\n        {\\n            Transform lastLine = lineContainer.transform.GetChild(lineContainer.transform.childCount - 1);\\n            Destroy(lastLine.gameObject);\\n        }\\n    }\\n\\n    void UpdateLine(Vector3 newTipPosition)\\n    {\\n        if (currentLineSegment == null)\\n        {\\n            return;\\n        }\\n\\n        float distanceToLastPoint = Vector3.Distance(inkPositions[inkPositions.Count - 1], newTipPosition);\\n\\n        if (distanceToLastPoint > minInkDist)\\n        {\\n            inkPositions.Add(newTipPosition);\\n            currentLineSegment.positionCount = inkPositions.Count;\\n            currentLineSegment.SetPosition(inkPositions.Count - 1, newTipPosition);\\n            \\n            strokeLength += distanceToLastPoint;\\n        }\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1739932121,\"model\":\"gpt-4o-2024-11-20\",\"object\":\"chat.completion\",\"service_tier\":null,\"system_fingerprint\":\"fp_f3927aa00d\",\"usage\":{\"completion_tokens\":2866,\"prompt_tokens\":627,\"total_tokens\":3493,\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":0,\"rejected_prediction_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0}}}"