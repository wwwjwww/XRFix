"{\"id\":\"chatcmpl-B4fhAQoQ3KJvBpKfQBHSqlperEvwd\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class PassthroughBrush : MonoBehaviour\\n{\\n    public OVRInput.Controller controllerHand = OVRInput.Controller.None;\\n    public GameObject lineSegmentPrefab;\\n    public GameObject lineContainer;\\n    public bool forceActive = true;\\n    LineRenderer currentLineSegment = null;\\n    List<Vector3> inkPositions = new List<Vector3>();\\n    float minInkDist = 0.01f;\\n    float strokeWidth = 0.1f;\\n    float strokeLength = 0.0f;\\n    Queue<GameObject> linePool = new Queue<GameObject>();\\n    int poolSize = 10; // Set an appropriate pool size\\n\\n    public enum BrushState\\n    {\\n        Idle,\\n        Inking\\n    };\\n\\n    BrushState brushStatus = BrushState.Idle;\\n\\n    private void OnEnable()\\n    {\\n        // Pre-instantiate line segments and add them to the pool\\n        for (int i = 0; i < poolSize; i++)\\n        {\\n            GameObject newLineSegment = Instantiate(lineSegmentPrefab);\\n            newLineSegment.SetActive(false);\\n            newLineSegment.transform.parent = lineContainer.transform;\\n            linePool.Enqueue(newLineSegment);\\n        }\\n    }\\n\\n    private void OnDisable()\\n    {\\n        brushStatus = BrushState.Idle;\\n    }\\n\\n    void LateUpdate()\\n    {\\n        transform.rotation = Quaternion.LookRotation(transform.position - Camera.main.transform.position);\\n\\n        if (!(controllerHand == OVRInput.Controller.LTouch || controllerHand == OVRInput.Controller.RTouch))\\n        {\\n            return;\\n        }\\n\\n        Vector3 tipPosition = transform.position;\\n        switch (brushStatus)\\n        {\\n            case BrushState.Idle:\\n                if (OVRInput.GetUp(OVRInput.Button.One, controllerHand))\\n                {\\n                    UndoInkLine();\\n                }\\n\\n                if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    StartLine(tipPosition);\\n                    brushStatus = BrushState.Inking;\\n                }\\n\\n                break;\\n            case BrushState.Inking:\\n\\n                UpdateLine(tipPosition);\\n                if (OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    brushStatus = BrushState.Idle;\\n                }\\n\\n                break;\\n        }\\n    }\\n\\n    void StartLine(Vector3 inkPos)\\n    {\\n        if (linePool.Count > 0)\\n        {\\n            GameObject newLine = linePool.Dequeue();\\n            newLine.transform.position = inkPos;\\n            newLine.transform.rotation = Quaternion.identity;\\n            newLine.SetActive(true);\\n\\n            currentLineSegment = newLine.GetComponent<LineRenderer>();\\n            currentLineSegment.positionCount = 1;\\n            currentLineSegment.SetPosition(0, inkPos);\\n            strokeWidth = currentLineSegment.startWidth;\\n            strokeLength = 0.0f;\\n            inkPositions.Clear();\\n            inkPositions.Add(inkPos);\\n        }\\n    }\\n\\n    void UndoInkLine()\\n    {\\n        // Implement undo functionality, e.g., disable the last drawn line and return it to the pool\\n        if (currentLineSegment != null)\\n        {\\n            currentLineSegment.gameObject.SetActive(false);\\n            linePool.Enqueue(currentLineSegment.gameObject);\\n            currentLineSegment = null;\\n        }\\n    }\\n\\n    void UpdateLine(Vector3 tipPosition)\\n    {\\n        // Implement the logic to update the line with the current tip position\\n        if (currentLineSegment != null && inkPositions.Count > 0)\\n        {\\n            Vector3 lastPosition = inkPositions[inkPositions.Count - 1];\\n            if (Vector3.Distance(lastPosition, tipPosition) > minInkDist)\\n            {\\n                inkPositions.Add(tipPosition);\\n                currentLineSegment.positionCount = inkPositions.Count;\\n                currentLineSegment.SetPosition(inkPositions.Count - 1, tipPosition);\\n                strokeLength += Vector3.Distance(lastPosition, tipPosition);\\n            }\\n        }\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}},{\"finish_reason\":\"stop\",\"index\":1,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class PassthroughBrush : MonoBehaviour\\n{\\n    public OVRInput.Controller controllerHand = OVRInput.Controller.None;\\n    public GameObject lineSegmentPrefab;\\n    public GameObject lineContainer;\\n    public bool forceActive = true;\\n    LineRenderer currentLineSegment = null;\\n    List<Vector3> inkPositions = new List<Vector3>();\\n    float minInkDist = 0.01f;\\n    float strokeWidth = 0.1f;\\n    float strokeLength = 0.0f;\\n    Queue<GameObject> linePool = new Queue<GameObject>();\\n    int poolSize = 10; // Example pool size\\n\\n    public enum BrushState\\n    {\\n        Idle,\\n        Inking\\n    };\\n\\n    BrushState brushStatus = BrushState.Idle;\\n\\n    private void OnDisable()\\n    {\\n        brushStatus = BrushState.Idle;\\n    }\\n\\n    private void Start()\\n    {\\n        InitializeLinePool();\\n    }\\n\\n    void LateUpdate()\\n    {\\n        transform.rotation = Quaternion.LookRotation(transform.position - Camera.main.transform.position);\\n\\n        if (!(controllerHand == OVRInput.Controller.LTouch || controllerHand == OVRInput.Controller.RTouch))\\n        {\\n            return;\\n        }\\n\\n        Vector3 tipPosition = transform.position;\\n        switch (brushStatus)\\n        {\\n            case BrushState.Idle:\\n                if (OVRInput.GetUp(OVRInput.Button.One, controllerHand))\\n                {\\n                    UndoInkLine();\\n                }\\n\\n                if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    StartLine(tipPosition);\\n                    brushStatus = BrushState.Inking;\\n                }\\n\\n                break;\\n            case BrushState.Inking:\\n                UpdateLine(tipPosition);\\n                if (OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    brushStatus = BrushState.Idle;\\n                }\\n\\n                break;\\n        }\\n    }\\n\\n    void InitializeLinePool()\\n    {\\n        for (int i = 0; i < poolSize; i++)\\n        {\\n            GameObject lineObj = Instantiate(lineSegmentPrefab);\\n            lineObj.SetActive(false);\\n            linePool.Enqueue(lineObj);\\n            lineObj.transform.parent = lineContainer.transform;\\n        }\\n    }\\n\\n    GameObject GetPooledLine()\\n    {\\n        if (linePool.Count > 0)\\n        {\\n            GameObject lineObj = linePool.Dequeue();\\n            lineObj.SetActive(true);\\n            return lineObj;\\n        }\\n        else\\n        {\\n            // If the pool is empty, instantiate a new line (you might want to expand the pool instead)\\n            GameObject lineObj = Instantiate(lineSegmentPrefab);\\n            lineObj.transform.parent = lineContainer.transform;\\n            return lineObj;\\n        }\\n    }\\n\\n    void ReleaseLine(GameObject lineObj)\\n    {\\n        lineObj.SetActive(false);\\n        linePool.Enqueue(lineObj);\\n    }\\n\\n    void StartLine(Vector3 inkPos)\\n    {\\n        GameObject newLine = GetPooledLine(); \\n        currentLineSegment = newLine.GetComponent<LineRenderer>();\\n        currentLineSegment.positionCount = 1;\\n        currentLineSegment.SetPosition(0, inkPos);\\n        strokeWidth = currentLineSegment.startWidth;\\n        strokeLength = 0.0f;\\n        inkPositions.Clear();\\n        inkPositions.Add(inkPos);\\n        newLine.transform.position = inkPos;\\n        newLine.transform.rotation = Quaternion.identity;\\n    }\\n\\n    void UndoInkLine()\\n    {\\n        if (currentLineSegment != null)\\n        {\\n            ReleaseLine(currentLineSegment.gameObject);\\n            currentLineSegment = null;\\n        }\\n    }\\n\\n    void UpdateLine(Vector3 newPos)\\n    {\\n        if (currentLineSegment == null) return;\\n\\n        float dist = Vector3.Distance(inkPositions[inkPositions.Count - 1], newPos);\\n        if (dist > minInkDist)\\n        {\\n            inkPositions.Add(newPos);\\n            currentLineSegment.positionCount = inkPositions.Count;\\n            currentLineSegment.SetPosition(inkPositions.Count - 1, newPos);\\n            strokeLength += dist;\\n        }\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}},{\"finish_reason\":\"stop\",\"index\":2,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class PassthroughBrush : MonoBehaviour\\n{\\n    public OVRInput.Controller controllerHand = OVRInput.Controller.None;\\n    public GameObject lineSegmentPrefab;\\n    public GameObject lineContainer;\\n    public bool forceActive = true;\\n    LineRenderer currentLineSegment = null;\\n    List<Vector3> inkPositions = new List<Vector3>();\\n    float minInkDist = 0.01f;\\n    float strokeWidth = 0.1f;\\n    float strokeLength = 0.0f;\\n\\n    private Queue<GameObject> lineSegmentPool = new Queue<GameObject>();\\n    public int poolSize = 10;\\n\\n    public enum BrushState\\n    {\\n        Idle,\\n        Inking\\n    };\\n\\n    BrushState brushStatus = BrushState.Idle;\\n\\n    private void Awake()\\n    {\\n        for (int i = 0; i < poolSize; i++)\\n        {\\n            GameObject lineSegment = Instantiate(lineSegmentPrefab);\\n            lineSegment.SetActive(false);\\n            lineSegment.transform.parent = lineContainer.transform;\\n            lineSegmentPool.Enqueue(lineSegment);\\n        }\\n    }\\n\\n    private void OnDisable()\\n    {\\n        brushStatus = BrushState.Idle;\\n    }\\n\\n    void LateUpdate()\\n    {\\n        transform.rotation = Quaternion.LookRotation(transform.position - Camera.main.transform.position);\\n\\n        if (!(controllerHand == OVRInput.Controller.LTouch || controllerHand == OVRInput.Controller.RTouch))\\n        {\\n            return;\\n        }\\n\\n        Vector3 tipPosition = transform.position;\\n        switch (brushStatus)\\n        {\\n            case BrushState.Idle:\\n                if (OVRInput.GetUp(OVRInput.Button.One, controllerHand))\\n                {\\n                    UndoInkLine();\\n                }\\n\\n                if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    StartLine(tipPosition);\\n                    brushStatus = BrushState.Inking;\\n                }\\n\\n                break;\\n            case BrushState.Inking:\\n\\n                UpdateLine(tipPosition);\\n                if (OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    brushStatus = BrushState.Idle;\\n                }\\n\\n                break;\\n        }\\n    }\\n\\n    void StartLine(Vector3 inkPos)\\n    {\\n        if (lineSegmentPool.Count == 0)\\n        {\\n            Debug.LogWarning(\\\"Line segment pool is empty. Consider increasing pool size.\\\");\\n            return;\\n        }\\n\\n        GameObject newLine = lineSegmentPool.Dequeue();\\n        newLine.transform.position = inkPos;\\n        newLine.transform.rotation = Quaternion.identity;\\n        newLine.SetActive(true);\\n\\n        currentLineSegment = newLine.GetComponent<LineRenderer>();\\n        currentLineSegment.positionCount = 1;\\n        currentLineSegment.SetPosition(0, inkPos);\\n        strokeWidth = currentLineSegment.startWidth;\\n        strokeLength = 0.0f;\\n        inkPositions.Clear();\\n        inkPositions.Add(inkPos);\\n    }\\n\\n    private void UndoInkLine()\\n    {\\n        if (currentLineSegment != null)\\n        {\\n            currentLineSegment.gameObject.SetActive(false);\\n            lineSegmentPool.Enqueue(currentLineSegment.gameObject);\\n            currentLineSegment = null;\\n        }\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}},{\"finish_reason\":\"stop\",\"index\":3,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class PassthroughBrush : MonoBehaviour\\n{\\n    public OVRInput.Controller controllerHand = OVRInput.Controller.None;\\n    public GameObject lineSegmentPrefab;\\n    public GameObject lineContainer;\\n    public bool forceActive = true;\\n    LineRenderer currentLineSegment = null;\\n    List<Vector3> inkPositions = new List<Vector3>();\\n    float minInkDist = 0.01f;\\n    float strokeWidth = 0.1f;\\n    float strokeLength = 0.0f;\\n    private Queue<GameObject> lineSegmentPool = new Queue<GameObject>();\\n    private const int initialPoolSize = 10;\\n\\n    public enum BrushState\\n    {\\n        Idle,\\n        Inking\\n    };\\n\\n    BrushState brushStatus = BrushState.Idle;\\n\\n    private void Awake()\\n    {\\n        for (int i = 0; i < initialPoolSize; i++)\\n        {\\n            GameObject newLineSegment = Instantiate(lineSegmentPrefab);\\n            newLineSegment.SetActive(false);\\n            lineSegmentPool.Enqueue(newLineSegment);\\n        }\\n    }\\n\\n    private void OnDisable()\\n    {\\n        brushStatus = BrushState.Idle;\\n    }\\n\\n    void LateUpdate()\\n    {\\n        transform.rotation = Quaternion.LookRotation(transform.position - Camera.main.transform.position);\\n\\n        if (!(controllerHand == OVRInput.Controller.LTouch || controllerHand == OVRInput.Controller.RTouch))\\n        {\\n            return;\\n        }\\n\\n        Vector3 tipPosition = transform.position;\\n        switch (brushStatus)\\n        {\\n            case BrushState.Idle:\\n                if (OVRInput.GetUp(OVRInput.Button.One, controllerHand))\\n                {\\n                    UndoInkLine();\\n                }\\n\\n                if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    StartLine(tipPosition);\\n                    brushStatus = BrushState.Inking;\\n                }\\n\\n                break;\\n            case BrushState.Inking:\\n                UpdateLine(tipPosition);\\n                if (OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    brushStatus = BrushState.Idle;\\n                }\\n\\n                break;\\n        }\\n    }\\n\\n    void StartLine(Vector3 inkPos)\\n    {\\n        GameObject newLine;\\n        if (lineSegmentPool.Count > 0)\\n        {\\n            newLine = lineSegmentPool.Dequeue();\\n            newLine.transform.position = inkPos;\\n            newLine.transform.rotation = Quaternion.identity;\\n            newLine.SetActive(true);\\n        }\\n        else\\n        {\\n            newLine = Instantiate(lineSegmentPrefab, inkPos, Quaternion.identity);\\n        }\\n\\n        currentLineSegment = newLine.GetComponent<LineRenderer>();\\n        currentLineSegment.positionCount = 1;\\n        currentLineSegment.SetPosition(0, inkPos);\\n        strokeWidth = currentLineSegment.startWidth;\\n        strokeLength = 0.0f;\\n        inkPositions.Clear();\\n        inkPositions.Add(inkPos);\\n        newLine.transform.parent = lineContainer.transform;\\n    }\\n\\n    private void UndoInkLine()\\n    {\\n        if (currentLineSegment != null)\\n        {\\n            currentLineSegment.gameObject.SetActive(false);\\n            lineSegmentPool.Enqueue(currentLineSegment.gameObject);\\n            currentLineSegment = null;\\n            inkPositions.Clear();\\n        }\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}},{\"finish_reason\":\"stop\",\"index\":4,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class PassthroughBrush : MonoBehaviour\\n{\\n    public OVRInput.Controller controllerHand = OVRInput.Controller.None;\\n    public GameObject lineSegmentPrefab;\\n    public GameObject lineContainer;\\n    public bool forceActive = true;\\n    LineRenderer currentLineSegment = null;\\n    List<Vector3> inkPositions = new List<Vector3>();\\n    float minInkDist = 0.01f;\\n    float strokeWidth = 0.1f;\\n    float strokeLength = 0.0f;\\n\\n    private Queue<GameObject> lineObjectPool = new Queue<GameObject>();\\n    public int poolSize = 10;\\n\\n    public enum BrushState\\n    {\\n        Idle,\\n        Inking\\n    };\\n\\n    BrushState brushStatus = BrushState.Idle;\\n\\n    private void Start()\\n    {\\n        for (int i = 0; i < poolSize; i++)\\n        {\\n            GameObject lineObject = Instantiate(lineSegmentPrefab);\\n            lineObject.SetActive(false);\\n            lineObjectPool.Enqueue(lineObject);\\n        }\\n    }\\n\\n    private void OnDisable()\\n    {\\n        brushStatus = BrushState.Idle;\\n    }\\n\\n    void LateUpdate()\\n    {\\n        transform.rotation = Quaternion.LookRotation(transform.position - Camera.main.transform.position);\\n\\n        if (!(controllerHand == OVRInput.Controller.LTouch || controllerHand == OVRInput.Controller.RTouch))\\n        {\\n            return;\\n        }\\n\\n        Vector3 tipPosition = transform.position;\\n        switch (brushStatus)\\n        {\\n            case BrushState.Idle:\\n                if (OVRInput.GetUp(OVRInput.Button.One, controllerHand))\\n                {\\n                    UndoInkLine();\\n                }\\n\\n                if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    StartLine(tipPosition);\\n                    brushStatus = BrushState.Inking;\\n                }\\n\\n                break;\\n            case BrushState.Inking:\\n\\n                UpdateLine(tipPosition);\\n                if (OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, controllerHand))\\n                {\\n                    brushStatus = BrushState.Idle;\\n                }\\n\\n                break;\\n        }\\n    }\\n\\n    void StartLine(Vector3 inkPos)\\n    {\\n        GameObject newLine;\\n        if (lineObjectPool.Count > 0)\\n        {\\n            newLine = lineObjectPool.Dequeue();\\n            newLine.transform.position = inkPos;\\n            newLine.SetActive(true);\\n        }\\n        else\\n        {\\n            newLine = Instantiate(lineSegmentPrefab, inkPos, Quaternion.identity);\\n        }\\n\\n        currentLineSegment = newLine.GetComponent<LineRenderer>();\\n        currentLineSegment.positionCount = 1;\\n        currentLineSegment.SetPosition(0, inkPos);\\n        strokeWidth = currentLineSegment.startWidth;\\n        strokeLength = 0.0f;\\n        inkPositions.Clear();\\n        inkPositions.Add(inkPos);\\n        newLine.transform.parent = lineContainer.transform;\\n    }\\n\\n    void UndoInkLine()\\n    {\\n        if (currentLineSegment != null)\\n        {\\n            currentLineSegment.gameObject.SetActive(false);\\n            lineObjectPool.Enqueue(currentLineSegment.gameObject);\\n            currentLineSegment = null;\\n        }\\n    }\\n\\n    void UpdateLine(Vector3 inkPos)\\n    {\\n        if (currentLineSegment != null)\\n        {\\n            Vector3 lastPos = inkPositions[inkPositions.Count - 1];\\n            if (Vector3.Distance(lastPos, inkPos) > minInkDist)\\n            {\\n                inkPositions.Add(inkPos);\\n                currentLineSegment.positionCount++;\\n                currentLineSegment.SetPosition(currentLineSegment.positionCount - 1, inkPos);\\n                strokeLength += Vector3.Distance(lastPos, inkPos);\\n            }\\n        }\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1740453288,\"model\":\"gpt-4o-2024-08-06\",\"object\":\"chat.completion\",\"service_tier\":\"default\",\"system_fingerprint\":\"fp_eb9dce56a8\",\"usage\":{\"completion_tokens\":3796,\"prompt_tokens\":704,\"total_tokens\":4500,\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":0,\"rejected_prediction_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0}}}"