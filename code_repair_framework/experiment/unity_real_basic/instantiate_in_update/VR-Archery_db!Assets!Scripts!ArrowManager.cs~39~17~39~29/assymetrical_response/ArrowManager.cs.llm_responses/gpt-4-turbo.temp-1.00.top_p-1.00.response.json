"{\"id\":\"chatcmpl-B4ftEAlWbjZhPKLg2TzN0bX0PovvP\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class ArrowManager : MonoBehaviour\\n{\\n    private GameObject currentArrow;\\n    private Queue<GameObject> arrowPool = new Queue<GameObject>(); // Object pool for arrows\\n    public static ArrowManager Instance;\\n    public OVRInput.Controller controller;\\n    public GameObject controler;\\n    public GameObject arrowPrefab;\\n    public GameObject LastArrow;\\n    public GameObject arrowStartPoint;\\n    public TextMesh debug;\\n    private bool hasArrow = false;\\n    private bool isAttached = false;\\n    public int poolSize = 10;  // Set a pool size\\n\\n    void Awake()\\n    {\\n        if (Instance == null)\\n            Instance = this;\\n        \\n        // Initialize arrow pool\\n        for (int i = 0; i < poolSize; i++)\\n        {\\n            GameObject arrow = Instantiate(arrowPrefab);\\n            arrow.SetActive(false);\\n            arrowPool.Enqueue(arrow);\\n        }\\n    }\\n\\n    void OnDestroy()\\n    {\\n        if (Instance == this)\\n            Instance = null;\\n    }\\n\\n    void Update()\\n    {\\n        debug.text = controler.transform.rotation.x.ToString() +\\n                     \\\"\\\\n\\\" + controler.transform.rotation.y.ToString() +\\n                     \\\"\\\\n\\\" + controler.transform.rotation.z.ToString();\\n        if (OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) > 0)\\n        {\\n            if (!hasArrow)\\n            {\\n                AttachArrow();\\n            }\\n            else if (isAttached)\\n            {\\n                Fire();\\n            }\\n        }\\n        else ThrowArrow();\\n    }\\n\\n    public void AttachArrow()\\n    {\\n        if (currentArrow == null && arrowPool.Count > 0)\\n        {\\n            currentArrow = arrowPool.Dequeue();\\n            currentArrow.SetActive(true);\\n            currentArrow.transform.SetParent(controler.transform);\\n            currentArrow.transform.localPosition = new Vector3(0.1f, 0f, 0.3f);\\n            currentArrow.GetComponent<Rigidbody>().isKinematic = true;\\n            hasArrow = true;\\n        }\\n    }\\n\\n    void Fire()\\n    {\\n        if (currentArrow != null)\\n        {\\n            currentArrow.transform.SetParent(null);\\n            currentArrow.GetComponent<Rigidbody>().isKinematic = false;\\n            isAttached = false;\\n            hasArrow = false;\\n            // Optionally re-add the arrow back to the pool after firing\\n            ReturnArrowToPool(currentArrow);\\n\\n            currentArrow = null;\\n        }\\n    }\\n    \\n    void ThrowArrow()\\n    {\\n        if (currentArrow != null && hasArrow)\\n        {\\n            currentArrow.transform.SetParent(null);\\n            currentArrow.GetComponent<Rigidbody>().isKinematic = false;\\n            hasArrow = false;\\n            ReturnArrowToPool(currentArrow);\\n\\n            currentArrow = null;\\n        }\\n    }\\n\\n    void ReturnArrowToPool(GameObject arrow)\\n    {\\n        arrow.SetActive(false);\\n        arrowPool.Enqueue(arrow);\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}},{\"finish_reason\":\"stop\",\"index\":1,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class ArrowManager : MonoBehaviour\\n{\\n    private GameObject currentArrow;\\n    public static ArrowManager Instance;\\n    public OVRInput.Controller controller;\\n    public GameObject controler;\\n    public GameObject arrowPrefab;\\n    public GameObject LastArrow;\\n    public GameObject arrowStartPoint;\\n    public TextMesh debug;\\n    private bool hasArrow = false;\\n    private bool isAttached = false;\\n    private Queue<GameObject> arrowPool = new Queue<GameObject>();\\n    public int poolSize = 10; // Pool size can be adjusted as needed\\n\\n    void Awake()\\n    {\\n        if (Instance == null)\\n            Instance = this;\\n        \\n        // Initialize the arrow object pool\\n        for (int i = 0; i < poolSize; i++)\\n        {\\n            GameObject arrow = Instantiate(arrowPrefab);\\n            arrow.SetActive(false);\\n            arrowPool.Enqueue(arrow);\\n        }\\n    }\\n\\n    void OnDestroy()\\n    {\\n        if (Instance == this)\\n            Instance = null;\\n    }\\n\\n    void Update()\\n    {\\n        debug.text = controler.transform.rotation.x.ToString() +\\n                     \\\"\\\\n\\\" + controler.transform.rotation.y.ToString() +\\n                     \\\"\\\\n\\\" + controler.transform.rotation.z.ToString();\\n        if (OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) > 0)\\n        {\\n            if (!hasArrow)\\n            {\\n                AttachArrow();\\n            } \\n            else if (isAttached) \\n            {\\n                Fire();\\n            }\\n        }\\n        else \\n        {\\n            ThrowArrow();\\n        }\\n    }\\n\\n    public void AttachArrow()\\n    {\\n        if (currentArrow == null && arrowPool.Count > 0)\\n        {\\n            currentArrow = arrowPool.Dequeue();\\n            currentArrow.transform.SetParent(controler.transform);\\n            currentArrow.transform.localPosition = new Vector3(0.1f, 0f, 0.3f);\\n            currentArrow.GetComponent<Rigidbody>().isKinematic = true;\\n            currentArrow.SetActive(true);\\n            hasArrow = true;\\n        }\\n    }\\n\\n    public void Fire()\\n    {\\n        // Implement Fire logic...\\n        // After firing, you can deactivate the arrow and return it to the pool\\n        if (currentArrow != null)\\n        {\\n            currentArrow.SetActive(false);\\n            arrowPool.Enqueue(currentArrow);\\n            currentArrow = null;\\n            hasArrow = false;\\n        }\\n    }\\n\\n    public void ThrowArrow()\\n    {\\n        // Implement Throw logic...\\n        // Ensure the arrow is deactivated and returned to the pool after throwing\\n        if (currentArrow != null)\\n        {\\n            currentArrow.SetActive(false);\\n            arrowPool.Enqueue(currentArrow);\\n            currentArrow = null;\\n            hasArrow = false;\\n        }\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}},{\"finish_reason\":\"stop\",\"index\":2,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class ArrowManager : MonoBehaviour\\n{\\n    private GameObject currentArrow;\\n    public static ArrowManager Instance;\\n    public OVRInput.Controller controller;\\n    public GameObject controler;\\n    public GameObject arrowPrefab;\\n    public GameObject LastArrow;\\n    public GameObject arrowStartPoint;\\n    public TextMesh debug;\\n    private bool hasArrow = false;\\n    private bool isAttached = false;\\n\\n    private Queue<GameObject> arrowPool;\\n    public int poolSize = 10;\\n\\n    void Awake()\\n    {\\n        if (Instance == null)\\n            Instance = this;\\n\\n        BuildArrowPool();\\n    }\\n\\n    void OnDestroy()\\n    {\\n        if (Instance == this)\\n            Instance = null;\\n    }\\n\\n    void Update()\\n    {\\n        debug.text = controler.transform.rotation.x.ToString() +\\n                     \\\"\\\\n\\\" + controler.transform.rotation.y.ToString() +\\n                     \\\"\\\\n\\\" + controler.transform.rotation.z.ToString();\\n\\n        if (OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) > 0)\\n        {\\n            if (!hasArrow)\\n            {\\n                AttachArrow();\\n            } \\n            else if (isAttached) \\n            {\\n                Fire();\\n            }\\n        }\\n        else \\n        {\\n            ThrowArrow();\\n        }\\n    }\\n    \\n    public void AttachArrow()\\n    {\\n        if (currentArrow == null && arrowPool.Count > 0)\\n        {\\n            currentArrow = arrowPool.Dequeue();\\n            currentArrow.transform.SetParent(controler.transform);\\n            currentArrow.transform.localPosition = new Vector3(0.1f, 0f, 0.3f);\\n            currentArrow.GetComponent<Rigidbody>().isKinematic = true;\\n            currentArrow.SetActive(true);\\n            hasArrow = true;\\n        }\\n    }\\n\\n    private void BuildArrowPool()\\n    {\\n        arrowPool = new Queue<GameObject>();\\n\\n        for (int i = 0; i < poolSize; i++)\\n        {\\n            GameObject arrow = Instantiate(arrowPrefab);\\n            arrow.SetActive(false);\\n            arrowPool.Enqueue(arrow);\\n        }\\n    }\\n\\n    private void Fire()\\n    {\\n        // Implementation for firing the arrow and returning it to the pool\\n        if(currentArrow != null)\\n        {\\n            currentArrow.GetComponent<Rigidbody>().isKinematic = false;\\n            currentArrow.transform.SetParent(null);\\n            // Add force/velocity to currentArrow here\\n\\n            // Return currentArrow to pool after a delay\\n            StartCoroutine(ReturnArrowToPool(currentArrow));\\n\\n            currentArrow = null;\\n            hasArrow = false;\\n        }\\n    }\\n\\n    private IEnumerator ReturnArrowToPool(GameObject arrow)\\n    {\\n        yield return new WaitForSeconds(5); // Wait for 5 seconds or till the arrow reaches a certain condition\\n\\n        arrow.SetActive(false);\\n        arrowPool.Enqueue(arrow);\\n    }\\n\\n    private void ThrowArrow()\\n    {\\n        // Implementation for handling arrow throwing logic, if necessary\\n        if (hasArrow && currentArrow != null)\\n        {\\n            currentArrow.GetComponent<Rigidbody>().isKinematic = false;\\n            currentArrow.transform.SetParent(null);\\n            // Add logic to throw the arrow if necessary\\n\\n            StartCoroutine(ReturnArrowToPool(currentArrow));\\n\\n            currentArrow = null;\\n            hasArrow = false;\\n        }\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}},{\"finish_reason\":\"stop\",\"index\":3,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class ArrowManager : MonoBehaviour\\n{\\n    private GameObject currentArrow;\\n    public static ArrowManager Instance;\\n    public OVRInput.Controller controller;\\n    public GameObject controler;\\n    public GameObject arrowPrefab;\\n    public GameObject LastArrow;\\n    public GameObject arrowStartPoint;\\n    public TextMesh debug;\\n    private bool hasArrow = false;\\n    private bool isAttached = false;\\n    private Queue<GameObject> arrowPool = new Queue<GameObject>();\\n    public int poolSize = 10; // Define the size of the pool\\n\\n    void Awake()\\n    {\\n        if (Instance == null)\\n            Instance = this;\\n        \\n        InitializeArrowPool();\\n    }\\n\\n    void OnDestroy()\\n    {\\n        if (Instance == this)\\n            Instance = null;\\n    }\\n\\n    void InitializeArrowPool()\\n    {\\n        for (int i = 0; i < poolSize; i++)\\n        {\\n            GameObject arrow = Instantiate(arrowPrefab);\\n            arrow.SetActive(false);\\n            arrowPool.Enqueue(arrow);\\n        }\\n    }\\n\\n    GameObject GetPooledArrow()\\n    {\\n        if (arrowPool.Count > 0)\\n        {\\n            GameObject arrow = arrowPool.Dequeue();\\n            arrow.SetActive(true);\\n            return arrow;\\n        }\\n        return Instantiate(arrowPrefab);\\n    }\\n\\n    void ReturnArrowToPool(GameObject arrow)\\n    {\\n        arrow.SetActive(false);\\n        arrowPool.Enqueue(arrow);\\n    }\\n\\n    void Update()\\n    {\\n        debug.text = controler.transform.rotation.x.ToString() +\\n                     \\\"\\\\n\\\" + controler.transform.rotation.y.ToString() +\\n                     \\\"\\\\n\\\" + controler.transform.rotation.z.ToString();\\n\\n        if (OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) > 0)\\n        {\\n            if (!hasArrow)\\n            {\\n                AttachArrow();\\n            }\\n            else if (isAttached)\\n            {\\n                Fire();\\n            }\\n        }\\n        else \\n        {\\n            ThrowArrow();\\n        }\\n    }\\n\\n    public void AttachArrow()\\n    {\\n        if (currentArrow == null)\\n        {\\n            currentArrow = GetPooledArrow();\\n            currentArrow.transform.SetParent(controler.transform);\\n            currentArrow.transform.localPosition = new Vector3(0.1f, 0f, 0.3f);\\n            currentArrow.GetComponent<Rigidbody>().isKinematic = true;\\n            hasArrow = true;\\n        }\\n    }\\n\\n    public void Fire()\\n    {\\n        if (currentArrow != null)\\n        {\\n            currentArrow.GetComponent<Rigidbody>().isKinematic = false;\\n            // Add fire logic here\\n            isAttached = false;\\n            hasArrow = false;\\n            ReturnArrowToPool(currentArrow);\\n            currentArrow = null;\\n        }\\n    }\\n\\n    public void ThrowArrow()\\n    {\\n        if (currentArrow != null && isAttached)\\n        {\\n            currentArrow.GetComponent<Rigidbody>().isKinematic = false;\\n            // Add throw logic here\\n            isAttached = false;\\n            hasArrow = false;\\n            ReturnArrowToPool(currentArrow);\\n            currentArrow = null;\\n        }\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}},{\"finish_reason\":\"stop\",\"index\":4,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class ArrowManager : MonoBehaviour\\n{\\n    private GameObject currentArrow;\\n    public static ArrowManager Instance;\\n    public OVRInput.Controller controller;\\n    public GameObject controler;\\n    public GameObject arrowPrefab;\\n    public GameObject LastArrow;\\n    public GameObject arrowStartPoint;\\n    public TextMesh debug;\\n    private bool hasArrow = false;\\n    private bool isAttached = false;\\n    private Queue<GameObject> arrowPool = new Queue<GameObject>();\\n    public int poolSize = 10; // Adjust the pool size as necessary\\n\\n    void Awake()\\n    {\\n        if (Instance == null)\\n            Instance = this;\\n            \\n        InitializeArrowPool();\\n    }\\n\\n    void OnDestroy()\\n    {\\n        if (Instance == this)\\n            Instance = null;\\n    }\\n\\n    void InitializeArrowPool()\\n    {\\n        for(int i = 0; i < poolSize; i++)\\n        {\\n            GameObject arrow = Instantiate(arrowPrefab);\\n            arrow.SetActive(false);\\n            arrowPool.Enqueue(arrow);\\n        }\\n    }\\n\\n    GameObject GetArrowFromPool()\\n    {\\n        if(arrowPool.Count > 0)\\n        {\\n            GameObject arrow = arrowPool.Dequeue();\\n            arrow.SetActive(true);\\n            return arrow;\\n        }\\n        else\\n        {\\n            // If pool is empty, create a new arrow (consider increasing poolSize instead)\\n            return Instantiate(arrowPrefab);\\n        }\\n    }\\n\\n    void ReturnArrowToPool(GameObject arrow)\\n    {\\n        arrow.SetActive(false);\\n        arrowPool.Enqueue(arrow);\\n    }\\n\\n    void Update()\\n    {\\n        debug.text = controler.transform.rotation.x.ToString() +\\n                     \\\"\\\\n\\\" + controler.transform.rotation.y.ToString() +\\n                     \\\"\\\\n\\\" + controler.transform.rotation.z.ToString();\\n\\n        if (OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) > 0)\\n        {\\n            if (!hasArrow)\\n            {\\n                AttachArrow();\\n            }\\n            else if (isAttached)\\n            {\\n                Fire();\\n            }\\n        }\\n        else \\n        {\\n            ThrowArrow();\\n        }\\n    }\\n    \\n    public void AttachArrow()\\n    {\\n        if (currentArrow == null)\\n        {\\n            currentArrow = GetArrowFromPool();\\n            currentArrow.transform.SetParent(controler.transform);\\n            currentArrow.transform.localPosition = new Vector3(0.1f, 0f, 0.3f);\\n            currentArrow.GetComponent<Rigidbody>().isKinematic = true;\\n            hasArrow = true;\\n        }\\n    }\\n\\n    // Assume Fire and ThrowArrow are defined and correctly utilizing the pool.\\n    public void Fire() { /* Implementation */ }\\n    public void ThrowArrow() { /* Implementation */ }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null}}],\"created\":1740454036,\"model\":\"gpt-4o-2024-08-06\",\"object\":\"chat.completion\",\"service_tier\":\"default\",\"system_fingerprint\":\"fp_eb9dce56a8\",\"usage\":{\"completion_tokens\":3109,\"prompt_tokens\":498,\"total_tokens\":3607,\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":0,\"rejected_prediction_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0}}}"