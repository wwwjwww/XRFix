"{\"id\":\"chatcmpl-Bq9ifGhTkbS2IeGun91S3sUZjCVgi\",\"choices\":[{\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nprivate Dictionary<int, timelineEvent> toRecord = new Dictionary<int, timelineEvent>();\\n\\nvoid Update() {\\n    playheadScrubbing = playheadHandle.curState == manipObject.manipState.grabbed;\\n\\n    if (!playheadScrubbing) updatePlayhead();\\n    else {\\n        playheadHandle.xBounds.y = _deviceInterface._gridParams.UnittoX(_deviceInterface._gridParams.head_tail.x);\\n        playheadHandle.xBounds.x = _deviceInterface._gridParams.UnittoX(_deviceInterface._gridParams.head_tail.y);\\n        curGridPosition = _deviceInterface._gridParams.XtoUnit(playheadHandle.transform.localPosition.x);\\n        timelineEventUpdate();\\n    }\\n\\n    lock (_recordLock) {\\n        foreach (KeyValuePair<int, timelineEvent> entry in toRecord) {\\n            entry.Value.setRecord(true);\\n            activeEvents[entry.Key] = entry.Value;\\n            activeEvents[entry.Key].setOut(entry.Value.GetStart() + .01f);\\n            activeEvents[entry.Key].overlapCheck();\\n        }\\n\\n        toRecord.Clear();\\n    }\\n}\\n\\n// Initialize new event objects outside of the Update method\\nprivate void QueueNewTimelineEvent(int key, float value) {\\n    if (!toRecord.ContainsKey(key)) {\\n        toRecord[key] = _deviceInterface.SpawnTimelineEvent(key, new Vector2(value, value + .01f));\\n    }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}},{\"finish_reason\":\"stop\",\"index\":1,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class timelinePlayer : MonoBehaviour {\\n  public xHandle playheadHandle;\\n  timelineComponentInterface _deviceInterface;\\n  float lastBeatTime = 0;\\n\\n  float curGridPosition;\\n\\n  public bool looping = true;\\n\\n  Dictionary<int, timelineEvent> activeEvents = new Dictionary<int, timelineEvent>();\\n  private Dictionary<int, Vector2> toRecordBuffer = new Dictionary<int, Vector2>(); // Pre-allocated buffer\\n\\n  void Awake() {\\n    _deviceInterface = GetComponent<timelineComponentInterface>();\\n  }\\n\\n  void Start() {\\n    masterControl.instance.beatUpdateEvent += beatUpdateEvent;\\n    masterControl.instance.beatResetEvent += beatResetEvent;\\n  }\\n\\n  void OnDestroy() {\\n    masterControl.instance.beatUpdateEvent -= beatUpdateEvent;\\n    masterControl.instance.beatResetEvent -= beatResetEvent;\\n  }\\n\\n  void beatResetEvent() {\\n    lastBeatTime = 0;\\n    Back();\\n  }\\n\\n  public void setRecord(bool on) {\\n    List<int> keys = new List<int>(activeEvents.Keys);\\n    foreach (int n in keys) {\\n      activeEvents[n].setRecord(false);\\n      activeEvents.Remove(n);\\n    }\\n  }\\n\\n  void updatePlayhead() {\\n    if (_deviceInterface._gridParams.isOnGrid(curGridPosition)) {\\n      playheadHandle.gameObject.SetActive(true);\\n      Vector3 pos = playheadHandle.transform.localPosition;\\n      pos.x = _deviceInterface._gridParams.UnittoX(curGridPosition);\\n      playheadHandle.transform.localPosition = pos;\\n    } else playheadHandle.gameObject.SetActive(false);\\n  }\\n\\n  List<int> loopKeys = new List<int>();\\n  void loopActiveEvents() {\\n    loopKeys = new List<int>(activeEvents.Keys);\\n    foreach (int n in loopKeys) {\\n      activeEvents[n].setOut(_deviceInterface._gridParams.head_tail.y);\\n      activeEvents[n].setRecord(false);\\n      activeEvents.Remove(n);\\n    }\\n  }\\n\\n  public void Back() {\\n    curGridPosition = _deviceInterface._gridParams.head_tail.x;\\n  }\\n\\n  bool playheadScrubbing = false;\\n\\n  void Update() {\\n    playheadScrubbing = playheadHandle.curState == manipObject.manipState.grabbed;\\n\\n    if (!playheadScrubbing) updatePlayhead();\\n    else {\\n      playheadHandle.xBounds.y = _deviceInterface._gridParams.UnittoX(_deviceInterface._gridParams.head_tail.x);\\n      playheadHandle.xBounds.x = _deviceInterface._gridParams.UnittoX(_deviceInterface._gridParams.head_tail.y);\\n      curGridPosition = _deviceInterface._gridParams.XtoUnit(playheadHandle.transform.localPosition.x);\\n      timelineEventUpdate();\\n    }\\n\\n    lock (_recordLock) {\\n      if (toRecord.Keys.Count > 0) {\\n        toRecordBuffer.Clear();\\n        foreach (KeyValuePair<int, float> entry in toRecord) {\\n          toRecordBuffer[entry.Key] = new Vector2(entry.Value, entry.Value + .01f); // Preallocate vectors outside Update\\n        }\\n\\n        foreach (KeyValuePair<int, Vector2> entry in toRecordBuffer) {\\n          activeEvents[entry.Key] = _deviceInterface.SpawnTimelineEvent(entry.Key, entry.Value);\\n          activeEvents[entry.Key].setRecord(true);\\n          activeEvents[entry.Key].setOut(entry.Value.y);\\n          activeEvents[entry.Key].overlapCheck();\\n        }\\n\\n        toRecord.Clear();\\n      }\\n    }\\n  }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}},{\"finish_reason\":\"stop\",\"index\":2,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class timelinePlayer : MonoBehaviour {\\n  public xHandle playheadHandle;\\n  timelineComponentInterface _deviceInterface;\\n  float lastBeatTime = 0;\\n\\n  float curGridPosition;\\n\\n  public bool looping = true;\\n\\n  Dictionary<int, timelineEvent> activeEvents = new Dictionary<int, timelineEvent>();\\n\\n  void Awake() {\\n    _deviceInterface = GetComponent<timelineComponentInterface>();\\n  }\\n\\n  void Start() {\\n    masterControl.instance.beatUpdateEvent += beatUpdateEvent;\\n    masterControl.instance.beatResetEvent += beatResetEvent;\\n  }\\n\\n  void OnDestroy() {\\n    masterControl.instance.beatUpdateEvent -= beatUpdateEvent;\\n    masterControl.instance.beatResetEvent -= beatResetEvent;\\n  }\\n\\n  void beatResetEvent() {\\n    lastBeatTime = 0;\\n    Back();\\n  }\\n\\n  public void setRecord(bool on) {\\n    List<int> keys = new List<int>(activeEvents.Keys);\\n    foreach (int n in keys) {\\n      activeEvents[n].setRecord(false);\\n      activeEvents.Remove(n);\\n    }\\n  }\\n\\n  void updatePlayhead() {\\n    if (_deviceInterface._gridParams.isOnGrid(curGridPosition)) {\\n      playheadHandle.gameObject.SetActive(true);\\n      Vector3 pos = playheadHandle.transform.localPosition;\\n      pos.x = _deviceInterface._gridParams.UnittoX(curGridPosition);\\n      playheadHandle.transform.localPosition = pos;\\n    } else playheadHandle.gameObject.SetActive(false);\\n  }\\n\\n  List<int> loopKeys = new List<int>();\\n  void loopActiveEvents() {\\n    loopKeys = new List<int>(activeEvents.Keys);\\n    foreach (int n in loopKeys) {\\n      activeEvents[n].setOut(_deviceInterface._gridParams.head_tail.y);\\n      activeEvents[n].setRecord(false);\\n      activeEvents.Remove(n);\\n    }\\n  }\\n\\n  public void Back() {\\n    curGridPosition = _deviceInterface._gridParams.head_tail.x;\\n  }\\n\\n  bool playheadScrubbing = false;\\n\\n  private Vector2 tempVector2 = new Vector2();\\n\\n  void Update() {\\n    playheadScrubbing = playheadHandle.curState == manipObject.manipState.grabbed;\\n\\n    if (!playheadScrubbing) updatePlayhead();\\n    else {\\n      playheadHandle.xBounds.y = _deviceInterface._gridParams.UnittoX(_deviceInterface._gridParams.head_tail.x);\\n      playheadHandle.xBounds.x = _deviceInterface._gridParams.UnittoX(_deviceInterface._gridParams.head_tail.y);\\n      curGridPosition = _deviceInterface._gridParams.XtoUnit(playheadHandle.transform.localPosition.x);\\n      timelineEventUpdate();\\n    }\\n\\n    lock (_recordLock) {\\n      if (toRecord.Keys.Count > 0) {\\n        foreach (KeyValuePair<int, float> entry in toRecord) {\\n          tempVector2.x = entry.Value;\\n          tempVector2.y = entry.Value + .01f;\\n          activeEvents[entry.Key] = _deviceInterface.SpawnTimelineEvent(entry.Key, tempVector2);\\n          activeEvents[entry.Key].setRecord(true);\\n          activeEvents[entry.Key].setOut(entry.Value + .01f);\\n          activeEvents[entry.Key].overlapCheck();\\n        }\\n\\n        toRecord.Clear();\\n      }\\n    }\\n  }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}},{\"finish_reason\":\"stop\",\"index\":3,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class timelinePlayer : MonoBehaviour {\\n  public xHandle playheadHandle;\\n  timelineComponentInterface _deviceInterface;\\n  float lastBeatTime = 0;\\n\\n  float curGridPosition;\\n\\n  public bool looping = true;\\n\\n  Dictionary<int, timelineEvent> activeEvents = new Dictionary<int, timelineEvent>();\\n\\n  void Awake() {\\n    _deviceInterface = GetComponent<timelineComponentInterface>();\\n  }\\n\\n  void Start() {\\n    masterControl.instance.beatUpdateEvent += beatUpdateEvent;\\n    masterControl.instance.beatResetEvent += beatResetEvent;\\n  }\\n\\n  void OnDestroy() {\\n    masterControl.instance.beatUpdateEvent -= beatUpdateEvent;\\n    masterControl.instance.beatResetEvent -= beatResetEvent;\\n  }\\n\\n  void beatResetEvent() {\\n    lastBeatTime = 0;\\n    Back();\\n  }\\n\\n  public void setRecord(bool on) {\\n    List<int> keys = new List<int>(activeEvents.Keys);\\n    foreach (int n in keys) {\\n      activeEvents[n].setRecord(false);\\n      activeEvents.Remove(n);\\n    }\\n  }\\n\\n  void updatePlayhead() {\\n    if (_deviceInterface._gridParams.isOnGrid(curGridPosition)) {\\n      playheadHandle.gameObject.SetActive(true);\\n      Vector3 pos = playheadHandle.transform.localPosition;\\n      pos.x = _deviceInterface._gridParams.UnittoX(curGridPosition);\\n      playheadHandle.transform.localPosition = pos;\\n    } else playheadHandle.gameObject.SetActive(false);\\n  }\\n\\n  List<int> loopKeys = new List<int>();\\n  void loopActiveEvents() {\\n    loopKeys = new List<int>(activeEvents.Keys);\\n    foreach (int n in loopKeys) {\\n      activeEvents[n].setOut(_deviceInterface._gridParams.head_tail.y);\\n      activeEvents[n].setRecord(false);\\n      activeEvents.Remove(n);\\n    }\\n  }\\n\\n  public void Back() {\\n    curGridPosition = _deviceInterface._gridParams.head_tail.x;\\n  }\\n\\n  bool playheadScrubbing = false;\\n\\n  Dictionary<int, Vector2> preAllocatedVectors = new Dictionary<int, Vector2>();\\n\\n  void Update() {\\n    playheadScrubbing = playheadHandle.curState == manipObject.manipState.grabbed;\\n\\n    if (!playheadScrubbing) updatePlayhead();\\n    else {\\n      playheadHandle.xBounds.y = _deviceInterface._gridParams.UnittoX(_deviceInterface._gridParams.head_tail.x);\\n      playheadHandle.xBounds.x = _deviceInterface._gridParams.UnittoX(_deviceInterface._gridParams.head_tail.y);\\n      curGridPosition = _deviceInterface._gridParams.XtoUnit(playheadHandle.transform.localPosition.x);\\n      timelineEventUpdate();\\n    }\\n\\n    lock (_recordLock) {\\n\\n      if (toRecord.Keys.Count > 0) {\\n        foreach (KeyValuePair<int, float> entry in toRecord) {\\n          if (!preAllocatedVectors.ContainsKey(entry.Key)) {\\n            preAllocatedVectors[entry.Key] = new Vector2(entry.Value, entry.Value + .01f);\\n          } else {\\n            preAllocatedVectors[entry.Key] = new Vector2(entry.Value, entry.Value + .01f);\\n          }\\n\\n          activeEvents[entry.Key] = _deviceInterface.SpawnTimelineEvent(entry.Key, preAllocatedVectors[entry.Key]);\\n          activeEvents[entry.Key].setRecord(true);\\n          activeEvents[entry.Key].setOut(entry.Value + .01f);\\n          activeEvents[entry.Key].overlapCheck();\\n        }\\n\\n        toRecord.Clear();\\n      }\\n    }\\n  }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}},{\"finish_reason\":\"stop\",\"index\":4,\"logprobs\":null,\"message\":{\"content\":\"```csharp\\nusing System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class timelinePlayer : MonoBehaviour {\\n  public xHandle playheadHandle;\\n  timelineComponentInterface _deviceInterface;\\n  float lastBeatTime = 0;\\n\\n  float curGridPosition;\\n\\n  public bool looping = true;\\n\\n  Dictionary<int, timelineEvent> activeEvents = new Dictionary<int, timelineEvent>();\\n\\n  // Cache the reusable Vector2 allocation outside of Update method\\n  private Dictionary<int, Vector2> allocatedVectors = new Dictionary<int, Vector2>();\\n\\n  void Awake() {\\n    _deviceInterface = GetComponent<timelineComponentInterface>();\\n  }\\n\\n  void Start() {\\n    masterControl.instance.beatUpdateEvent += beatUpdateEvent;\\n    masterControl.instance.beatResetEvent += beatResetEvent;\\n  }\\n\\n  void OnDestroy() {\\n    masterControl.instance.beatUpdateEvent -= beatUpdateEvent;\\n    masterControl.instance.beatResetEvent -= beatResetEvent;\\n  }\\n\\n  void beatResetEvent() {\\n    lastBeatTime = 0;\\n    Back();\\n  }\\n\\n  public void setRecord(bool on) {\\n    List<int> keys = new List<int>(activeEvents.Keys);\\n    foreach (int n in keys) {\\n      activeEvents[n].setRecord(false);\\n      activeEvents.Remove(n);\\n    }\\n  }\\n\\n  void updatePlayhead() {\\n    if (_deviceInterface._gridParams.isOnGrid(curGridPosition)) {\\n      playheadHandle.gameObject.SetActive(true);\\n      Vector3 pos = playheadHandle.transform.localPosition;\\n      pos.x = _deviceInterface._gridParams.UnittoX(curGridPosition);\\n      playheadHandle.transform.localPosition = pos;\\n    } else playheadHandle.gameObject.SetActive(false);\\n  }\\n\\n  List<int> loopKeys = new List<int>();\\n  void loopActiveEvents() {\\n    loopKeys = new List<int>(activeEvents.Keys);\\n    foreach (int n in loopKeys) {\\n      activeEvents[n].setOut(_deviceInterface._gridParams.head_tail.y);\\n      activeEvents[n].setRecord(false);\\n      activeEvents.Remove(n);\\n    }\\n  }\\n\\n  public void Back() {\\n    curGridPosition = _deviceInterface._gridParams.head_tail.x;\\n  }\\n\\n  bool playheadScrubbing = false;\\n\\n  void Update() {\\n    playheadScrubbing = playheadHandle.curState == manipObject.manipState.grabbed;\\n\\n    if (!playheadScrubbing) updatePlayhead();\\n    else {\\n      playheadHandle.xBounds.y = _deviceInterface._gridParams.UnittoX(_deviceInterface._gridParams.head_tail.x);\\n      playheadHandle.xBounds.x = _deviceInterface._gridParams.UnittoX(_deviceInterface._gridParams.head_tail.y);\\n      curGridPosition = _deviceInterface._gridParams.XtoUnit(playheadHandle.transform.localPosition.x);\\n      timelineEventUpdate();\\n    }\\n\\n    lock (_recordLock) {\\n      if (toRecord.Keys.Count > 0) {\\n        foreach (KeyValuePair<int, float> entry in toRecord) {\\n          // Use or update cached Vector2 allocation\\n          Vector2 timeRange;\\n          if (!allocatedVectors.TryGetValue(entry.Key, out timeRange)) {\\n            timeRange = new Vector2(entry.Value, entry.Value + .01f);\\n            allocatedVectors[entry.Key] = timeRange;\\n          } else {\\n            timeRange.x = entry.Value;\\n            timeRange.y = entry.Value + .01f;\\n          }\\n\\n          if (!activeEvents.ContainsKey(entry.Key)) {\\n            activeEvents[entry.Key] = _deviceInterface.SpawnTimelineEvent(entry.Key, timeRange);\\n          }\\n          activeEvents[entry.Key].setRecord(true);\\n          activeEvents[entry.Key].setOut(entry.Value + .01f);\\n          activeEvents[entry.Key].overlapCheck();\\n        }\\n\\n        toRecord.Clear();\\n      }\\n    }\\n  }\\n}\\n```\",\"refusal\":null,\"role\":\"assistant\",\"audio\":null,\"function_call\":null,\"tool_calls\":null,\"annotations\":[]}}],\"created\":1751770117,\"model\":\"gpt-4o-2024-08-06\",\"object\":\"chat.completion\",\"service_tier\":\"default\",\"system_fingerprint\":\"fp_07871e2ad8\",\"usage\":{\"completion_tokens\":3271,\"prompt_tokens\":824,\"total_tokens\":4095,\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":0,\"rejected_prediction_tokens\":0},\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0}}}"