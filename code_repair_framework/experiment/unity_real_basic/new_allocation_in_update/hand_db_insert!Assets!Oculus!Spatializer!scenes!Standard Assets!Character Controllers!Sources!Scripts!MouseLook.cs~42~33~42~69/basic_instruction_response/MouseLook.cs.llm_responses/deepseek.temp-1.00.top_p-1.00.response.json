{
    "code_repairing_0": "It seems your code is missing so I can't see the completion of your problem. Are you trying to fix this bug or you are asking for an advice on how to change the camera direction based on mouse movement? I'll assume the latter.\n\nThe following code changes the camera direction based on mouse movement. I've removed the \"new Vector3()\" part because you've mentioned you had a bug with these and they were \"inefficient\". \n\n```csharp\nvoid Update ()\n{\n    if (axes == RotationAxes.MouseXAndY)\n    {\n        float rotationX = transform.localEulerAngles.y + Input.GetAxis(\"Mouse X\") * sensitivityX;\n\n        rotationY += Input.GetAxis(\"Mouse Y\") * sensitivityY;\n        rotationY = Mathf.Clamp (rotationY, minimumY, maximumY);\n\n        transform.localEulerAngles = new Vector3(-rotationY, rotationX, 0);\n    }\n    else\n    {\n        // If the axes are set to MouseX, the returned localEulerAngles.y value will not be affected.\n        // Otherwise, if the axes are set to MouseY, the returned localEulerAngles.x value will not be affected.\n        // This means you can look left and right but not up and down.\n        transform.Rotate(0, Input.GetAxis(\"Mouse X\") * sensitivityX, 0);\n        // The commented out line would allow you to look up and down\n        //transform.Rotate(-Input.GetAxis(\"Mouse Y\") * sensitivityY, 0, 0);\n    }\n}\n```\nThis will allow your camera to rotate around its vertical axis (looking up and down), and around its horizontal axis (looking left and right). It also ensures that your rotation is clamped within your specified minimum and maximum values.",
    "code_repairing_1": "It seems like you are trying to set the local rotation of your camera using mouse input, but you are experiencing some performance issues due to the allocation of new Vector3 objects in the Update method. \n\nYou can change your code to store the Vector3 in a field and update it when needed, instead of creating a new Vector3 each frame. This can improve your performance. \n\nHere is the fixed code:\n\n```csharp\nusing UnityEngine;\n\n[AddComponentMenu(\"Camera-Control/Mouse Look\")]\npublic class MouseLook : MonoBehaviour \n{\n    public enum RotationAxes { MouseXAndY = 0, MouseX = 1, MouseY = 2 }\n    public RotationAxes axes = RotationAxes.MouseXAndY;\n    public float sensitivityX = 15F;\n    public float sensitivityY = 15F;\n\n    public float minimumX = -360F;\n    public float maximumX = 360F;\n\n    public float minimumY = -60F;\n    public float maximumY = 60F;\n\n    float rotationY = 0F;\n    Vector3 currentRotation;\n\n    void Update ()\n    {\n        if (axes == RotationAxes.MouseXAndY)\n        {\n            float rotationX = transform.localEulerAngles.y + Input.GetAxis(\"Mouse X\") * sensitivityX;\n            rotationX = Mathf.Clamp (rotationX, minimumX, maximumX);\n\n            rotationY += Input.GetAxis(\"Mouse Y\") * sensitivityY;\n            rotationY = Mathf.Clamp (rotationY, minimumY, maximumY);\n\n            currentRotation = new Vector3(-rotationY, rotationX, 0);\n            transform.localEulerAngles = currentRotation;\n        }\n    else\n        {\n            // Code for other Axes goes here\n        }\n    }\n}\n```\n\nThe Vector3 `currentRotation` is now updated once per frame and is then directly set to the local Euler angles of the transform. This avoids the performance issue.",
    "code_repairing_2": "Your current code is setting the rotation of the gameobject it's attached to every frame, which may not be the best way to do this. Instead, you can set the rotation inside of the `LateUpdate` method, which is called after all the updates for the current frame have been processed, to ensure that you are working with the most recent data.\n\nThe updated code would look like this:\n\n```csharp\nvoid LateUpdate ()\n{\n    if (axes == RotationAxes.MouseXAndY)\n    {\n        float rotationX = transform.localEulerAngles.y + Input.GetAxis(\"Mouse X\") * sensitivityX;\n        \n        rotationY += Input.GetAxis(\"Mouse Y\") * sensitivityY;\n        rotationY = Mathf.Clamp (rotationY, minimumY, maximumY);\n        \n        transform.localEulerAngles = new Vector3(-rotationY, rotationX, 0);\n    }\n}\n```\n\nAlso, you should be aware that using `transform.localEulerAngles` directly can sometimes cause issues with the hierarchy of the gameobjects in your scene. If you are encountering such issues, you may want to consider using `transform.localRotation` instead.",
    "code_repairing_3": "transform.localEulerAngles = new Vector3(-rotationY, rotationX, 0);\n\n\t\t}\n\t\telse if (axes == RotationAxes.MouseX)\n\t\t{\n\t\t\ttransform.Rotate(0, Input.GetAxis(\"Mouse X\") * sensitivityX, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trotationY += Input.GetAxis(\"Mouse Y\") * sensitivityY;\n\t\t\trotationY = Mathf.Clamp (rotationY, minimumY, maximumY);\n\t\t\t\n\t\t\ttransform.localEulerAngles = new Vector3(-rotationY, 0, 0);\n\t\t}\n\t}\n}",
    "code_repairing_4": "It appears you're trying to set the rotation of the object. The code should be:\n\n```csharp\ntransform.localEulerAngles = new Vector3(-rotationY, rotationX, 0);\n```\n\nThis code will set the local rotation of the object to a new Vector3. The X component of the Vector3 is the negative of the variable `rotationY`, the Y component is the `rotationX`, and the Z component is 0.\n\nIn the context of your code, it would look something like this:\n\n```csharp\nusing UnityEngine;\nusing System.Collections;\n\n[AddComponentMenu(\"Camera-Control/Mouse Look\")]\npublic class MouseLook : MonoBehaviour {\n\n    public enum RotationAxes { MouseXAndY = 0, MouseX = 1, MouseY = 2 }\n    public RotationAxes axes = RotationAxes.MouseXAndY;\n    public float sensitivityX = 15F;\n    public float sensitivityY = 15F;\n\n    public float minimumX = -360F;\n    public float maximumX = 360F;\n\n    public float minimumY = -60F;\n    public float maximumY = 60F;\n\n    float rotationY = 0F;\n\n    void Update () {\n        if (axes == RotationAxes.MouseXAndY) {\n            float rotationX = transform.localEulerAngles.y + Input.GetAxis(\"Mouse X\") * sensitivityX;\n\n            rotationY += Input.GetAxis(\"Mouse Y\") * sensitivityY;\n            rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);\n\n            transform.localEulerAngles = new Vector3(-rotationY, rotationX, 0);\n        }\n    }\n}\n```\n\nThis code will allow the camera to move with the mouse movement relative to the object it's attached to."
}