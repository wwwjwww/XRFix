{
    "code_repairing_0": "Fixed code:\n\nusing System.Diagnostics.CodeAnalysis;\nusing Random = UnityEngine.Random;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing System.Linq;\nusing System;\n\n[SuppressMessage(\"ReSharper\", \"ReturnTypeCanBeEnumerable.Local\")]\npublic class BrickAttach : MonoBehaviour\n{\n    private Color32 _color;\n    public Color32 Color\n    {\n        get => _color;\n        set => SetColor(value);\n    }\n\n    public Color32 HoverColor\n    {\n        get\n        {\n            int difference = (Convert.ToInt32(_color.r) + Convert.ToInt32(_color.g) + Convert.ToInt32(_color.b)) > 300\n               ? -20\n                : 20;\n            byte r = (byte)(Mathf.Clamp(_color.r + difference, 0, 255));\n            byte g = (byte)(Mathf.Clamp(_color.g + difference, 0, 255));\n            byte b = (byte)(Mathf.Clamp(_color.b + difference, 0, 255));\n            byte a = (byte)(Mathf.Clamp(_color.a, 0, 255));\n\n            return new Color32(r, g, b, a);\n        }\n    }\n\n    private Session session;\n    private bool _hoveredLeft;\n    private bool _hoveredRight;\n    public bool Held { get; private set; }\n\n    public int renderQueue;\n\n    public GameObject maleConnectorParent;\n    public GameObject femaleConnectorParent;\n\n    public GameObject model;\n    public GameObject combinedModel;\n\n    private BrickUuid _brickUuid;\n    private GameObject _modularModel;\n\n    private BulkGrabFollow[] _attachedBulkGrabFollows;\n\n    public string swapPrefab;\n\n    public string normalPrefabName;\n\n    public List<GameObject> maleConnectors;\n    public List<GameObject> femaleConnectors;\n\n    public List<LegoConnectorScript> maleConnectorScripts;\n    public List<LegoConnectorScript> femaleConnectorScripts;\n\n    private readonly Dictionary<string, LegoConnectorScript> maleConnectorScriptsByName = new Dictionary<string, LegoConnectorScript>();\n\n    public Mesh originalMesh;\n    public Material originalMaterial;\n\n    private UserSettings _userSettings;\n    private static readonly int ShaderColorProperty = Shader.PropertyToID(\"_Color\");\n    private static readonly int ShaderTexOffsetProperty = Shader.PropertyToID(\"_TexOffset\");\n    private MaterialPropertyBlock _props;\n\n    public Mesh solidMesh;\n    public Mesh hollowMesh;\n    public Mesh studMesh;\n\n    public PlacedBrickRenderer placedBrickRenderer;\n\n    public MeshFilter meshFilter;\n    public MeshRenderer meshRenderer;\n\n    public bool renderHollowMesh;\n\n    public string headClientId;\n    public bool isPlayerHead;\n\n    private AvatarManager _avatarManager;\n\n    public float texOffset;\n\n    private void Awake()\n    {\n        texOffset = Random.Range(0f, 1f);\n        _props = new MaterialPropertyBlock();\n        _brickUuid = GetComponent<BrickUuid>();\n        _userSettings = UserSettings.GetInstance();\n        placedBrickRenderer = GetComponent<PlacedBrickRenderer>();\n        meshFilter = model.GetComponent<MeshFilter>();\n        meshRenderer = model.GetComponent<MeshRenderer>();\n\n        foreach (Transform child in maleConnectorParent.transform)\n        {\n            maleConnectorScriptsByName.Add(child.gameObject.name, child.gameObject.GetComponent<LegoConnectorScript>());\n        }\n\n        ModularBrickObjects modularBrickObject = ModularBrickObjects.GetInstance();\n        _modularModel = modularBrickObject.GetModularModel(normalPrefabName);\n        solidMesh = modularBrickObject.GetSolidMesh(normalPrefabName);\n        hollowMesh = modularBrickObject.GetHollowMesh(normalPrefabName);\n        studMesh = modularBrickObject.GetStudMesh(normalPrefabName);\n\n        if (Application.isEditor)\n        {\n            originalMaterial = model.GetComponent<MeshRenderer>().sharedMaterial;\n            originalMesh = _userSettings.SuperUltraPerformanceMode? _modularModel.transform.Find(\"FlatBody\").GetComponentInChildren<MeshFilter>().sharedMesh : model.GetComponent<MeshFilter>().sharedMesh;\n        }\n\n        SetSortedMaterial();\n    }\n\n    private void Start()\n    {\n        OwnedPhysicsBricksStore.GetInstance().AddBrick(gameObject);\n        _avatarManager = AvatarManager.GetInstance();\n        session = Session.GetInstance();\n        headClientId = session.ClientID;\n\n        if (!isPlayerHead && headClientId == session.ClientID)\n            ChunkedRenderer.GetInstance().AddBrickToRenderer(gameObject);\n    }\n\n    private void SetSortedMaterial(Mesh mesh = null)\n    {\n        MeshRenderer meshRenderer = model.GetComponent<MeshRenderer>();\n\n        meshRenderer.material = BrickRenderQueueSorter.SortedMaterialFromMesh(mesh? mesh : meshFilter.sharedMesh, meshRenderer.sharedMaterial);\n        renderQueue = meshRenderer.sharedMaterial.renderQueue;\n    }\n\n    public void SetUuid(string uuid)\n    {\n        _brickUuid.uuid = uuid;\n    }\n\n    public string GetUuid()\n    {\n        return _brickUuid.uuid;\n    }\n\n    public void SetColor(Color32 color)\n    {\n        if (!model)\n        {\n            Debug.LogError(\"There should be a model on this object\");\n            return;\n        }\n\n        _color = color;\n\n        UpdateBrickColor();\n    }\n\n    public void SetHovered(bool hovered, bool left)\n    {\n        if ((left && (_hoveredLeft == hovered)) || (!left && (_hoveredRight == hovered)))\n            return;\n\n        if (left)\n            _hoveredLeft = hovered;\n        else\n            _hoveredRight = hovered;\n\n        UpdateBrickColor();\n    }\n\n    public void SetHeld(bool held)\n    {\n        if (Held == held)\n            return;\n\n        Held = held;\n        UpdateBrickColor();\n    }\n\n    private void UpdateBrickColor()\n    {\n        if (_props == null) return;\n\n        _props.SetColor(ShaderColorProperty, (_hoveredLeft || _hoveredRight || Held)? HoverColor : _color);\n        _props.SetFloat(ShaderTexOffsetProperty, texOffset);\n\n        MeshRenderer renderer = model.GetComponent<MeshRenderer>();\n        renderer.SetPropertyBlock(_props);\n    }\n\n    public bool ConnectBricks(Vector3 newPos, Quaternion newRot, Vector3 connectionDirection, Session session = null)\n    {\n        session = session?? Session.GetInstance();\n        transform.position = newPos;\n        transform.rotation = newRot;\n\n        List<GameObject> bricksBelow = OverlappingBricksFromConnectors(femaleConnectors);\n        List<BrickAttach> bricksBelowAttaches = bricksBelow.Select(b => b.GetComponent<BrickAttach>()).ToList();\n\n        List<GameObject> bricksAbove = OverlappingBricksFromConnectors(maleConnectors);\n        List<BrickAttach> bricksAboveAttaches = bricksAbove.Select(b => b.GetComponent<BrickAttach>()).ToList();\n\n        string attachedToHeadClientId = session.ClientID;\n        foreach (BrickAttach attach in bricksBelowAttaches)\n            if (attach.headClientId!= session.ClientID)\n                attachedToHeadClientId = attach.headClientId;\n\n        foreach (BrickAttach attach in bricksAboveAttaches)\n            if (attach.headClientId!= session.ClientID)\n                attachedToHeadClientId = attach.headClientId;\n\n        for (int i = 0; i < bricksBelowAttaches.Count; i++)\n        {\n            ConfigureNeighboringBrick(bricksBelowAttaches[i], bricksBelow[i], true);\n        }\n\n        for (int i = 0; i < bricksAboveAttaches.Count(); i++)\n        {\n            ConfigureNeighboringBrick(bricksAboveAttaches[i], bricksAbove[i], false);\n        }\n\n        BrickSwapper.SwapToFakeBrick(gameObject, attachedToHeadClientId, _avatarManager);\n\n        return true;\n    }\n\n    private void ConfigureNeighboringBrick(BrickAttach attach, GameObject brick, bool below)\n    {\n        if (attach == null) return;\n        if (attach.GetUuid() == GetUuid()) return;\n\n        BrickSwapper.SwapToFakeBrick(brick);\n    }\n\n    private List<GameObject> OverlappingBricksFromConnectors(List<GameObject> connectors)\n    {\n        return connectors.Select(OverlappingBrickFromConnector).Where(x => x!= null).Distinct().ToList();\n    }\n\n    private GameObject OverlappingBrickFromConnector(GameObject connector)\n    {\n        return connector.GetComponent<LegoConnectorScript>().BrickCollidingWith(null);\n    }\n\n    public void RecalculateEnabledConnectors()\n    {\n        foreach (LegoConnectorScript script in maleConnectorScripts)\n        {\n            script.RecalculateEnabled();\n        }\n\n        foreach (LegoConnectorScript script in femaleConnectorScripts)\n        {\n            script.RecalculateEnabled();\n        }\n    }\n\n    public void RecalculateRenderedGeometry()\n    {\n        bool placed =!(placedBrickRenderer!= null);\n        bool performanceMode = _userSettings.SuperUltraPerformanceMode;\n\n        string cacheKey = \"\";\n        cacheKey += normalPrefabName;\n\n        bool allFemalePegsCovered = femaleConnectorScripts.All(s => s.covered);\n\n        bool isOnCarpet = IsOnCarpet();\n\n        if (performanceMode)\n        {\n            cacheKey += \"perfmode\";\n        }\n        else\n        {\n            foreach (LegoConnectorScript s in maleConnectorScripts)\n            {\n                cacheKey += ((placed && s.covered)? \"Y\" : \"N\");",
    "code_repairing_1": "Claro, existen muchas herramientas que puedes usar para tener una mejor organizaci\u00f3n de tus tareas y conocimientos, aqu\u00ed te recomiendo algunas:\n\n- Todoist: Esta es una herramienta de gesti\u00f3n de tareas que te permite organizar tus tareas, prioridades, proyectos y m\u00e1s. Te ofrece diferentes opciones de vistas y filtros para que puedas ver y trabajar con tus tareas de manera m\u00e1s eficiente. Tambi\u00e9n puedes utilizarla para crear listas de comprobaci\u00f3n y asignar tareas a otros miembros del equipo. Todoist es gratuita para usuarios individuales y tambi\u00e9n ofrece planes premium para empresas y organizaciones.\n\n- Evernote: Esta es una herramienta que te permite crear y organizar notas, archivos y materiales de aprendiz",
    "code_repairing_2": "using UnityEngine;\n\npublic class BrickAttach : MonoBehaviour\n{\n\tprivate Color32 _color;\n\tpublic Color32 Color\n\t{\n\t\tget => _color;\n\t\tset => SetColor(value);\n\t}\n\n\tpublic Color32 HoverColor\n\t{\n\t\tget\n\t\t{\n\t\t\tint difference = (Convert.ToInt32(_color.r) + Convert.ToInt32(_color.g) + Convert.ToInt32(_color.b)) > 300\n\t\t\t\t? -20\n\t\t\t\t: 20;\n\t\t\tbyte r = (byte)(Mathf.Clamp(_color.r + difference, 0, 255));\n\t\t\tbyte g = (byte)(Mathf.Clamp(_color.g + difference, 0, 255));\n\t\t\tbyte b = (byte)(Mathf.Clamp(_color.b + difference, 0, 255));\n\t\t\tbyte a = (byte)(Mathf.Clamp(_color.a, 0, 255));\n\n\t\t\treturn new Color32(r, g, b, a);\n\t\t}\n\t}\n\n\tprivate Session _session;\n\tprivate bool _hoveredLeft;\n\tprivate bool _hoveredRight;\n\tpublic bool Held { get; private set; }\n\n\tpublic int renderQueue;\n\n\tpublic GameObject maleConnectorParent;\n\tpublic GameObject femaleConnectorParent;\n\n\tpublic GameObject model;\n\tpublic GameObject combinedModel;\n\n\tprivate BrickUuid _brickUuid;\n\tprivate GameObject _modularModel;\n\n\tprivate BulkGrabFollow[] _attachedBulkGrabFollows;\n\n\tpublic string swapPrefab;\n\n\tpublic string normalPrefabName;\n\n\tpublic List<GameObject> maleConnectors { get; private set; }\n\tpublic List<GameObject> femaleConnectors { get; private set; }\n\n\tpublic List<LegoConnectorScript> maleConnectorScripts { get; private set; }\n\tpublic List<LegoConnectorScript> femaleConnectorScripts { get; private set; }\n\n\tprivate readonly Dictionary<string, LegoConnectorScript> _maleConnectorScriptsByName = new Dictionary<string, LegoConnectorScript>();\n\n\tpublic Mesh originalMesh;\n\tpublic Material originalMaterial;\n\n\tprivate UserSettings _userSettings;\n\tprivate static readonly int ShaderColorProperty = Shader.PropertyToID(\"_Color\");\n\tprivate static readonly int ShaderTexOffsetProperty = Shader.PropertyToID(\"_TexOffset\");\n\tprivate MaterialPropertyBlock _props;\n\n\tpublic Mesh solidMesh;\n\tpublic Mesh hollowMesh;\n\tpublic Mesh studMesh;\n\n\tpublic PlacedBrickRenderer placedBrickRenderer;\n\n\tpublic MeshFilter meshFilter;\n\tpublic MeshRenderer meshRenderer;\n\n\tpublic bool renderHollowMesh;\n\n\tpublic string headClientId;\n\tpublic bool isPlayerHead;\n\n\tprivate AvatarManager _avatarManager;\n\n\tpublic float texOffset;\n\n\tprivate void Awake()\n\t{\n\t\ttexOffset = Random.Range(0f, 1f);\n\t\t_props = new MaterialPropertyBlock();\n\t\t_brickUuid = GetComponent<BrickUuid>();\n\t\t_userSettings = UserSettings.GetInstance();\n\t\tplacedBrickRenderer = GetComponent<PlacedBrickRenderer>();\n\t\tmeshFilter = model.GetComponent<MeshFilter>();\n\t\tmeshRenderer = model.GetComponent<MeshRenderer>();\n\n\t\tforeach (Transform child in maleConnectorParent.transform)\n\t\t{\n\t\t\t_maleConnectorScriptsByName.Add(child.gameObject.name, child.gameObject.GetComponent<LegoConnectorScript>());\n\t\t}\n\n\t\tModularBrickObjects modularBrickObject = ModularBrickObjects.GetInstance();\n\t\t_modularModel = modularBrickObject.GetModularModel(normalPrefabName);\n\t\tsolidMesh = modularBrickObject.GetSolidMesh(normalPrefabName);\n\t\thollowMesh = modularBrickObject.GetHollowMesh(normalPrefabName);\n\t\tstudMesh = modularBrickObject.GetStudMesh(normalPrefabName);\n\n\t\tif (Application.isEditor)\n\t\t{\n\t\t\toriginalMaterial = model.GetComponent<MeshRenderer>().sharedMaterial;\n\t\t\toriginalMesh = _userSettings.SuperUltraPerformanceMode? _modularModel.transform.Find(\"FlatBody\").GetComponentInChildren<MeshFilter>().sharedMesh : model.GetComponent<MeshFilter>().sharedMesh;\n\t\t}\n\n\t\tSetSortedMaterial();\n\t}\n\n\tprivate void Start()\n\t{\n\t\tOwnedPhysicsBricksStore.GetInstance().AddBrick(gameObject);\n\t\t_avatarManager = AvatarManager.GetInstance();\n\t\t_session = Session.GetInstance();\n\t\theadClientId = _session.ClientID;\n\n\t\tif (!isPlayerHead && headClientId == _session.ClientID)\n\t\t\tChunkedRenderer.GetInstance().AddBrickToRenderer(gameObject);\n\t}\n\n\tprivate void SetSortedMaterial(Mesh mesh = null)\n\t{\n\t\tMeshRenderer meshRenderer = model.GetComponent<MeshRenderer>();\n\n\t\tmeshRenderer.material = BrickRenderQueueSorter.SortedMaterialFromMesh(mesh? mesh : meshFilter.sharedMesh, meshRenderer.sharedMaterial);\n\t\trenderQueue = meshRenderer.sharedMaterial.renderQueue;\n\t}\n\n\tpublic void SetUuid(string uuid)\n\t{\n\t\t_brickUuid.uuid = uuid;\n\t}\n\n\tpublic string GetUuid()\n\t{\n\t\treturn _brickUuid.uuid;\n\t}\n\n\tpublic void SetColor(Color32 color)\n\t{\n\t\tif (!model)\n\t\t{\n\t\t\tDebug.LogError(\"There should be a model on this object\");\n\t\t\treturn;\n\t\t}\n\n\t\t_color = color;\n\n\t\tUpdateBrickColor();\n\t}\n\n\tpublic void SetHovered(bool hovered, bool left)\n\t{\n\t\tif ((left && (_hoveredLeft == hovered)) || (!left && (_hoveredRight == hovered)))\n\t\t\treturn;\n\n\t\tif (left)\n\t\t\t_hoveredLeft = hovered;\n\t\telse\n\t\t\t_hoveredRight = hovered;\n\n\t\tUpdateBrickColor();\n\t}\n\n\tpublic void SetHeld(bool held)\n\t{\n\t\tif (Held == held)\n\t\t\treturn;\n\n\t\tHeld = held;\n\t\tUpdateBrickColor();\n\t}\n\n\tprivate void UpdateBrickColor()\n\t{\n\t\tif (_props == null) return;\n\n\t\t_props.SetColor(ShaderColorProperty, (_hoveredLeft || _hoveredRight || Held)? HoverColor : _color);\n\t\t_props.SetFloat(ShaderTexOffsetProperty, texOffset);\n\n\t\tMeshRenderer renderer = model.GetComponent<MeshRenderer>();\n\t\trenderer.SetPropertyBlock(_props);\n\t}\n\n\tpublic bool ConnectBricks(Vector3 newPos, Quaternion newRot, Vector3 connectionDirection, Session session = null)\n\t{\n\t\tsession = session?? Session.GetInstance();\n\t\ttransform.position = newPos;\n\t\ttransform.rotation = newRot;\n\n\t\tList<GameObject> bricksBelow = OverlappingBricksFromConnectors(femaleConnectors);\n\t\tList<BrickAttach> bricksBelowAttaches = bricksBelow.Select(b => b.GetComponent<BrickAttach>()).ToList();\n\n\t\tList<GameObject> bricksAbove = OverlappingBricksFromConnectors(maleConnectors);\n\t\tList<BrickAttach> bricksAboveAttaches = bricksAbove.Select(b => b.GetComponent<BrickAttach>()).ToList();\n\n\t\tstring attachedToHeadClientId = session.ClientID;\n\t\tforeach (BrickAttach attach in bricksBelowAttaches)\n\t\t\tif (attach.headClientId!= session.ClientID)\n\t\t\t\tattachedToHeadClientId = attach.headClientId;\n\n\t\tforeach (BrickAttach attach in bricksAboveAttaches)\n\t\t\tif (attach.headClientId!= session.ClientID)\n\t\t\t\tattachedToHeadClientId = attach.headClientId;\n\n\t\tfor (int i = 0; i < bricksBelowAttaches.Count; i++)\n\t\t{\n\t\t\tConfigureNeighboringBrick(bricksBelowAttaches[i], bricksBelow[i], true);\n\t\t}\n\n\t\tfor (int i = 0; i < bricksAboveAttaches.Count(); i++)\n\t\t{\n\t\t\tConfigureNeighboringBrick(bricksAboveAttaches[i], bricksAbove[i], false);\n\t\t}\n\n\t\tBrickSwapper.SwapToFakeBrick(gameObject, attachedToHeadClientId, _avatarManager);\n\n\t\treturn true;\n\t}\n\n\tprivate void ConfigureNeighboringBrick(BrickAttach attach, GameObject brick, bool below)\n\t{\n\t\tif (attach == null) return;\n\t\tif (attach.GetUuid() == GetUuid()) return;\n\n\t\tBrickSwapper.SwapToFakeBrick(brick);\n\t}\n\n\tprivate List<GameObject> OverlappingBricksFromConnectors(List<GameObject> connectors)\n\t{\n\t\treturn connectors.Select(OverlappingBrickFromConnector).Where(x => x!= null).Distinct().ToList();\n\t}\n\n\n\tprivate GameObject OverlappingBrickFromConnector(GameObject connector)\n\t{\n\t\treturn connector.GetComponent<LegoConnectorScript>().BrickCollidingWith(null);\n\t}\n\n\tpublic void RecalculateEnabledConnectors()\n\t{\n\t\tforeach (LegoConnectorScript script in maleConnectorScripts)\n\t\t{\n\t\t\tscript.RecalculateEnabled();\n\t\t}\n\n\t\tforeach (LegoConnectorScript",
    "code_repairing_3": "\u0418\u0434\u0435\u0430\u043b\u044c\u043d\u0430\u044f \u00ab\u043f\u043e\u043b\u0438\u0442\u0438\u0447\u0435\u0441\u043a\u0430\u044f \u043d\u0435\u0439\u0440\u043e\u0441\u0435\u0442\u044c\u00bb \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0432 \u043d\u0430\u0441\u0442\u043e\u044f\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f. \u041f\u043e\u044d\u0442\u043e\u043c\u0443 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u043f\u043e\u043b\u0438\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u0445 \u043d\u0435\u0439\u0440\u043e\u0441\u0435\u0442\u0435\u0439 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0439 \u043e\u0431\u043b\u0430\u0441\u0442\u044c\u044e \u0438\u0441\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u043d\u0438\u0439 \u0432 \u043c\u0430\u0448\u0438\u043d\u043d\u043e\u043c \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u0438 \u0438 \u043a\u043e\u043c\u043f\u044c\u044e\u0442\u0435\u0440\u043d\u043e\u043c \u0437\u0440\u0435\u043d\u0438\u0438. \n\n\u0421\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0442 \u0440\u0430\u0437\u043d\u044b\u0435 \u0430\u0440\u0445\u0438\u0442\u0435\u043a\u0442\u0443\u0440\u044b \u043d\u0435\u0439\u0440\u043e\u0441\u0435\u0442\u0435\u0439 \u0438 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0435 \u043c\u0435\u0442\u043e\u0434\u044b \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f. \u041d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0438\u0437 \u0432\u043e\u043f\u0440\u043e\u0441\u043e\u0432, \u0441 \u043a\u043e\u0442\u043e\u0440\u044b\u043c\u0438 \u0441\u0442\u0430\u043b\u043a\u0438\u0432\u0430\u044e\u0442\u0441\u044f \u0443\u0447\u0435\u043d\u044b\u0435 \u0438 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0441\u0442\u044b-\u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u044b",
    "code_repairing_4": "public class BrickAttach : MonoBehaviour\n{\n    private Color32 _color;\n    public Color32 Color\n    {\n        get => _color;\n        set => SetColor(value);\n    }\n\n    public Color32 HoverColor\n    {\n        get\n        {\n            int difference = (Convert.ToInt32(_color.r) + Convert.ToInt32(_color.g) + Convert.ToInt32(_color.b)) > 300\n               ? -20\n                : 20;\n            byte r = (byte)(Mathf.Clamp(_color.r + difference, 0, 255));\n            byte g = (byte)(Mathf.Clamp(_color.g + difference, 0, 255));\n            byte b = (byte)(Mathf.Clamp(_color.b + difference, 0, 255));\n            byte a = (byte)(Mathf.Clamp(_color.a, 0, 255));\n\n            return new Color32(r, g, b, a);\n        }\n    }\n\n    private Session session;\n    private bool _hoveredLeft;\n    private bool _hoveredRight;\n    public bool Held { get; private set; }\n\n    public int renderQueue;\n\n    public GameObject maleConnectorParent;\n    public GameObject femaleConnectorParent;\n\n    public GameObject model;\n    public GameObject combinedModel;\n\n    private BrickUuid _brickUuid;\n    private GameObject _modularModel;\n\n    private BulkGrabFollow[] _attachedBulkGrabFollows;\n\n    public string swapPrefab;\n\n    public string normalPrefabName;\n\n    public List<GameObject> maleConnectors = new List<GameObject>();\n    public List<GameObject> femaleConnectors = new List<GameObject>();\n\n    public List<LegoConnectorScript> maleConnectorScripts = new List<LegoConnectorScript>();\n    public List<LegoConnectorScript> femaleConnectorScripts = new List<LegoConnectorScript>();\n\n    private readonly Dictionary<string, LegoConnectorScript> maleConnectorScriptsByName =\n        new Dictionary<string, LegoConnectorScript>();\n\n    public Mesh originalMesh;\n    public Material originalMaterial;\n\n    private UserSettings _userSettings;\n    private static readonly int ShaderColorProperty = Shader.PropertyToID(\"_Color\");\n    private static readonly int ShaderTexOffsetProperty = Shader.PropertyToID(\"_TexOffset\");\n    private MaterialPropertyBlock _props;\n\n    public Mesh solidMesh;\n    public Mesh hollowMesh;\n    public Mesh studMesh;\n\n    public PlacedBrickRenderer placedBrickRenderer;\n\n    public MeshFilter meshFilter;\n    public MeshRenderer meshRenderer;\n\n    public bool renderHollowMesh;\n\n    public string headClientId;\n    public bool isPlayerHead;\n\n    private AvatarManager _avatarManager;\n\n    public float texOffset;\n\n    private void Awake()\n    {\n        texOffset = Random.Range(0f, 1f);\n        _props = new MaterialPropertyBlock();\n        _brickUuid = GetComponent<BrickUuid>();\n        _userSettings = UserSettings.GetInstance();\n        placedBrickRenderer = GetComponent<PlacedBrickRenderer>();\n        meshFilter = model.GetComponent<MeshFilter>();\n        meshRenderer = model.GetComponent<MeshRenderer>();\n\n        foreach (Transform child in maleConnectorParent.transform)\n        {\n            maleConnectorScriptsByName.Add(child.gameObject.name, child.gameObject.GetComponent<LegoConnectorScript>());\n        }\n\n        ModularBrickObjects modularBrickObject = ModularBrickObjects.GetInstance();\n        _modularModel = modularBrickObject.GetModularModel(normalPrefabName);\n        solidMesh = modularBrickObject.GetSolidMesh(normalPrefabName);\n        hollowMesh = modularBrickObject.GetHollowMesh(normalPrefabName);\n        studMesh = modularBrickObject.GetStudMesh(normalPrefabName);\n\n        if (Application.isEditor)\n        {\n            originalMaterial = model.GetComponent<MeshRenderer>().sharedMaterial;\n            originalMesh = _userSettings.SuperUltraPerformanceMode? _modularModel.transform.Find(\"FlatBody\").GetComponentInChildren<MeshFilter>().sharedMesh : model.GetComponent<MeshFilter>().sharedMesh;\n        }\n\n        SetSortedMaterial();\n    }\n\n    private void Start()\n    {\n        OwnedPhysicsBricksStore.GetInstance().AddBrick(gameObject);\n        _avatarManager = AvatarManager.GetInstance();\n        session = Session.GetInstance();\n        headClientId = session.ClientID;\n\n        if (!isPlayerHead && headClientId == session.ClientID)\n            ChunkedRenderer.GetInstance().AddBrickToRenderer(gameObject);\n    }\n\n    private void SetSortedMaterial(Mesh mesh = null)\n    {\n        MeshRenderer meshRenderer = model.GetComponent<MeshRenderer>();\n\n        meshRenderer.material = BrickRenderQueueSorter.SortedMaterialFromMesh(mesh? mesh : meshFilter.sharedMesh, meshRenderer.sharedMaterial);\n        renderQueue = meshRenderer.sharedMaterial.renderQueue;\n    }\n\n    public void SetUuid(string uuid)\n    {\n        _brickUuid.uuid = uuid;\n    }\n\n    public string GetUuid()\n    {\n        return _brickUuid.uuid;\n    }\n\n    public void SetColor(Color32 color)\n    {\n        if (!model)\n        {\n            Debug.LogError(\"There should be a model on this object\");\n            return;\n        }\n\n        _color = color;\n\n        UpdateBrickColor();\n    }\n\n    public void SetHovered(bool hovered, bool left)\n    {\n        if ((left && (_hoveredLeft == hovered)) || (!left && (_hoveredRight == hovered)))\n            return;\n\n        if (left)\n            _hoveredLeft = hovered;\n        else\n            _hoveredRight = hovered;\n\n        UpdateBrickColor();\n    }\n\n    public void SetHeld(bool held)\n    {\n        if (Held == held)\n            return;\n\n        Held = held;\n        UpdateBrickColor();\n    }\n\n    private void UpdateBrickColor()\n    {\n        if (_props == null) return;\n\n        _props.SetColor(ShaderColorProperty, (_hoveredLeft || _hoveredRight || Held)? HoverColor : _color);\n        _props.SetFloat(ShaderTexOffsetProperty, texOffset);\n\n        MeshRenderer renderer = model.GetComponent<MeshRenderer>();\n        renderer.SetPropertyBlock(_props);\n    }\n\n    public bool ConnectBricks(Vector3 newPos, Quaternion newRot, Vector3 connectionDirection, Session session = null)\n    {\n        session = session?? Session.GetInstance();\n        transform.position = newPos;\n        transform.rotation = newRot;\n\n        List<GameObject> bricksBelow = OverlappingBricksFromConnectors(femaleConnectors);\n        List<BrickAttach> bricksBelowAttaches = bricksBelow.Select(b => b.GetComponent<BrickAttach>()).ToList();\n\n        List<GameObject> bricksAbove = OverlappingBricksFromConnectors(maleConnectors);\n        List<BrickAttach> bricksAboveAttaches = bricksAbove.Select(b => b.GetComponent<BrickAttach>()).ToList();\n\n        string attachedToHeadClientId = session.ClientID;\n        foreach (BrickAttach attach in bricksBelowAttaches)\n            if (attach.headClientId!= session.ClientID)\n                attachedToHeadClientId = attach.headClientId;\n\n        foreach (BrickAttach attach in bricksAboveAttaches)\n            if (attach.headClientId!= session.ClientID)\n                attachedToHeadClientId = attach.headClientId;\n\n        for (int i = 0; i < bricksBelowAttaches.Count; i++)\n        {\n            ConfigureNeighboringBrick(bricksBelowAttaches[i], bricksBelow[i], true);\n        }\n\n        for (int i = 0; i < bricksAboveAttaches.Count(); i++)\n        {\n            ConfigureNeighboringBrick(bricksAboveAttaches[i], bricksAbove[i], false);\n        }\n\n        BrickSwapper.SwapToFakeBrick(gameObject, attachedToHeadClientId, _avatarManager);\n\n        return true;\n    }\n\n    private void ConfigureNeighboringBrick(BrickAttach attach, GameObject brick, bool below)\n    {\n        if (attach == null) return;\n        if (attach.GetUuid() == GetUuid()) return;\n\n        BrickSwapper.SwapToFakeBrick(brick);\n    }\n\n    private List<GameObject> OverlappingBricksFromConnectors(List<GameObject> connectors)\n    {\n        return connectors.Select(OverlappingBrickFromConnector).Where(x => x!= null).Distinct().ToList();\n    }\n\n    private GameObject OverlappingBrickFromConnector(GameObject connector)\n    {\n        return connector.GetComponent<LegoConnectorScript>().BrickCollidingWith(null);\n    }\n\n    public void RecalculateEnabledConnectors()\n    {\n        foreach (LegoConnectorScript script in maleConnectorScripts)\n        {\n            script.RecalculateEnabled();\n        }\n\n        foreach (LegoConnectorScript script in femaleConnectorScripts)\n        {\n            script.RecalculateEnabled();\n        }\n    }\n\n    public void RecalculateRenderedGeometry()\n    {\n        bool placed =!(placedBrickRenderer!= null);\n        bool performanceMode = _userSettings.SuperUltraPerformanceMode;\n\n        string cacheKey = \"\";\n        cacheKey += normalPrefabName;\n\n        bool allFemalePegsCovered = femaleConnectorScripts.All(s => s.covered);\n\n        bool isOnCarpet = IsOnCarpet();\n\n        if (performanceMode)\n        {\n            cacheKey += \"perfmode\";\n        }\n        else\n        {\n            foreach (LegoConnectorScript s in maleConnectorScripts)\n            {\n                cacheKey += ((placed && s.covered)? \"Y\" : \"N\");\n            }\n\n            if ((allFemalePegsCovered || isOnCarpet) && placed) cacheKey += \"-bottomcovered\";\n        }\n\n        MeshFilter"
}