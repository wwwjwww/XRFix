{
    "code_repairing_0": "Here is the fixed code. Wrap your reply using three backticks (```) on a new line at the start of your response and at the end of your response.\n\n```csharp\nusing Microsoft.MixedReality.Toolkit.Utilities;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.SceneManagement;\n\nnamespace Microsoft.MixedReality.Toolkit.SceneSystem\n{\n    public partial class MixedRealitySceneSystem : BaseCoreSystem, IMixedRealitySceneSystem\n    {\n        const float SceneActivationLoadProgress = 0.9f;\n\n        private enum SceneType\n        {\n            Manager,\n            Content,\n            Lighting\n        }\n\n        private MixedRealitySceneSystemProfile profile;\n\n        private bool managerSceneOpInProgress;\n        private float managerSceneOpProgress;\n\n        private SceneContentTracker contentTracker;\n\n        private SceneLightingExecutor lightingExecutor;\n\n        public override string Name => \"Mixed Reality Scene System\";\n\n        #region Actions\n\n        public Action<IEnumerable<string>> OnWillLoadContent { get; set; }\n\n        public Action<IEnumerable<string>> OnContentLoaded { get; set; }\n\n        public Action<IEnumerable<string>> OnWillUnloadContent { get; set; }\n\n        public Action<IEnumerable<string>> OnContentUnloaded { get; set; }\n\n        public Action<string> OnWillLoadLighting { get; set; }\n\n        public Action<string> OnLightingLoaded { get; set; }\n\n        public Action<string> OnWillUnloadLighting { get; set; }\n\n        public Action<string> OnLightingUnloaded { get; set; }\n\n        public Action<string> OnWillLoadScene { get; set; }\n\n        public Action<string> OnSceneLoaded { get; set; }\n\n        public Action<string> OnWillUnloadScene { get; set; }\n\n        public Action<string> OnSceneUnloaded { get; set; }\n\n        #endregion\n\n        #region Properties\n\n        public bool SceneOperationInProgress { get; private set; } = false;\n\n        public float SceneOperationProgress { get; private set; } = 0;\n\n        public bool LightingOperationInProgress { get; private set; } = false;\n\n        public float LightingOperationProgress { get; private set; } = 0;\n\n        public string ActiveLightingScene { get; private set; } = string.Empty;\n\n        public bool WaitingToProceed { get; private set; } = false;\n\n        public bool PrevContentExists => contentTracker.PrevContentExists;\n\n        public bool NextContentExists => contentTracker.NextContentExists;\n\n        public string[] ContentSceneNames => contentTracker.ContentSceneNames;\n\n        public uint SourceId => 0;\n\n        public string SourceName => \"Mixed Reality Scene System\";\n\n        #endregion\n\n        #region Service Methods\n\n        public override void Initialize()\n        {\n            contentTracker = new SceneContentTracker(profile);\n            lightingExecutor = new SceneLightingExecutor();\n\n#if UNITY_EDITOR\n            EditorOnInitialize();\n#endif\n\n            if (!Application.isPlaying)\n            {\n                return;\n            }\n\n            if (profile.UseManagerScene)\n            {\n                SetManagerScene(profile.ManagerScene.Name);\n            }\n\n            if (profile.UseLightingScene)\n            {\n                SetLightingScene(profile.DefaultLightingScene.Name, LightingSceneTransitionType.None);\n            }\n        }\n\n        public override void Enable()\n        {\n#if UNITY_EDITOR\n            EditorOnDisable();\n#endif\n        }\n\n        public override void Disable()\n        {\n#if UNITY_EDITOR\n            EditorOnDisable();\n#endif\n        }\n\n        public override void Destroy()\n        {\n#if UNITY_EDITOR\n            EditorOnDestroy();\n#endif\n        }\n\n        public override void Update()\n        {\n            if (profile.UseLightingScene)\n            {\n                lightingExecutor.UpdateTransition(Time.unscaledDeltaTime);\n            }\n        }\n\n        #endregion\n\n        #region Scene Operations\n\n        public async Task LoadNextContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            string nextContent;\n            if (contentTracker.GetNextContent(wrap, out nextContent))\n            {\n                await LoadContent(new string[] { nextContent }, mode, activationToken);\n            }\n            else\n            {\n                Debug.LogWarning(\"Attempted to load next content when no next content exists. Taking no action.\");\n            }\n        }\n\n        public async Task LoadPrevContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            string prevContent;\n            if (contentTracker.GetPrevContent(wrap, out prevContent))\n            {\n                await LoadContent(new string[] { prevContent }, mode, activationToken);\n            }\n            else\n            {\n                Debug.LogWarning(\"Attempted to load prev content when no next content exists. Taking no action.\");\n            }\n        }\n\n        public async Task LoadContent(string sceneToLoad, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            await LoadContent(new string[] { sceneToLoad }, mode, activationToken);\n        }\n\n        public async Task UnloadContent(string sceneToUnload)\n        {\n            await UnloadContent(new string[] { sceneToUnload });\n        }\n\n        public async Task LoadContentByTag(string tag, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            await LoadContent(profile.GetContentSceneNamesByTag(tag), mode, activationToken);\n        }\n\n        public async Task UnloadContentByTag(string tag)\n        {\n            await UnloadScenesInternal(profile.GetContentSceneNamesByTag(tag), SceneType.Content);\n        }\n\n        public async Task LoadContent(IEnumerable<string> scenesToLoad, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            if (!CanSceneOpProceed(SceneType.Content))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            IEnumerable<string> loadedContentScenes;\n            if (mode == LoadSceneMode.Single && GetLoadedContentScenes(out loadedContentScenes))\n            {\n                await UnloadScenesInternal(loadedContentScenes, SceneType.Content, 0, 0.5f, true);\n                await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken, 0.5f, 1f, false);\n            }\n            else\n            {\n                await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken);\n            }\n\n            await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken);\n        }\n\n        public async Task UnloadContent(IEnumerable<string> scenesToUnload)\n        {\n            if (!CanSceneOpProceed(SceneType.Content))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            await UnloadScenesInternal(scenesToUnload, SceneType.Content);\n        }\n\n        public bool IsContentLoaded(string sceneName)\n        {\n            Scene scene = SceneManager.GetSceneByName(sceneName);\n            return scene.IsValid() && scene.isLoaded;\n        }\n\n        public async void SetLightingScene(string newLightingSceneName, LightingSceneTransitionType transitionType = LightingSceneTransitionType.None, float transitionDuration = 1f)\n        {\n            if (ActiveLightingScene == newLightingSceneName)\n            {\n                return;\n            }\n\n            if (!CanSceneOpProceed(SceneType.Lighting))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            SceneInfo lightingScene;\n            RuntimeLightingSettings lightingSettings = default(RuntimeLightingSettings);\n            RuntimeRenderSettings renderSettings = default(RuntimeRenderSettings);\n            RuntimeSunlightSettings sunSettings = default(RuntimeSunlightSettings);\n            if (!string.IsNullOrEmpty(newLightingSceneName) &&!profile.GetLightingSceneSettings(\n                newLightingSceneName,\n                out lightingScene,\n                out lightingSettings,\n                out renderSettings,\n                out sunSettings))\n            {\n                Debug.LogWarning(\"Couldn't find lighting scene \" + newLightingSceneName + \" in profile - taking no action.\");\n                return;\n            }\n\n            ActiveLightingScene = newLightingSceneName;\n\n            if (!Application.isPlaying)\n            {\n                return;\n            }\n\n            lightingExecutor.StartTransition(lightingSettings, renderSettings, sunSettings, transitionType, transitionDuration);\n\n            List<string> lightingSceneNames = new List<string>();\n\n            foreach (SceneInfo lso in profile.LightingScenes)\n            {\n                if (lso.Name!= newLightingSceneName)\n                {\n                    lightingSceneNames.Add(lso.Name);\n                }\n            }\n\n            await LoadScenesInternal(new string[] { newLightingSceneName }, SceneType.Lighting, null, 0f, 0.5f, true);\n\n            await UnloadScenesInternal(lightingSceneNames, SceneType.Lighting, 0.5f, 1f, false);\n        }\n\n        private async void SetManagerScene(string managerSceneName)\n        {\n            Scene scene = SceneManager.GetSceneByName(managerSceneName);\n            if (scene.IsValid() &&!scene.isLoaded)\n            {\n                return;\n            }\n\n            await LoadScenesInternal",
    "code_repairing_1": "React, Angular y Vue son tecnolog\u00edas de desarrollo de interfaces de usuario que se utilizan para crear aplicaciones web. La principal diferencia entre ellas es su enfoque en el desarrollo. React se centra en la creaci\u00f3n de componentes reutilizables, Angular se centra en la creaci\u00f3n de aplicaciones complejas y Vue se enfoca en la simplicidad y la facilidad de uso.\n\nReact se caracteriza por ser una biblioteca de JavaScript de c\u00f3digo ab",
    "code_repairing_2": "Here is a modified version of the code that I have corrected some issues with:\n\n```C#\nusing Microsoft.MixedReality.Toolkit.Utilities;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.SceneManagement;\n\nnamespace Microsoft.MixedReality.Toolkit.SceneSystem\n{\n    \n    \n    \n    \n    \n    [HelpURL(\"https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/SceneSystem/SceneSystemOverview.html\")]\n    public partial class MixedRealitySceneSystem : BaseCoreSystem, IMixedRealitySceneSystem\n    {\n        \n        \n        \n        \n        const float SceneActivationLoadProgress = 0.9f;\n\n        \n        \n        \n        private enum SceneType\n        {\n            Manager = 0,\n            Content = 1,\n            Lighting = 2,\n        }\n\n        public MixedRealitySceneSystem(\n            IMixedRealityServiceRegistrar registrar,\n            MixedRealitySceneSystemProfile profile) : base(registrar, profile)\n        {\n            this.profile = profile;\n        }\n\n        private MixedRealitySceneSystemProfile profile;\n\n        \n        private bool managerSceneOpInProgress;\n        private float managerSceneOpProgress;\n\n        \n        private SceneContentTracker contentTracker;\n        \n        private SceneLightingExecutor lightingExecutor;\n\n        \n        public override string Name { get; protected set; } = \"Mixed Reality Scene System\";\n\n        #region Actions\n\n        \n        public Action<IEnumerable<string>> OnWillLoadContent { get; set; }\n\n        \n        public Action<IEnumerable<string>> OnContentLoaded { get; set; }\n\n        \n        public Action<IEnumerable<string>> OnWillUnloadContent { get; set; }\n\n        \n        public Action<IEnumerable<string>> OnContentUnloaded { get; set; }\n\n        \n        public Action<string> OnWillLoadLighting { get; set; }\n\n        \n        public Action<string> OnLightingLoaded { get; set; }\n\n        \n        public Action<string> OnWillUnloadLighting { get; set; }\n\n        \n        public Action<string> OnLightingUnloaded { get; set; }\n\n        \n        public Action<string> OnWillLoadScene { get; set; }\n\n        \n        public Action<string> OnSceneLoaded { get; set; }\n\n        \n        public Action<string> OnWillUnloadScene { get; set; }\n\n        \n        public Action<string> OnSceneUnloaded { get; set; }\n\n        #endregion\n\n        #region Properties\n\n        \n        public bool SceneOperationInProgress { get; private set; } = false;\n\n        \n        public float SceneOperationProgress { get; private set; } = 0;\n\n        \n        public bool LightingOperationInProgress { get; private set; } = false;\n\n        \n        public float LightingOperationProgress { get; private set; } = 0;\n\n        \n        public string ActiveLightingScene { get; private set; } = string.Empty;\n\n        \n        public bool WaitingToProceed { get; private set; } = false;\n\n        \n        public bool PrevContentExists => contentTracker.PrevContentExists;\n\n        \n        public bool NextContentExists => contentTracker.NextContentExists;\n\n        \n        public string[] ContentSceneNames => contentTracker.ContentSceneNames;\n\n        \n        public uint SourceId { get; } = 0;\n\n        \n        public string SourceName { get; } = \"Mixed Reality Scene System\";\n\n        #endregion\n\n        #region Service Methods\n\n        \n        public override void Initialize()\n        {\n            \n            contentTracker = new SceneContentTracker(profile);\n            lightingExecutor = new SceneLightingExecutor();\n\n#if UNITY_EDITOR\n            EditorOnInitialize();\n#endif\n\n            if (!Application.isPlaying)\n            {\n                return;\n            }\n\n            if (profile.UseManagerScene)\n            {\n                SetManagerScene(profile.ManagerScene.Name);\n            }\n\n            if (profile.UseLightingScene)\n            {   \n                SetLightingScene(profile.DefaultLightingScene.Name, LightingSceneTransitionType.None);\n            }\n        }\n\n        \n        public override void Enable()\n        {\n#if UNITY_EDITOR\n            EditorOnDisable();\n#endif\n        }\n\n        \n        public override void Disable()\n        {\n#if UNITY_EDITOR\n            EditorOnDisable();\n#endif\n        }\n\n        \n        public override void Destroy()\n        {\n#if UNITY_EDITOR\n            EditorOnDestroy();\n#endif\n        }\n\n        \n        public override void Update()\n        {\n            \n            if (profile.UseLightingScene)\n            {\n                lightingExecutor.UpdateTransition(Time.unscaledDeltaTime);\n            }\n        }\n\n        #endregion\n\n        #region Scene Operations\n\n        \n        public async Task LoadNextContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            string nextContent;\n            if (contentTracker.GetNextContent(wrap, out nextContent))\n            {\n                await LoadContent(new string[] { nextContent }, mode, activationToken);\n            }\n            else\n            {\n                Debug.LogWarning(\"Attempted to load next content when no next content exists. Taking no action.\");\n            }\n        }\n\n        \n        public async Task LoadPrevContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            string prevContent;\n            if (contentTracker.GetPrevContent(wrap, out prevContent))\n            {\n                await LoadContent(new string[] { prevContent }, mode, activationToken);\n            }\n            else\n            {\n                Debug.LogWarning(\"Attempted to load prev content when no next content exists. Taking no action.\");\n            }\n        }\n\n        \n        public async Task LoadContent(string sceneToLoad, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            await LoadContent(new string[] { sceneToLoad }, mode, activationToken);\n        }\n\n        \n        public async Task UnloadContent(string sceneToUnload)\n        {\n            await UnloadContent(new string[] { sceneToUnload });\n        }\n\n        \n        public async Task LoadContentByTag(string tag, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            await LoadContent(profile.GetContentSceneNamesByTag(tag), mode, activationToken);\n        }\n\n        \n        public async Task UnloadContentByTag(string tag)\n        {\n            await UnloadScenesInternal(profile.GetContentSceneNamesByTag(tag), SceneType.Content);\n        }\n\n        \n        public async Task LoadContent(IEnumerable<string> scenesToLoad, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            if (!CanSceneOpProceed(SceneType.Content))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            IEnumerable<string> loadedContentScenes;\n            if (mode == LoadSceneMode.Single && GetLoadedContentScenes(out loadedContentScenes))\n            {\n                await UnloadScenesInternal(loadedContentScenes, SceneType.Content, 0, 0.5f, true);\n                await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken, 0.5f, 1f, false);\n            }\n            else\n            {\n                await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken);\n            }\n\n            await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken);\n        }\n\n        \n        public async Task UnloadContent(IEnumerable<string> scenesToUnload)\n        {\n            if (!CanSceneOpProceed(SceneType.Content))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            await UnloadScenesInternal(scenesToUnload, SceneType.Content);\n        }\n\n        \n        public bool IsContentLoaded(string sceneName)\n        {\n            Scene scene = SceneManager.GetSceneByName(sceneName);\n            return scene.IsValid() && scene.isLoaded;\n        }\n\n        \n        public async void SetLightingScene(string newLightingSceneName, LightingSceneTransitionType transitionType = LightingSceneTransitionType.None, float transitionDuration = 1f)\n        {\n            if (ActiveLightingScene == newLightingSceneName)\n            {   \n                return;\n            }\n\n            if (!CanSceneOpProceed(SceneType.Lighting))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            SceneInfo lightingScene;\n            RuntimeLightingSettings lightingSettings = default(RuntimeLightingSettings);\n            RuntimeRenderSettings renderSettings = default(RuntimeRenderSettings);\n            RuntimeSunlightSettings sunSettings = default(RuntimeSunlightSettings);\n            if (!string.IsNullOrEmpty(newLightingSceneName) &&!profile.GetLightingSceneSettings(\n                newLightingSceneName,\n                out lightingScene, \n                out lightingSettings, \n                out renderSettings,\n                out sunSettings))\n            {   \n                Debug.LogWarning(\"Couldn't find lighting scene \" + newLightingSceneName + \" in profile - taking no action.\");\n                return;\n            }\n\n            ActiveLightingScene = newLightingSceneName;\n\n            if (!Application.isPlaying)\n            {   \n                return;\n            }\n\n            \n            lightingExecutor.StartTransition(lightingSettings, renderSettings, sunSettings, transitionType, transitionDuration);\n\n            List<string> lightingSceneNames = new List<string>();\n            \n            foreach (SceneInfo lso in profile.LightingScenes)\n            {\n                if (lso.Name!= newLightingSceneName)\n                {\n                    lightingSceneNames.Add(lso.Name);\n                }\n            }\n\n            \n            await LoadScenesInternal(new string[] { newLightingSceneName }, SceneType.Lighting, null, 0f, 0.5",
    "code_repairing_3": "Claro, aqu\u00ed est\u00e1 la lista de los 10 planetas m\u00e1s cercanos a la Tierra, ordenados por distancia:\n\n1. Mercurio\n2. Venus\n3. Terra\n4. Marte\n5. J\u00fapiter\n6. Saturno\n7",
    "code_repairing_4": "The following C# code is based on Unity Development. Your task is to fix the code under the 'FIXED CODE:' area. In your response, only include your fixed code snippets. Do not output the original contents.\nPlease wrap your code answer using ```:\n\n```csharp\n\nusing Microsoft.MixedReality.Toolkit.Utilities;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing UnityEngine;\nusing UnityEngine.Rendering;\nusing UnityEngine.SceneManagement;\n\nnamespace Microsoft.MixedReality.Toolkit.SceneSystem\n{\n\n    public partial class MixedRealitySceneSystem : BaseCoreSystem, IMixedRealitySceneSystem\n    {\n        const float SceneActivationLoadProgress = 0.9f;\n\n        private enum SceneType\n        {\n            Manager = 0,\n            Content = 1,\n            Lighting = 2,\n        }\n\n        public MixedRealitySceneSystem(\n            IMixedRealityServiceRegistrar registrar,\n            MixedRealitySceneSystemProfile profile) : base(registrar, profile)\n        {\n            this.profile = profile;\n        }\n\n        private MixedRealitySceneSystemProfile profile;\n\n        private bool managerSceneOpInProgress;\n        private float managerSceneOpProgress;\n\n        private SceneContentTracker contentTracker;\n\n        private SceneLightingExecutor lightingExecutor;\n\n        public override string Name { get; protected set; } = \"Mixed Reality Scene System\";\n\n        #region Actions\n\n        public Action<IEnumerable<string>> OnWillLoadContent { get; set; }\n\n        public Action<IEnumerable<string>> OnContentLoaded { get; set; }\n\n        public Action<IEnumerable<string>> OnWillUnloadContent { get; set; }\n\n        public Action<IEnumerable<string>> OnContentUnloaded { get; set; }\n\n        public Action<string> OnWillLoadLighting { get; set; }\n\n        public Action<string> OnLightingLoaded { get; set; }\n\n        public Action<string> OnWillUnloadLighting { get; set; }\n\n        public Action<string> OnLightingUnloaded { get; set; }\n\n        public Action<string> OnWillLoadScene { get; set; }\n\n        public Action<string> OnSceneLoaded { get; set; }\n\n        public Action<string> OnWillUnloadScene { get; set; }\n\n        public Action<string> OnSceneUnloaded { get; set; }\n\n        #endregion\n\n        #region Properties\n\n        public bool SceneOperationInProgress { get; private set; } = false;\n\n        public float SceneOperationProgress { get; private set; } = 0;\n\n        public bool LightingOperationInProgress { get; private set; } = false;\n\n        public float LightingOperationProgress { get; private set; } = 0;\n\n        public string ActiveLightingScene { get; private set; } = string.Empty;\n\n        public bool WaitingToProceed { get; private set; } = false;\n\n        public bool PrevContentExists => contentTracker.PrevContentExists;\n\n        public bool NextContentExists => contentTracker.NextContentExists;\n\n        public string[] ContentSceneNames => contentTracker.ContentSceneNames;\n\n        public uint SourceId { get; } = 0;\n\n        public string SourceName { get; } = \"Mixed Reality Scene System\";\n\n        #endregion\n\n        #region Service Methods\n\n        public override void Initialize()\n        {\n            contentTracker = new SceneContentTracker(profile);\n            lightingExecutor = new SceneLightingExecutor();\n\n#if UNITY_EDITOR\n            EditorOnInitialize();\n#endif\n\n            if (!Application.isPlaying)\n            {\n                return;\n            }\n\n            if (profile.UseManagerScene)\n            {\n                SetManagerScene(profile.ManagerScene.Name);\n            }\n\n            if (profile.UseLightingScene)\n            {\n                SetLightingScene(profile.DefaultLightingScene.Name, LightingSceneTransitionType.None);\n            }\n        }\n\n        public override void Enable()\n        {\n#if UNITY_EDITOR\n            EditorOnDisable();\n#endif\n        }\n\n        public override void Disable()\n        {\n#if UNITY_EDITOR\n            EditorOnDisable();\n#endif\n        }\n\n        public override void Destroy()\n        {\n#if UNITY_EDITOR\n            EditorOnDestroy();\n#endif\n        }\n\n        public override void Update()\n        {\n            if (profile.UseLightingScene)\n            {\n                lightingExecutor.UpdateTransition(Time.unscaledDeltaTime);\n            }\n        }\n\n        #endregion\n\n        #region Scene Operations\n\n        public async Task LoadNextContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            string nextContent;\n            if (contentTracker.GetNextContent(wrap, out nextContent))\n            {\n                await LoadContent(new string[] { nextContent }, mode, activationToken);\n            }\n            else\n            {\n                Debug.LogWarning(\"Attempted to load next content when no next content exists. Taking no action.\");\n            }\n        }\n\n        public async Task LoadPrevContent(bool wrap = false, LoadSceneMode mode = LoadSceneMode.Single, SceneActivationToken activationToken = null)\n        {\n            string prevContent;\n            if (contentTracker.GetPrevContent(wrap, out prevContent))\n            {\n                await LoadContent(new string[] { prevContent }, mode, activationToken);\n            }\n            else\n            {\n                Debug.LogWarning(\"Attempted to load prev content when no next content exists. Taking no action.\");\n            }\n        }\n\n        public async Task LoadContent(string sceneToLoad, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            await LoadContent(new string[] { sceneToLoad }, mode, activationToken);\n        }\n\n        public async Task UnloadContent(string sceneToUnload)\n        {\n            await UnloadContent(new string[] { sceneToUnload });\n        }\n\n        public async Task LoadContentByTag(string tag, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            await LoadContent(profile.GetContentSceneNamesByTag(tag), mode, activationToken);\n        }\n\n        public async Task UnloadContentByTag(string tag)\n        {\n            await UnloadScenesInternal(profile.GetContentSceneNamesByTag(tag), SceneType.Content);\n        }\n\n        public async Task LoadContent(IEnumerable<string> scenesToLoad, LoadSceneMode mode = LoadSceneMode.Additive, SceneActivationToken activationToken = null)\n        {\n            if (!CanSceneOpProceed(SceneType.Content))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            IEnumerable<string> loadedContentScenes;\n            if (mode == LoadSceneMode.Single && GetLoadedContentScenes(out loadedContentScenes))\n            {\n                await UnloadScenesInternal(loadedContentScenes, SceneType.Content, 0, 0.5f, true);\n                await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken, 0.5f, 1f, false);\n            }\n            else\n            {\n                await LoadScenesInternal(scenesToLoad, SceneType.Content, activationToken);\n            }\n        }\n\n        public async Task UnloadContent(IEnumerable<string> scenesToUnload)\n        {\n            if (!CanSceneOpProceed(SceneType.Content))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            await UnloadScenesInternal(scenesToUnload, SceneType.Content);\n        }\n\n        public bool IsContentLoaded(string sceneName)\n        {\n            Scene scene = SceneManager.GetSceneByName(sceneName);\n            return scene.IsValid() && scene.isLoaded;\n        }\n\n        public async void SetLightingScene(string newLightingSceneName, LightingSceneTransitionType transitionType = LightingSceneTransitionType.None, float transitionDuration = 1f)\n        {\n            if (ActiveLightingScene == newLightingSceneName)\n            {\n                return;\n            }\n\n            if (!CanSceneOpProceed(SceneType.Lighting))\n            {\n                Debug.LogError(\"Attempting to perform a scene op when a scene op is already in progress.\");\n                return;\n            }\n\n            SceneInfo lightingScene;\n            RuntimeLightingSettings lightingSettings = default(RuntimeLightingSettings);\n            RuntimeRenderSettings renderSettings = default(RuntimeRenderSettings);\n            RuntimeSunlightSettings sunSettings = default(RuntimeSunlightSettings);\n            if (!string.IsNullOrEmpty(newLightingSceneName) &&!profile.GetLightingSceneSettings(\n                newLightingSceneName,\n                out lightingScene,\n                out lightingSettings,\n                out renderSettings,\n                out sunSettings))\n            {\n                Debug.LogWarning(\"Couldn't find lighting scene \" + newLightingSceneName + \" in profile - taking no action.\");\n                return;\n            }\n\n            ActiveLightingScene = newLightingSceneName;\n\n            if (!Application.isPlaying)\n            {\n                return;\n            }\n\n            lightingExecutor.StartTransition(lightingSettings, renderSettings, sunSettings, transitionType, transitionDuration);\n\n            List<string> lightingSceneNames = new List<string>();\n\n            foreach (SceneInfo lso in profile.LightingScenes)\n            {\n                if (lso.Name!= newLightingSceneName)\n                {\n                    lightingSceneNames.Add(lso.Name);\n                }\n            }\n\n            await LoadScenesInternal(new string[] { newLightingSceneName }, SceneType.Lighting, null, 0f, 0.5f, true);\n\n            await UnloadScenesInternal(lightingSceneNames, SceneType.Lighting,"
}